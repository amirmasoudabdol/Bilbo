{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SAM \u00b6 SAM is an extensible and modular framework for simulating and studying effects of various questionable research practices, QRPs, on scientific results. It provides interfaces and APIs for designing, and experimenting on several statistical models under the influence of various p -hacking strategies as well as other types of QRPs. For instance, the user is able to design a simulation to could design a two-by-two factorial experiment and study the effect of optional stopping on achieving significant results. SAM offers analysis of a number of conventional and recognized p -hacking methods out of the box; additionally, the user will be able to implement new methods based on her preferences. In this vignette, we will describe the underlying design principles and main features of SAM alongside some examples. In the Design section, we describe types of problems that SAM analyses. After setting the ground rules, we describes different components of SAM and the process of designing your own simulation. Note The contents of this documentation might be slightly differ from the information published by Abdol et al., 2021 1 . For general introduction to SAM, please refer to the main publication while we sync the two sources. The preparation of this project and its related material was supported by an ERC consolidator grant IMPROVE (grant no. 603726361) from the European Research Council. Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9","title":"Home"},{"location":"#sam","text":"SAM is an extensible and modular framework for simulating and studying effects of various questionable research practices, QRPs, on scientific results. It provides interfaces and APIs for designing, and experimenting on several statistical models under the influence of various p -hacking strategies as well as other types of QRPs. For instance, the user is able to design a simulation to could design a two-by-two factorial experiment and study the effect of optional stopping on achieving significant results. SAM offers analysis of a number of conventional and recognized p -hacking methods out of the box; additionally, the user will be able to implement new methods based on her preferences. In this vignette, we will describe the underlying design principles and main features of SAM alongside some examples. In the Design section, we describe types of problems that SAM analyses. After setting the ground rules, we describes different components of SAM and the process of designing your own simulation. Note The contents of this documentation might be slightly differ from the information published by Abdol et al., 2021 1 . For general introduction to SAM, please refer to the main publication while we sync the two sources. The preparation of this project and its related material was supported by an ERC consolidator grant IMPROVE (grant no. 603726361) from the European Research Council. Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9","title":"SAM"},{"location":"about/","text":"About \u00b6","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"change-log/","text":"","title":"Change log"},{"location":"configuration-file/","text":"Attention The contents of this documentation might slightly differ from the information published by Abdol et al., 2021 1 . For general introduction to SAM, please refer to the main publication while we sync the two sources. Configuration File \u00b6 SAM uses a JSON file to load and save all simulation parameters. The code block below shows a general configuration file used by SAM. As highlighted, the config file is separated into 4 different sections, each corresponding to one of SAM's component discussed previously. In this chapter, we will discuss each section, and learn how to configure each module separately; in order to be able to customize and configure all processes of execution , research and hacking workflows. Sample Configuration File { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"n_obs\" : 25 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.4 , 0.4 ], \"covs\" : 0.5 , \"stddevs\" : 1.0 } }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.005 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } }, \"researcher_parameters\" : { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"sig\" , \"min(pvalue)\" ] ], \"will_start_hacking_decision_policies\" : [ \"!sig\" ], \"stashing_policy\" : [ \"\" ], \"between_hacks_selection_policies\" : [ [ \"\" ] ], \"between_replications_selection_policies\" : [ [ \"\" ] ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] }, \"probability_of_being_a_hacker\" : 1 , \"probability_of_committing_a_hack\" : 1 , \"hacking_strategies\" : [], \"is_pre_processing\" : false , \"pre_processing_methods\" : [ \"\" ] }, \"journal_parameters\" : { \"max_pubs\" : 24 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.05 , \"pub_bias\" : 0.1 , \"side\" : 0 } }, \"simulation_parameters\" : { \"log_level\" : \"info\" , \"master_seed\" : \"random\" , \"n_sims\" : 1 , \"output_path\" : \"../outputs/\" , \"output_prefix\" : \"sample_sim\" , \"update_config\" : true , \"progress\" : false , \"save_all_pubs\" : false , \"save_meta\" : true , \"save_overall_summaries\" : true , \"save_pubs_per_sim_summaries\" : true , \"save_rejected\" : false } } About JSON For the introduction to JSON, see here or here . Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9","title":"Introduction"},{"location":"configuration-file/#configuration-file","text":"SAM uses a JSON file to load and save all simulation parameters. The code block below shows a general configuration file used by SAM. As highlighted, the config file is separated into 4 different sections, each corresponding to one of SAM's component discussed previously. In this chapter, we will discuss each section, and learn how to configure each module separately; in order to be able to customize and configure all processes of execution , research and hacking workflows. Sample Configuration File { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"n_obs\" : 25 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.4 , 0.4 ], \"covs\" : 0.5 , \"stddevs\" : 1.0 } }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.005 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } }, \"researcher_parameters\" : { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"sig\" , \"min(pvalue)\" ] ], \"will_start_hacking_decision_policies\" : [ \"!sig\" ], \"stashing_policy\" : [ \"\" ], \"between_hacks_selection_policies\" : [ [ \"\" ] ], \"between_replications_selection_policies\" : [ [ \"\" ] ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] }, \"probability_of_being_a_hacker\" : 1 , \"probability_of_committing_a_hack\" : 1 , \"hacking_strategies\" : [], \"is_pre_processing\" : false , \"pre_processing_methods\" : [ \"\" ] }, \"journal_parameters\" : { \"max_pubs\" : 24 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.05 , \"pub_bias\" : 0.1 , \"side\" : 0 } }, \"simulation_parameters\" : { \"log_level\" : \"info\" , \"master_seed\" : \"random\" , \"n_sims\" : 1 , \"output_path\" : \"../outputs/\" , \"output_prefix\" : \"sample_sim\" , \"update_config\" : true , \"progress\" : false , \"save_all_pubs\" : false , \"save_meta\" : true , \"save_overall_summaries\" : true , \"save_pubs_per_sim_summaries\" : true , \"save_rejected\" : false } } About JSON For the introduction to JSON, see here or here . Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9","title":"Configuration File"},{"location":"contact/","text":"","title":"Contact"},{"location":"data-strategies/","text":"Data Strategies \u00b6 Data Strategy is the source of data, i.e., population. It knows the underlying design, and its properties . During the research preperation stage, the Researcher reaches our to the Data Strategy object and uses it to populates \u2014 ie., generates/collects data for \u2014 its Experiment. Study Design \u00b6 Parameters of Data Strategy are intertwined with experiment design parameters. Before defining the model, we need to specify the structure of our design, number of observations in each group, and number of replications (if applicable). Study design is specified by assigning the number of conditions, n ( n_conditions ), and the number of dependent variables in each condition, m ( n_dep_vars ). After specifying our design, each group is going to be populated by n_obs observations based on the given model, specified in data_strategy . { \"experiment_parameters\" : { \"n_reps\" : 5 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"data_strategy\" : { \"name\" : \"\" , ... } } } We can configure types and specifications of the model using data_strategy parameters. In the rest of this section, we discuss the specification of Linear Model and Graded Response Model data strategies as the two currently avilable methods. Linear Model \u00b6 In the case of Linear Model, SAM models \\bar{y} = \\bar{x} + \\bar{\\epsilon} \\bar{y} = \\bar{x} + \\bar{\\epsilon} where \\bar{x} \\bar{x} and \\bar{\\epsilon} \\bar{\\epsilon} are vectors of values drawn either from a single multivariate distribution, or a set of univariate distributions. Two following configurations showcase variants of this setup. As it is shown, it is possible to mix and match uni- and multi-variate distributions in order to acheive a certain population characteristics. SAM supports a wide range of statistical distributions . While most distirbutions accept a set of predefined parameters, multivariate normal distribution offers some helper parameters for easier configuration, Table 1. For instance, we are able to set a fixed value for covariance and standard deviation and guide SAM to generate an appropriate covariance matrix., e.g., setting stddevs to 1, and covs to 0 leads to the generation of Identity matrix of m \u00d7 n . TODO: Improve the table Parameters Value / Type means \u03bc , double or array stddevs \u03c3 2 , double or array covs \u03c3 x y , double sigma \u03a3 , matrix Linear Model Configuration: Multivariate Normal { \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0.2 ], \"covs\" : 0.0 , \"stddevs\" : 1.0 }, \"errors\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 ], \"covs\" : 0.0 , \"stddevs\" : 1.0 } } Linear Model Configuration: Custom Distributions { \"data_strategy\" : { \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0.2 ], \"covs\" : 0.0 , \"stddevs\" : 1.0 }, \"errors\" : [ { \"dist\" : \"cauchy_distribution\" , \"a\" : 0 , \"b\" : 0.1 }, { \"dist\" : \"cauchy_distribution\" , \"a\" : 0 , \"b\" : 0.1 } ] } Warning It's important to keep in mind that the given distribution should be able to account for the pre-defined study design; otherwise, SAM cannot initialize the Experiment and an error will occur. General Graded Response Model 1 \u00b6 The current implementation of the Graded Response Model is based on the model introduced by Samejima 1 where we use Rasch model as the default response function. According to Rasch model, the probablity of person j j answering an item i i correctly, Pr(X_{ij} = 1) Pr(X_{ij} = 1) , can be calculated based on the difficulty, \\beta_{i} \\beta_{i} , of the item i i and the ability, \\theta_{j} \\theta_{j} , of a person j j with the following model 2 : Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} Besides general design parameters , we need to provide number of categories , as well as number of items per category to be able to completely setup a GRM. Thereafter, like before, we also need to define the underlying distributions of abilities and difficulties . Figure 2 shows the schematic of GRM as it is being implemented in SAM. General Graded Response Model TODO: Improve the table Parameters Value / Type n_items int abilities \u03b8 , a multivariate distribution, or a list of univariate distributions n_categories int difficulties \u03b2 , a multivariate distribution, or a list of univariate distributions Note: SAM models the GRM using the threshold model, therefore for c categories, we need to provide k - 1 distributions, or dimension in the case utilizing multivariate distribution. An example of GRM configuration can be found below, with it, we model a study with 2 groups, 10 items, and 3 categories for each item, while examinee's abilities is drawn from a multivariate normal distribution of \u03b8 ~ MN(O, I). For more elaborate usecase of this model, see Bakker et al., 2014 . Graded Response Model Configuration { \"name\" : \"GradedResponseModel\" , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"data_strategy\" : { \"n_items\" : 10 , \"abilities\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"n_categories\" : 3 , \"difficulties\" : [ { \"dist\" : \"normal_distribution\" , \"mean\" : 0 , \"stddev\" : 1.0 }, { \"dist\" : \"normal_distribution\" , \"mean\" : 0 , \"stddev\" : 1.0 } ], } } Info Since SAM is mainly a C++ library, it supports all available statistical distributions available in STL . For multivariate distributions, SAM uses available distributions in baaraan library. Fumiko Samejima. Graded Response Model , pages 85\u2013100. Springer New York, New York, NY, 1997. URL: https://doi.org/10.1007/978-1-4757-2691-6_5 , doi:10.1007/978-1-4757-2691-6_5 . \u21a9 \u21a9 Susan E Embretson and Steven Paul Reise. Item response theory for psychologists. Maheah . New Jersey: Lawrence Erlbaum Associates, Publishers, 2000. \u21a9","title":"Data Strategies"},{"location":"data-strategies/#data-strategies","text":"Data Strategy is the source of data, i.e., population. It knows the underlying design, and its properties . During the research preperation stage, the Researcher reaches our to the Data Strategy object and uses it to populates \u2014 ie., generates/collects data for \u2014 its Experiment.","title":"Data Strategies"},{"location":"data-strategies/#study-design","text":"Parameters of Data Strategy are intertwined with experiment design parameters. Before defining the model, we need to specify the structure of our design, number of observations in each group, and number of replications (if applicable). Study design is specified by assigning the number of conditions, n ( n_conditions ), and the number of dependent variables in each condition, m ( n_dep_vars ). After specifying our design, each group is going to be populated by n_obs observations based on the given model, specified in data_strategy . { \"experiment_parameters\" : { \"n_reps\" : 5 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"data_strategy\" : { \"name\" : \"\" , ... } } } We can configure types and specifications of the model using data_strategy parameters. In the rest of this section, we discuss the specification of Linear Model and Graded Response Model data strategies as the two currently avilable methods.","title":"Study Design"},{"location":"data-strategies/#linear-model","text":"In the case of Linear Model, SAM models \\bar{y} = \\bar{x} + \\bar{\\epsilon} \\bar{y} = \\bar{x} + \\bar{\\epsilon} where \\bar{x} \\bar{x} and \\bar{\\epsilon} \\bar{\\epsilon} are vectors of values drawn either from a single multivariate distribution, or a set of univariate distributions. Two following configurations showcase variants of this setup. As it is shown, it is possible to mix and match uni- and multi-variate distributions in order to acheive a certain population characteristics. SAM supports a wide range of statistical distributions . While most distirbutions accept a set of predefined parameters, multivariate normal distribution offers some helper parameters for easier configuration, Table 1. For instance, we are able to set a fixed value for covariance and standard deviation and guide SAM to generate an appropriate covariance matrix., e.g., setting stddevs to 1, and covs to 0 leads to the generation of Identity matrix of m \u00d7 n . TODO: Improve the table Parameters Value / Type means \u03bc , double or array stddevs \u03c3 2 , double or array covs \u03c3 x y , double sigma \u03a3 , matrix Linear Model Configuration: Multivariate Normal { \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0.2 ], \"covs\" : 0.0 , \"stddevs\" : 1.0 }, \"errors\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 ], \"covs\" : 0.0 , \"stddevs\" : 1.0 } } Linear Model Configuration: Custom Distributions { \"data_strategy\" : { \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0.2 ], \"covs\" : 0.0 , \"stddevs\" : 1.0 }, \"errors\" : [ { \"dist\" : \"cauchy_distribution\" , \"a\" : 0 , \"b\" : 0.1 }, { \"dist\" : \"cauchy_distribution\" , \"a\" : 0 , \"b\" : 0.1 } ] } Warning It's important to keep in mind that the given distribution should be able to account for the pre-defined study design; otherwise, SAM cannot initialize the Experiment and an error will occur.","title":"Linear Model"},{"location":"data-strategies/#general-graded-response-model1","text":"The current implementation of the Graded Response Model is based on the model introduced by Samejima 1 where we use Rasch model as the default response function. According to Rasch model, the probablity of person j j answering an item i i correctly, Pr(X_{ij} = 1) Pr(X_{ij} = 1) , can be calculated based on the difficulty, \\beta_{i} \\beta_{i} , of the item i i and the ability, \\theta_{j} \\theta_{j} , of a person j j with the following model 2 : Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} Besides general design parameters , we need to provide number of categories , as well as number of items per category to be able to completely setup a GRM. Thereafter, like before, we also need to define the underlying distributions of abilities and difficulties . Figure 2 shows the schematic of GRM as it is being implemented in SAM. General Graded Response Model TODO: Improve the table Parameters Value / Type n_items int abilities \u03b8 , a multivariate distribution, or a list of univariate distributions n_categories int difficulties \u03b2 , a multivariate distribution, or a list of univariate distributions Note: SAM models the GRM using the threshold model, therefore for c categories, we need to provide k - 1 distributions, or dimension in the case utilizing multivariate distribution. An example of GRM configuration can be found below, with it, we model a study with 2 groups, 10 items, and 3 categories for each item, while examinee's abilities is drawn from a multivariate normal distribution of \u03b8 ~ MN(O, I). For more elaborate usecase of this model, see Bakker et al., 2014 . Graded Response Model Configuration { \"name\" : \"GradedResponseModel\" , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 25 , \"data_strategy\" : { \"n_items\" : 10 , \"abilities\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"n_categories\" : 3 , \"difficulties\" : [ { \"dist\" : \"normal_distribution\" , \"mean\" : 0 , \"stddev\" : 1.0 }, { \"dist\" : \"normal_distribution\" , \"mean\" : 0 , \"stddev\" : 1.0 } ], } } Info Since SAM is mainly a C++ library, it supports all available statistical distributions available in STL . For multivariate distributions, SAM uses available distributions in baaraan library. Fumiko Samejima. Graded Response Model , pages 85\u2013100. Springer New York, New York, NY, 1997. URL: https://doi.org/10.1007/978-1-4757-2691-6_5 , doi:10.1007/978-1-4757-2691-6_5 . \u21a9 \u21a9 Susan E Embretson and Steven Paul Reise. Item response theory for psychologists. Maheah . New Jersey: Lawrence Erlbaum Associates, Publishers, 2000. \u21a9","title":"General Graded Response Model1"},{"location":"decision-strategies/","text":"Decision Strategies \u00b6 Decision strategy acts as researcher's brain, and describes his/her logical steps. Its specification will be used by the Researcher to perform two fundamentals tasks, Selection and Decision. As discussed in the Design section, in most cases a Selection is followed by a Decision, directly evaluating the already selected outcome. We will refer to this process as Selection \u2192 Decision sequence. These sequences are the building block of decision strategy. We use utilize them in several different stages of Research , and Hacking workflows in order to mimic the thought process of the Researcher and guide him throughout his research. As researcher needs to perform several selections and decisions during her course of research, each selection and decision is defined separately in the configuration file. Figure 1 shows a simplified version of research workflow by only highlighing Selection and Decision stages. The diagram also replaces logical names with their parameter names counterpart as they are lsited in decision_strategy section of configurtion file . Figure 1. Decision Workflow. Rectangles are representing a Selection steps while diamonds are Decision steps. Figure 1 highlights 4 main Selection \u2192 Decision sequences of research and hackingw workflow. Here we Initial sequence Performing a selection on an original experiment Evaluating the selected outcome (if any) to make a decision on whether to enter the Hacking Workflow . While Hacking sequences Performing a selection on an altered experiment Stashing Step: Selecting certain outcomes for building a database of alternated outcomes Evaluating the selected outcome (if any) to make a decision on whether to continue with the rest of hacking strategies. After Hacking sequences Performing a selection on the database of altered outcomes (collected during hacking workflow), stashed results . Evaluating the selected outcome \u2014 from the database of altered outcomes \u2014 to make a decision on whether to replicate the study. Before Submission sequences Evaluating the final submission, S F , to make decision on whether to submit the final submission to the Journal. All possible selections and decisions steps can be found in the list below: initial_selection_policies will_start_hacking_decision_policies stashing_policy h_s_selection h_s_decision ... between_hacks_selection_policies between_replications_selection_policies will_continue_replicating_decision_policy submission_decision_policies Policies \u00b6 Policies are the building blocks of researcher\u2019s logic. Each policy is a logical expression describing a query to be performed on list of available outcome variables. Here we discuss a range of available logical expression and variables that can be used to construct any elaborate quesries. Policy \u00b6 A policy is a string consists of a function and a variable. A function defines a kind of a query that is going to be applied on an experiment, and the variable specifies the parameter of the experiment that is going to be queried. For instance, min(pvalue) policy will query experiment\u2019s outcomes for the outcome with the minimum p -value. List of available functions for constructing a policy is: min(x) , returns an outcome with minimum x parameters among all outcomes max(x) , returns an outcome with maximum x parameters among all outcomes first , returns the first items in the list last , returns the last items of the list sig , returns a list of significant outomces all , returns all outcomes uniary operator, ! binary operators, > , < , >= , <= , == And list of all available parameters: id , a unique identifier of outcome variables nobs , number of observations associated with outcome variables mean , the mean value associated with the outcome variables pvalue , the p -value associated with outcome variables effect , the effect size associated with outcome variables sig , the significant flag associated with outcome variables, set by comapring pvalue against \u0251. Any combinations of listed functions and parameters can be used to create a policy. For instance, max(pvalue) , returns an outcome variable with maximum p -value max(effect) , returns an outcome variable with minimum effect sig , returns outcome variables that are significant !sig , returns outcome variables that are not significant effect > 0 , return outcome variables with positive effect pvalue < 0.025 , return outcome variables with p -value lower than 0.025 id == 5 , returns outcome the outcome variable with the id set to 5. Policy Chain, PC \u00b6 A policy chain is a list of queries applied one after another on an experiment. They are the main mean of constructing larger and more complicated queries. For example, [\u201csig\u201d, \u201cmin(pvalue)\u201d] queries an experiment for a list of significant outcomes and among them returns the one with minimum p -value. As demonstrated, policies will be applied one after another in a hierarchal order; in fact, they should be seen as AND statements, \"sig\" AND \"min(pvalue)\" , that are going to be applied on Experiments. Important Decision (s) are defined in term of policy chains. In fact, decisions are set of queries assessing the truth of their policies. For instance, will_start_hacking_decision_policies is helping a researcher to decide on whether to start the hacking procedure. Policy Chain Set, PCS \u00b6 A policy chain set is a set of policy chains. Policy chain sets are mainly being used in Selection steps. A researcher goes through every policy chain in a hierarchal order and stops as soon as one returns a unique outcome. { \"initial_selection_policies\" : [ [ \u201csig\u201d , \u201cmi n (pvalue)\u201d ], [ \u201ce ffe c t > 0 \u201d , \u201cmi n (pvalue)\u201d ], [ \u201ce ffe c t < 0 \u201d , \u201c f irs t \u201d ] ] } For instance, research with the selection policy chain set above: starts by looking for [\u201csig\u201d, \u201cmin(pvalue)\u201d] if there is no outcome with these properties, he moves to search for [\u201ceffect > 0\u201d, \u201cmin(pvalue)\u201d] , and finally, if that returns no unique outcome, he applies the last set of queries on the Experiment. Policy chain sets are designed to mimic behaviors of a researchers with multiple priorities. An example of this behavior is demonstrated in Bakker et al., 2012 simulation . Example: Bakker et al., 2012's Decision Strategy { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"between_hacks_selection_policies\" : [ [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"between_replications_selection_policies\" : [ [ \"effect > 0\" , \"sig\" , \"first\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"initial_selection_policies\" : [ [ \"id == 2\" , \"sig\" , \"effect > 0\" ], [ \"id == 3\" , \"sig\" , \"effect > 0\" ] ], \"stashing_policy\" : [ \"all\" ], \"submission_decision_policies\" : [ \"\" ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"will_start_hacking_decision_policies\" : [ \"effect < 0\" , \"!sig\" ] } }","title":"Decision Strategies"},{"location":"decision-strategies/#decision-strategies","text":"Decision strategy acts as researcher's brain, and describes his/her logical steps. Its specification will be used by the Researcher to perform two fundamentals tasks, Selection and Decision. As discussed in the Design section, in most cases a Selection is followed by a Decision, directly evaluating the already selected outcome. We will refer to this process as Selection \u2192 Decision sequence. These sequences are the building block of decision strategy. We use utilize them in several different stages of Research , and Hacking workflows in order to mimic the thought process of the Researcher and guide him throughout his research. As researcher needs to perform several selections and decisions during her course of research, each selection and decision is defined separately in the configuration file. Figure 1 shows a simplified version of research workflow by only highlighing Selection and Decision stages. The diagram also replaces logical names with their parameter names counterpart as they are lsited in decision_strategy section of configurtion file . Figure 1. Decision Workflow. Rectangles are representing a Selection steps while diamonds are Decision steps. Figure 1 highlights 4 main Selection \u2192 Decision sequences of research and hackingw workflow. Here we Initial sequence Performing a selection on an original experiment Evaluating the selected outcome (if any) to make a decision on whether to enter the Hacking Workflow . While Hacking sequences Performing a selection on an altered experiment Stashing Step: Selecting certain outcomes for building a database of alternated outcomes Evaluating the selected outcome (if any) to make a decision on whether to continue with the rest of hacking strategies. After Hacking sequences Performing a selection on the database of altered outcomes (collected during hacking workflow), stashed results . Evaluating the selected outcome \u2014 from the database of altered outcomes \u2014 to make a decision on whether to replicate the study. Before Submission sequences Evaluating the final submission, S F , to make decision on whether to submit the final submission to the Journal. All possible selections and decisions steps can be found in the list below: initial_selection_policies will_start_hacking_decision_policies stashing_policy h_s_selection h_s_decision ... between_hacks_selection_policies between_replications_selection_policies will_continue_replicating_decision_policy submission_decision_policies","title":"Decision Strategies"},{"location":"decision-strategies/#policies","text":"Policies are the building blocks of researcher\u2019s logic. Each policy is a logical expression describing a query to be performed on list of available outcome variables. Here we discuss a range of available logical expression and variables that can be used to construct any elaborate quesries.","title":"Policies"},{"location":"decision-strategies/#policy","text":"A policy is a string consists of a function and a variable. A function defines a kind of a query that is going to be applied on an experiment, and the variable specifies the parameter of the experiment that is going to be queried. For instance, min(pvalue) policy will query experiment\u2019s outcomes for the outcome with the minimum p -value. List of available functions for constructing a policy is: min(x) , returns an outcome with minimum x parameters among all outcomes max(x) , returns an outcome with maximum x parameters among all outcomes first , returns the first items in the list last , returns the last items of the list sig , returns a list of significant outomces all , returns all outcomes uniary operator, ! binary operators, > , < , >= , <= , == And list of all available parameters: id , a unique identifier of outcome variables nobs , number of observations associated with outcome variables mean , the mean value associated with the outcome variables pvalue , the p -value associated with outcome variables effect , the effect size associated with outcome variables sig , the significant flag associated with outcome variables, set by comapring pvalue against \u0251. Any combinations of listed functions and parameters can be used to create a policy. For instance, max(pvalue) , returns an outcome variable with maximum p -value max(effect) , returns an outcome variable with minimum effect sig , returns outcome variables that are significant !sig , returns outcome variables that are not significant effect > 0 , return outcome variables with positive effect pvalue < 0.025 , return outcome variables with p -value lower than 0.025 id == 5 , returns outcome the outcome variable with the id set to 5.","title":"Policy"},{"location":"decision-strategies/#policy-chain-pc","text":"A policy chain is a list of queries applied one after another on an experiment. They are the main mean of constructing larger and more complicated queries. For example, [\u201csig\u201d, \u201cmin(pvalue)\u201d] queries an experiment for a list of significant outcomes and among them returns the one with minimum p -value. As demonstrated, policies will be applied one after another in a hierarchal order; in fact, they should be seen as AND statements, \"sig\" AND \"min(pvalue)\" , that are going to be applied on Experiments. Important Decision (s) are defined in term of policy chains. In fact, decisions are set of queries assessing the truth of their policies. For instance, will_start_hacking_decision_policies is helping a researcher to decide on whether to start the hacking procedure.","title":"Policy Chain, PC"},{"location":"decision-strategies/#policy-chain-set-pcs","text":"A policy chain set is a set of policy chains. Policy chain sets are mainly being used in Selection steps. A researcher goes through every policy chain in a hierarchal order and stops as soon as one returns a unique outcome. { \"initial_selection_policies\" : [ [ \u201csig\u201d , \u201cmi n (pvalue)\u201d ], [ \u201ce ffe c t > 0 \u201d , \u201cmi n (pvalue)\u201d ], [ \u201ce ffe c t < 0 \u201d , \u201c f irs t \u201d ] ] } For instance, research with the selection policy chain set above: starts by looking for [\u201csig\u201d, \u201cmin(pvalue)\u201d] if there is no outcome with these properties, he moves to search for [\u201ceffect > 0\u201d, \u201cmin(pvalue)\u201d] , and finally, if that returns no unique outcome, he applies the last set of queries on the Experiment. Policy chain sets are designed to mimic behaviors of a researchers with multiple priorities. An example of this behavior is demonstrated in Bakker et al., 2012 simulation . Example: Bakker et al., 2012's Decision Strategy { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"between_hacks_selection_policies\" : [ [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"between_replications_selection_policies\" : [ [ \"effect > 0\" , \"sig\" , \"first\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"initial_selection_policies\" : [ [ \"id == 2\" , \"sig\" , \"effect > 0\" ], [ \"id == 3\" , \"sig\" , \"effect > 0\" ] ], \"stashing_policy\" : [ \"all\" ], \"submission_decision_policies\" : [ \"\" ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"will_start_hacking_decision_policies\" : [ \"effect < 0\" , \"!sig\" ] } }","title":"Policy Chain Set, PCS"},{"location":"design/","text":"Attention The contents of this documentation might slightly differ from the information published by Abdol et al., 2021 1 . For general introduction to SAM, please refer to the main publication while we sync the two sources. Design \u00b6 First, we will review a common process of defining, conducting and reporting scientific research. In this section, we describe a simplified process of producing scientific result . In order to define a list of components and entities involved in different stages of conducting research. Later, in the Design section, we will explain how each component is represented in SAM. The Scientific Research Process \u00b6 The process of producing scientific research is often a cumbersome and complicated process. A typical scientific study starts by formulating a hypothesis when a Researcher jots down her ideas about how a certain process influences a certain phenomenon or how she thinks a complicated system works. In order to test this hypothesis, she sets up an experiment in which the underlying parameters and boundaries of her theories and ideas are defined. After the Experiment Setup is finalized, an Experiment is conducted in which the Researcher aims to collect certain types of data in order to test her hypothesis, e.g., questionnaire results, sensors data, images, etc. The next step is (pre-)processing and analysis of the data, which leads to a conclusion evaluating her initial hypothesis (a.k.a results). If the results are informative \u2014 regardless of agreeing or disagreeing with the initial hypothesis (i.e., pre-registered hypothesis ) \u2014 the Researcher selects a Journal and submits her findings in the form of a Manuscript, for it to be reviewed according to the Journal's criteria. Finally, the Journal will decide whether the submitted manuscript is published. Figure 1. The Simplified Process of Producing a Scientific Publication/Result. Meta-analysis \u00b6 It has been shown and discussed [cite, cite], the aforementioned process is often long and prone to errors in every different stage. The natural complexity of conducting a research, together with the large number of degrees of freedom available to researchers and journals, will undoubtedly affect the quality of research and publications [cite, cite]. Researchers may make mistakes, and journals may select a particular set of publications based on erroneous or outdated criteria. As a result, various biases will accumulate the pool of publications and ultimately affect our understanding of a certain topic [cite, cite, cite]. Studying this interaction between Researchers , their Research , Journals (i.e. the publishing medium), and Publications (i.e., Knowledge ), is a challenging task 2 , 3 . The list of degrees of freedom is long 4 , 5 [cite], and researchers are insufficiently aware of the consequences of certain procedures on the final outcome of their research. In recent years, the field of meta-analysis has grown in size and popularity in an attempt to evaluate and account for the various biases introduced by this process. As a result, the scientific community have defined and documented the effects of researchers' degrees of freedom on published results [cite] and the unwanted outcomes of journals' tendency to publish positive and novel results [cite]. For example, it has been shown that the process of adding new data points to an experiment \u2014 after the initial data collection \u2014 is a widespread practice 4 , 5 and it has a severe effect on researchers' ability to create significant results; and therefore makes their research more appealing to biased journals, and consequently skew our collective knowledge. While meta-analysts and statisticians are hard at work to identify and correct for these issues, lack of data and the complicated nature of aforementioned interactions make it challenging to address this issue systematically. To the extend that the scientific community cannot agree on the effects and propagative impacts of questionable research practices on our collective knowledge [cite, papers supporting some of the qrps], a.k.a, true effect size . SAM \u00b6 With SAM, we are hoping to address this issue. We are developing a standardize and flexible framework for studying of these processes and interactions. SAM streamlines the process of designing and executing large simulation studies covering as many aspects of performing scientific research as possible, from designing the experiment setup to the process of reviewing and accepting research by journals. Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9 Marjan Bakker, Annette van Dijk, and Jelte M. Wicherts. The rules of the game called psychological science. Perspectives on Psychological Science , 7 6 6 :543\u2013554, nov 2012. URL: https://doi.org/10.1177%2F1745691612459060 , doi:10.1177/1745691612459060 . \u21a9 Marjan Bakker and Jelte M. Wicherts. Outlier removal, sum scores, and the inflation of the type i error rate in independent samples t tests: the power of alternatives and recommendations. Psychological Methods , 19 3 3 :409\u2013427, 2014. URL: https://doi.org/10.1037%2Fmet0000014 , doi:10.1037/met0000014 . \u21a9 Leslie K John, George Loewenstein, and Drazen Prelec. Measuring the prevalence of questionable research practices with incentives for truth telling. Psychol Sci , 23 5 5 :524\u201332, May 2012. doi:10.1177/0956797611430953 . \u21a9 \u21a9 Franca Agnoli, Jelte M. Wicherts, Coosje L. S. Veldkamp, Paolo Albiero, and Roberto Cubelli. Questionable research practices among italian research psychologists. PLOS ONE , 12 3 3 :e0172792, mar 2017. URL: https://doi.org/10.1371%2Fjournal.pone.0172792 , doi:10.1371/journal.pone.0172792 . \u21a9 \u21a9","title":"Introduction"},{"location":"design/#design","text":"First, we will review a common process of defining, conducting and reporting scientific research. In this section, we describe a simplified process of producing scientific result . In order to define a list of components and entities involved in different stages of conducting research. Later, in the Design section, we will explain how each component is represented in SAM.","title":"Design"},{"location":"design/#the-scientific-research-process","text":"The process of producing scientific research is often a cumbersome and complicated process. A typical scientific study starts by formulating a hypothesis when a Researcher jots down her ideas about how a certain process influences a certain phenomenon or how she thinks a complicated system works. In order to test this hypothesis, she sets up an experiment in which the underlying parameters and boundaries of her theories and ideas are defined. After the Experiment Setup is finalized, an Experiment is conducted in which the Researcher aims to collect certain types of data in order to test her hypothesis, e.g., questionnaire results, sensors data, images, etc. The next step is (pre-)processing and analysis of the data, which leads to a conclusion evaluating her initial hypothesis (a.k.a results). If the results are informative \u2014 regardless of agreeing or disagreeing with the initial hypothesis (i.e., pre-registered hypothesis ) \u2014 the Researcher selects a Journal and submits her findings in the form of a Manuscript, for it to be reviewed according to the Journal's criteria. Finally, the Journal will decide whether the submitted manuscript is published. Figure 1. The Simplified Process of Producing a Scientific Publication/Result.","title":"The Scientific Research Process"},{"location":"design/#meta-analysis","text":"It has been shown and discussed [cite, cite], the aforementioned process is often long and prone to errors in every different stage. The natural complexity of conducting a research, together with the large number of degrees of freedom available to researchers and journals, will undoubtedly affect the quality of research and publications [cite, cite]. Researchers may make mistakes, and journals may select a particular set of publications based on erroneous or outdated criteria. As a result, various biases will accumulate the pool of publications and ultimately affect our understanding of a certain topic [cite, cite, cite]. Studying this interaction between Researchers , their Research , Journals (i.e. the publishing medium), and Publications (i.e., Knowledge ), is a challenging task 2 , 3 . The list of degrees of freedom is long 4 , 5 [cite], and researchers are insufficiently aware of the consequences of certain procedures on the final outcome of their research. In recent years, the field of meta-analysis has grown in size and popularity in an attempt to evaluate and account for the various biases introduced by this process. As a result, the scientific community have defined and documented the effects of researchers' degrees of freedom on published results [cite] and the unwanted outcomes of journals' tendency to publish positive and novel results [cite]. For example, it has been shown that the process of adding new data points to an experiment \u2014 after the initial data collection \u2014 is a widespread practice 4 , 5 and it has a severe effect on researchers' ability to create significant results; and therefore makes their research more appealing to biased journals, and consequently skew our collective knowledge. While meta-analysts and statisticians are hard at work to identify and correct for these issues, lack of data and the complicated nature of aforementioned interactions make it challenging to address this issue systematically. To the extend that the scientific community cannot agree on the effects and propagative impacts of questionable research practices on our collective knowledge [cite, papers supporting some of the qrps], a.k.a, true effect size .","title":"Meta-analysis"},{"location":"design/#sam","text":"With SAM, we are hoping to address this issue. We are developing a standardize and flexible framework for studying of these processes and interactions. SAM streamlines the process of designing and executing large simulation studies covering as many aspects of performing scientific research as possible, from designing the experiment setup to the process of reviewing and accepting research by journals. Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9 Marjan Bakker, Annette van Dijk, and Jelte M. Wicherts. The rules of the game called psychological science. Perspectives on Psychological Science , 7 6 6 :543\u2013554, nov 2012. URL: https://doi.org/10.1177%2F1745691612459060 , doi:10.1177/1745691612459060 . \u21a9 Marjan Bakker and Jelte M. Wicherts. Outlier removal, sum scores, and the inflation of the type i error rate in independent samples t tests: the power of alternatives and recommendations. Psychological Methods , 19 3 3 :409\u2013427, 2014. URL: https://doi.org/10.1037%2Fmet0000014 , doi:10.1037/met0000014 . \u21a9 Leslie K John, George Loewenstein, and Drazen Prelec. Measuring the prevalence of questionable research practices with incentives for truth telling. Psychol Sci , 23 5 5 :524\u201332, May 2012. doi:10.1177/0956797611430953 . \u21a9 \u21a9 Franca Agnoli, Jelte M. Wicherts, Coosje L. S. Veldkamp, Paolo Albiero, and Roberto Cubelli. Questionable research practices among italian research psychologists. PLOS ONE , 12 3 3 :e0172792, mar 2017. URL: https://doi.org/10.1371%2Fjournal.pone.0172792 , doi:10.1371/journal.pone.0172792 . \u21a9 \u21a9","title":"SAM"},{"location":"distributinos/","text":"Distributions \u00b6","title":"Distributions"},{"location":"distributinos/#distributions","text":"","title":"Distributions"},{"location":"effect-strategies/","text":"Effect Strategies \u00b6 Effect Strategies are being used to compute effect sizes of every outcome variables in an Experiment. Like most methods, we configure an Effect Strategy by specifying the method name, and its appropriate parameters, if any. Configuration: Effect Strategy { \"experiment_parameters\" : { ... , \"data_strategy\" : { ... }, \"test_strategy\" : { ... }, \"effect_strategy\" : { \"name\" : \"MethodName\" } } } Mean Differences \u00b6 TODO: Add descsription and reference d = \\mu_1 - \\mu_2 d = \\mu_1 - \\mu_2 \"effect_strategy\" : { \"name\" : \"MeanDifference\" } Standardized Mean Differences \u00b6 TODO: Add descsription and reference d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} where s s is an average standard deviation of both groups, \\sqrt{\\frac{s_{1}^2 + s_{2}^2}{2}} \\sqrt{\\frac{s_{1}^2 + s_{2}^2}{2}} , where the variance for one of the groups is defined as s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 \"effect_strategy\" : { \"name\" : \"StandardizedMeanDifference\" } Cohen's D \u00b6 TODO: Add descsription and reference d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} where s s , the pooled standard deviation is defined as: s = \\sqrt{\\frac{(n_1-1)s^2_1 + (n_2-1)s^2_2}{n_1+n_2 - 2}} s = \\sqrt{\\frac{(n_1-1)s^2_1 + (n_2-1)s^2_2}{n_1+n_2 - 2}} where the variance for one of the groups is defined as s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 \"effect_strategy\" : { \"name\" : \"CohensD\" } Hedge's G \u00b6 TODO: Add descsription and reference \"effect_strategy\" : { \"name\" : \"HedgesG\" }","title":"Effect Strategies"},{"location":"effect-strategies/#effect-strategies","text":"Effect Strategies are being used to compute effect sizes of every outcome variables in an Experiment. Like most methods, we configure an Effect Strategy by specifying the method name, and its appropriate parameters, if any. Configuration: Effect Strategy { \"experiment_parameters\" : { ... , \"data_strategy\" : { ... }, \"test_strategy\" : { ... }, \"effect_strategy\" : { \"name\" : \"MethodName\" } } }","title":"Effect Strategies"},{"location":"effect-strategies/#mean-differences","text":"TODO: Add descsription and reference d = \\mu_1 - \\mu_2 d = \\mu_1 - \\mu_2 \"effect_strategy\" : { \"name\" : \"MeanDifference\" }","title":"Mean Differences"},{"location":"effect-strategies/#standardized-mean-differences","text":"TODO: Add descsription and reference d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} where s s is an average standard deviation of both groups, \\sqrt{\\frac{s_{1}^2 + s_{2}^2}{2}} \\sqrt{\\frac{s_{1}^2 + s_{2}^2}{2}} , where the variance for one of the groups is defined as s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 \"effect_strategy\" : { \"name\" : \"StandardizedMeanDifference\" }","title":"Standardized Mean Differences"},{"location":"effect-strategies/#cohens-d","text":"TODO: Add descsription and reference d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} d = \\frac{\\bar{x}_1 - \\bar{x}_2}{s} = \\frac{\\mu_1 - \\mu_2}{s} where s s , the pooled standard deviation is defined as: s = \\sqrt{\\frac{(n_1-1)s^2_1 + (n_2-1)s^2_2}{n_1+n_2 - 2}} s = \\sqrt{\\frac{(n_1-1)s^2_1 + (n_2-1)s^2_2}{n_1+n_2 - 2}} where the variance for one of the groups is defined as s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 s_i^2 = \\frac 1 {n_1-1} \\sum_{i=1}^{n_1} (x_{1,i} - \\bar{x}_1)^2 \"effect_strategy\" : { \"name\" : \"CohensD\" }","title":"Cohen's D"},{"location":"effect-strategies/#hedges-g","text":"TODO: Add descsription and reference \"effect_strategy\" : { \"name\" : \"HedgesG\" }","title":"Hedge's G"},{"location":"execution-flow/","text":"Execution Flow \u00b6 SAM simulates the process of producing scientific research through several sub-processes as depicted in Figure 1. Each rounded rectangle describes a process that is either performed entirely by one of the components or through a collaboration between different ones. This chapter describes each process in more details. In this section, we expand each process to their sub-processes and describe the overall execution flow of a simulation. Figure 1. Overall Execution Flow of SAM Info In the this and following sections, we will use flowchart diagrams to visualize and express processes and algorithms. If you are not familiar with general syntax of flowcharts, please read the Wikipedia article on Flowcharts . Initialization \u00b6 During the initialization phase, SAMs loads a configuration file and initializes many of its compartments based on the given parameters. Figure 2. Initialization Routine. By the end of the initialization step, the Researcher knows his Experiment Setup, his overall plan for conducting the research and has decided on his arsenal of possible questionable research practices. Additionally, the Journal is initialized and ready to review Researcher's submissions. Preparing the Research \u00b6 The preparation of research is the first step of the simulation. At this stage, The Researcher uses the information provided within the Experiment Setup and collects data points for each group and dependent variable. Figure 3. Preparing the Research. By the end of this stage, the Experiment is populated with data points and the Researcher is ready to conduct his research as prescribed within the configuration file. Performing the Research \u00b6 At this stage, the Researcher uses the Test Strategy to run the test and populate relevant variables, e.g., statistic , pvalue , sig , side . Similarly, Effect Strategy will be used to calculate effect sizes, and populate effect variable. The next step is to check whether the Researcher is satisfied with the test results. This is done by passing the Experiment to the Decision Strategy. The Researcher relies on decision strategy's verdict to decide on whether to proceed with the current Submission, or continue applying one or more of the hacking strategies before submitting the study for the review. This process will be discussed in more details in Research Workflow and Decision Strategy . Figure 4. Steps involved in performing the research By the end of this stage, the Researcher has finished his research and is ready to prepare his Submission, ie., manuscript. Publishing the Research \u00b6 This last stage simulates the preparation process of the final manuscript and consequently sending it to the Journal for review. After finalizing the research and applying any of QRPs (if necessary), the Researcher prepares his final Submission. This is done through the logic coded within the Decision Strategy module. In the case where the Researcher finds an outcome, a Submission record will be created and submitted/sent to the Journal. If the Researcher is not satisfied with any of the available outcome, he discards the Experiment, and skips the rest of this stage. The Journal evaluates the received Submission based on the criteria defined by the Selection Strategy module. If accepted, the Journal adds the submission to its publications list for further analysis. Figure 5. Steps involving publishing a research Despite what happens to the Experiment and Submission (ie., discardment, rejection or acceptance by the Journal), the Researcher is done by the current Experiment and initializes a new Experiment.","title":"Execution Flow"},{"location":"execution-flow/#execution-flow","text":"SAM simulates the process of producing scientific research through several sub-processes as depicted in Figure 1. Each rounded rectangle describes a process that is either performed entirely by one of the components or through a collaboration between different ones. This chapter describes each process in more details. In this section, we expand each process to their sub-processes and describe the overall execution flow of a simulation. Figure 1. Overall Execution Flow of SAM Info In the this and following sections, we will use flowchart diagrams to visualize and express processes and algorithms. If you are not familiar with general syntax of flowcharts, please read the Wikipedia article on Flowcharts .","title":"Execution Flow"},{"location":"execution-flow/#initialization","text":"During the initialization phase, SAMs loads a configuration file and initializes many of its compartments based on the given parameters. Figure 2. Initialization Routine. By the end of the initialization step, the Researcher knows his Experiment Setup, his overall plan for conducting the research and has decided on his arsenal of possible questionable research practices. Additionally, the Journal is initialized and ready to review Researcher's submissions.","title":"Initialization"},{"location":"execution-flow/#preparing-the-research","text":"The preparation of research is the first step of the simulation. At this stage, The Researcher uses the information provided within the Experiment Setup and collects data points for each group and dependent variable. Figure 3. Preparing the Research. By the end of this stage, the Experiment is populated with data points and the Researcher is ready to conduct his research as prescribed within the configuration file.","title":"Preparing the Research"},{"location":"execution-flow/#performing-the-research","text":"At this stage, the Researcher uses the Test Strategy to run the test and populate relevant variables, e.g., statistic , pvalue , sig , side . Similarly, Effect Strategy will be used to calculate effect sizes, and populate effect variable. The next step is to check whether the Researcher is satisfied with the test results. This is done by passing the Experiment to the Decision Strategy. The Researcher relies on decision strategy's verdict to decide on whether to proceed with the current Submission, or continue applying one or more of the hacking strategies before submitting the study for the review. This process will be discussed in more details in Research Workflow and Decision Strategy . Figure 4. Steps involved in performing the research By the end of this stage, the Researcher has finished his research and is ready to prepare his Submission, ie., manuscript.","title":"Performing the Research"},{"location":"execution-flow/#publishing-the-research","text":"This last stage simulates the preparation process of the final manuscript and consequently sending it to the Journal for review. After finalizing the research and applying any of QRPs (if necessary), the Researcher prepares his final Submission. This is done through the logic coded within the Decision Strategy module. In the case where the Researcher finds an outcome, a Submission record will be created and submitted/sent to the Journal. If the Researcher is not satisfied with any of the available outcome, he discards the Experiment, and skips the rest of this stage. The Journal evaluates the received Submission based on the criteria defined by the Selection Strategy module. If accepted, the Journal adds the submission to its publications list for further analysis. Figure 5. Steps involving publishing a research Despite what happens to the Experiment and Submission (ie., discardment, rejection or acceptance by the Journal), the Researcher is done by the current Experiment and initializes a new Experiment.","title":"Publishing the Research"},{"location":"experiment-configurations/","text":"Experiment Configurations \u00b6 Experiment parameters split into 4 main sections. While first four paramters are describing the overall design of the study, parameters of each individual module are encapsulated into three sections, ie., Data Strategy , Test Strategies , and Effect Strategies . Parameter Type Description n_reps integer Indicates the number of replications of the same research. n_conditions integer Indicates the number of conditions, m . Excluding the control group. n_dep_vars integer Indicates the number of dependent variables in each condition, n . n_obs integer , array , Parameter Indicates the number of observations per group data_strategy string Specify the underlying Data Strategy . test_strategy string Specify the underlying Test Strategies . effect_strategy string Specify the underlying Effect Strategies . The code snippet below showcases a sample of Experiment's parameters that's being used in Bakker et al., 2012 . Experiment's Configurations \"experiment_parameters\" : { \"n_obs\" : 20 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 , 0.25 , 0.25 ], \"sigma\" : [[ 1.0 , 0.5 , 0.0 , 0.0 ], [ 0.5 , 1.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.0 , 0.5 ], [ 0.0 , 0.0 , 0.5 , 1.0 ]] }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } }","title":"Introduction"},{"location":"experiment-configurations/#experiment-configurations","text":"Experiment parameters split into 4 main sections. While first four paramters are describing the overall design of the study, parameters of each individual module are encapsulated into three sections, ie., Data Strategy , Test Strategies , and Effect Strategies . Parameter Type Description n_reps integer Indicates the number of replications of the same research. n_conditions integer Indicates the number of conditions, m . Excluding the control group. n_dep_vars integer Indicates the number of dependent variables in each condition, n . n_obs integer , array , Parameter Indicates the number of observations per group data_strategy string Specify the underlying Data Strategy . test_strategy string Specify the underlying Test Strategies . effect_strategy string Specify the underlying Effect Strategies . The code snippet below showcases a sample of Experiment's parameters that's being used in Bakker et al., 2012 . Experiment's Configurations \"experiment_parameters\" : { \"n_obs\" : 20 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 , 0.25 , 0.25 ], \"sigma\" : [[ 1.0 , 0.5 , 0.0 , 0.0 ], [ 0.5 , 1.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.0 , 0.5 ], [ 0.0 , 0.0 , 0.5 , 1.0 ]] }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } }","title":"Experiment Configurations"},{"location":"extending-sam/","text":"Extending SAM \u00b6","title":"Extending SAM"},{"location":"extending-sam/#extending-sam","text":"","title":"Extending SAM"},{"location":"hacking-behaviors/","text":"Hacking Behaviors \u00b6 TODO: Add some intro Probability of Being a Hacker \u00b6 The probability of being a hacker is a value between 0 and 1 which determines whether the Researcher is executing the hacking workflow. Besides a fixed value, we are able to define a distribution to be used for each Researcher, for instance: \"probability_of_being_a_hacker\" : { \"dist\" : \"uniform_real_distribution\" , \"a\" : 0 , \"b\" : 1 } In this case, for each new Researcher, SAM draws a value from the given distribution and set the chance of him entering the Hacking Workflow. This setting allows for design and simulation of population of Researchers each with different probablity of being a hacker. Probability of Committing to a Hack \u00b6 The probability of committing to a hack is a value between 0 and 1 which determines whether the Researcher applies a hacking strategy on a given Experiment,. Like before, while we can use a fixed value or a distribution for this parameters. Hacking Commitment Strategy \u00b6 Additionally, we are able to define a specific function to calcualte this probability based on the content of the Experiment. For instance, we may define a function that adjust this probability based on the distance of p -value from \u0251. In this case, the Researcher could individually evaluate each Experiment and decide on whether he wants to commit to a QRP based on the properties of the current Experiment. This allows for a much more fine-grained filtering and execution of QRPs, and overall smarter Researchers. In Friese et al. 2020 [^1] example, we utilize this parameter to implement their dynamic approach of calculating researcher's interest in hacking the p -value based on its distance to \u0251, and the calculated effect size. \"hacking_probability_strategy\" : { \"method\" : \"FrankenbachStrategy\" , \"base_hp\" : params [ \"hacking_prob_base_hp\" ], \"lo_p\" : 0.2 , \"hi_p\" : 0.4 , \"lo_sei\" : 0.1 , \"hi_sei\" : 0.6 } Number of Hacking Strategies \u00b6 The n_hacks parameters determine how many of the hacking strategies are going to be selected and used by the researcher. Omitting this parameter will result in selection of all available parameters. Hacking Strategies' Selection Priority \u00b6 If the value of n_hacks ( h n ) parameter is smaller than the total number of hacking strategies listed ( h t ), a researcher must select h n methods from the set of given strategies. This selection can be done in various ways: Based on items prevalence asc(prevalence) desc(prevalence) Based on items defensibility asc(defensibility) desc(defensibility) Randomly, random Given ordered, \u200c Hacking Strategies Execution's Order \u00b6 Similarly, when it comes to the execution of hacking strategies, researcher may decide which method he/she would likes to apply first. This can be based on similar criteria as described in hacking_execution_order : Available values for hacking_execution_order : Based on items prevalence asc(prevalence) desc(prevalence) Based on items defensibility asc(defensibility) desc(defensibility) Randomly, random Given ordered, \u200c","title":"Hacking Behaviors"},{"location":"hacking-behaviors/#hacking-behaviors","text":"TODO: Add some intro","title":"Hacking Behaviors"},{"location":"hacking-behaviors/#probability-of-being-a-hacker","text":"The probability of being a hacker is a value between 0 and 1 which determines whether the Researcher is executing the hacking workflow. Besides a fixed value, we are able to define a distribution to be used for each Researcher, for instance: \"probability_of_being_a_hacker\" : { \"dist\" : \"uniform_real_distribution\" , \"a\" : 0 , \"b\" : 1 } In this case, for each new Researcher, SAM draws a value from the given distribution and set the chance of him entering the Hacking Workflow. This setting allows for design and simulation of population of Researchers each with different probablity of being a hacker.","title":"Probability of Being a Hacker"},{"location":"hacking-behaviors/#probability-of-committing-to-a-hack","text":"The probability of committing to a hack is a value between 0 and 1 which determines whether the Researcher applies a hacking strategy on a given Experiment,. Like before, while we can use a fixed value or a distribution for this parameters.","title":"Probability of Committing to a Hack"},{"location":"hacking-behaviors/#hacking-commitment-strategy","text":"Additionally, we are able to define a specific function to calcualte this probability based on the content of the Experiment. For instance, we may define a function that adjust this probability based on the distance of p -value from \u0251. In this case, the Researcher could individually evaluate each Experiment and decide on whether he wants to commit to a QRP based on the properties of the current Experiment. This allows for a much more fine-grained filtering and execution of QRPs, and overall smarter Researchers. In Friese et al. 2020 [^1] example, we utilize this parameter to implement their dynamic approach of calculating researcher's interest in hacking the p -value based on its distance to \u0251, and the calculated effect size. \"hacking_probability_strategy\" : { \"method\" : \"FrankenbachStrategy\" , \"base_hp\" : params [ \"hacking_prob_base_hp\" ], \"lo_p\" : 0.2 , \"hi_p\" : 0.4 , \"lo_sei\" : 0.1 , \"hi_sei\" : 0.6 }","title":"Hacking Commitment Strategy"},{"location":"hacking-behaviors/#number-of-hacking-strategies","text":"The n_hacks parameters determine how many of the hacking strategies are going to be selected and used by the researcher. Omitting this parameter will result in selection of all available parameters.","title":"Number of Hacking Strategies"},{"location":"hacking-behaviors/#hacking-strategies-selection-priority","text":"If the value of n_hacks ( h n ) parameter is smaller than the total number of hacking strategies listed ( h t ), a researcher must select h n methods from the set of given strategies. This selection can be done in various ways: Based on items prevalence asc(prevalence) desc(prevalence) Based on items defensibility asc(defensibility) desc(defensibility) Randomly, random Given ordered, \u200c","title":"Hacking Strategies' Selection Priority"},{"location":"hacking-behaviors/#hacking-strategies-executions-order","text":"Similarly, when it comes to the execution of hacking strategies, researcher may decide which method he/she would likes to apply first. This can be based on similar criteria as described in hacking_execution_order : Available values for hacking_execution_order : Based on items prevalence asc(prevalence) desc(prevalence) Based on items defensibility asc(defensibility) desc(defensibility) Randomly, random Given ordered, \u200c","title":"Hacking Strategies Execution's Order"},{"location":"hacking-strategies/","text":"Hacking Strategies \u00b6 Hacking Strategy encapsulates vairous processes and procedures of performing a questionable research practices on a given Experiment. SAM is capable of executing a complicated set of hacking strategies on a given Experiment. A list of hacking strategies will be applied one at a time, in the specified order. At the end of each method, the Researcher observes their influences on all outcome variables and decides on whether to stop, or what to report if results are satisfactory, see here and here . Besides the definition of hacking strategies, we are able to modify researcher's behavior as well. In the configuration below, we can see the main body of defining hacking strategies for a researcher. Above the list of hacking strategies, a collection of parameters modify the behavior of the Researcher throughout the Hacking Workflow . While we will cover these parameters in detail in Hacking Behavior section, a list below briefly describes their function. probability_of_being_a_hacker , double , indicates the chance of chance of the Researcher entering the hacking workflow. probability_of_committing_a_hack , double , indicates the chance of applying a given method on the Experiment. For a detailed example, see Friese et al. 2020 [^1] n_hacks , integer , indicates the number of hacking strategies to be selected from the list. hacking_selection_priority , indicates the priority of hacking strategies during at selection stages hacking_execution_order , indicates the execution order of hacking strategies during the execution of hacking workflow . hacking_strategies , a list of hacking strategies and their selection \u2192 decision sequences, see Figure 1. Hacking Strategy: Top Level Settings { \"researcher_parameters\" : { \"probability_of_being_a_hacker\" : 1 , \"probability_of_committing_a_hack\" : 1 , \"n_hacks: 3, \" hacki n g_selec t io n _priori t y \": \" ra n dom \" \" hacki n g_execu t io n _order \": \" ra n dom \" \" hacki n g_s trate gies \": [ [ // Hacking Strategy Specification { \" na me \": \" H 1 \" }, // Selection [ [] ], // Decision [] ], ... ] } } Highlighted lines of the code block above showcases a sequence of hacking \u2192 selection \u2192 decision . This corresponds to the highlighted region of the [Hacking Workflow] flowchart shown in Figure 1. TODO: Add more explanation TODO: Add an example for a complete hacking strategy Figure 1. Hacking Step Hacking Strategy Specification \u00b6 While each hacking strategy is accompanied with its list of unique parameters, all method must share a set of common parameters. name , string , each strategy should contains a name parameters, that's how SAM recognizes and configures each method, a list of available methods can be found in the left-hand side menu. stage , string , indicates on which stage of the research workflow, researcher is allowed to apply this method, see hacking stage . defensibility , double , defensibility of a strategy indicates researcher's perception of how acceptable a given method is in his/her field prevalence , double , prevalence of a strategy indicates researcher's perception of how widespread a given method is among his/her fellow researchers. target , string , indicates which groups will be targeted by the hacking strategy. Control Treatment Both stopping_condition , an optional policy chain indicating the stopping criteria of the method. { \"name\": \"OutliersRemoval\", \"target\": \"Both\", \"stage\": \"PostProcessing\", \"max_attempts\": 1, \"min_observations\": 1, \"multipliers\": [2], \"n_attempts\": 1, \"num\": 10, \"order\": \"random\", \u201cstopping_condition\u201d: [\u201cpre-reg\u201d, \u201csig\u201d] } Prevalence and Defensibility \u00b6 The prevalence and defensibility can be adjusted based on our preferences and type of simulations that we are going to conduct. There are higher level information at researcher's hand which helps him to make more informed decision during the hacking workflow. For insurance, we can define a cautious researcher who only applies strategies with high defensibility, ie., outliers removal. This is being enforced using hacking_execution_order and it will be discussed in hacking behaviors stage. Hacking Stages \u00b6 Not all QRPs can be applied during every stage of conducting research. For instance, its preferred to apply the Questionable Rounding method after exploring other methods, and just before applying the Submission to the Journal. In addition, some strategies can be applied in different stages, for instance, Outliers Removal can be applied both during pre- and post-processing stages. The stage parameter controls this aspect of QRPs. While we set a logical default values for each method, we can enforce the execution of a method out of its usual stage. Here we list all available stages, as well as methods that are usually being applied during this stage: Setup DataCollection Stopping Data Collection PreProcessing Outliers Removal PostProcessing Outliers Removal Optional Stopping Fabricating Data Falsifying Data Reporting Questionable Rounding","title":"Introduction"},{"location":"hacking-strategies/#hacking-strategies","text":"Hacking Strategy encapsulates vairous processes and procedures of performing a questionable research practices on a given Experiment. SAM is capable of executing a complicated set of hacking strategies on a given Experiment. A list of hacking strategies will be applied one at a time, in the specified order. At the end of each method, the Researcher observes their influences on all outcome variables and decides on whether to stop, or what to report if results are satisfactory, see here and here . Besides the definition of hacking strategies, we are able to modify researcher's behavior as well. In the configuration below, we can see the main body of defining hacking strategies for a researcher. Above the list of hacking strategies, a collection of parameters modify the behavior of the Researcher throughout the Hacking Workflow . While we will cover these parameters in detail in Hacking Behavior section, a list below briefly describes their function. probability_of_being_a_hacker , double , indicates the chance of chance of the Researcher entering the hacking workflow. probability_of_committing_a_hack , double , indicates the chance of applying a given method on the Experiment. For a detailed example, see Friese et al. 2020 [^1] n_hacks , integer , indicates the number of hacking strategies to be selected from the list. hacking_selection_priority , indicates the priority of hacking strategies during at selection stages hacking_execution_order , indicates the execution order of hacking strategies during the execution of hacking workflow . hacking_strategies , a list of hacking strategies and their selection \u2192 decision sequences, see Figure 1. Hacking Strategy: Top Level Settings { \"researcher_parameters\" : { \"probability_of_being_a_hacker\" : 1 , \"probability_of_committing_a_hack\" : 1 , \"n_hacks: 3, \" hacki n g_selec t io n _priori t y \": \" ra n dom \" \" hacki n g_execu t io n _order \": \" ra n dom \" \" hacki n g_s trate gies \": [ [ // Hacking Strategy Specification { \" na me \": \" H 1 \" }, // Selection [ [] ], // Decision [] ], ... ] } } Highlighted lines of the code block above showcases a sequence of hacking \u2192 selection \u2192 decision . This corresponds to the highlighted region of the [Hacking Workflow] flowchart shown in Figure 1. TODO: Add more explanation TODO: Add an example for a complete hacking strategy Figure 1. Hacking Step","title":"Hacking Strategies"},{"location":"hacking-strategies/#hacking-strategy-specification","text":"While each hacking strategy is accompanied with its list of unique parameters, all method must share a set of common parameters. name , string , each strategy should contains a name parameters, that's how SAM recognizes and configures each method, a list of available methods can be found in the left-hand side menu. stage , string , indicates on which stage of the research workflow, researcher is allowed to apply this method, see hacking stage . defensibility , double , defensibility of a strategy indicates researcher's perception of how acceptable a given method is in his/her field prevalence , double , prevalence of a strategy indicates researcher's perception of how widespread a given method is among his/her fellow researchers. target , string , indicates which groups will be targeted by the hacking strategy. Control Treatment Both stopping_condition , an optional policy chain indicating the stopping criteria of the method. { \"name\": \"OutliersRemoval\", \"target\": \"Both\", \"stage\": \"PostProcessing\", \"max_attempts\": 1, \"min_observations\": 1, \"multipliers\": [2], \"n_attempts\": 1, \"num\": 10, \"order\": \"random\", \u201cstopping_condition\u201d: [\u201cpre-reg\u201d, \u201csig\u201d] }","title":"Hacking Strategy Specification"},{"location":"hacking-strategies/#prevalence-and-defensibility","text":"The prevalence and defensibility can be adjusted based on our preferences and type of simulations that we are going to conduct. There are higher level information at researcher's hand which helps him to make more informed decision during the hacking workflow. For insurance, we can define a cautious researcher who only applies strategies with high defensibility, ie., outliers removal. This is being enforced using hacking_execution_order and it will be discussed in hacking behaviors stage.","title":"Prevalence and Defensibility"},{"location":"hacking-strategies/#hacking-stages","text":"Not all QRPs can be applied during every stage of conducting research. For instance, its preferred to apply the Questionable Rounding method after exploring other methods, and just before applying the Submission to the Journal. In addition, some strategies can be applied in different stages, for instance, Outliers Removal can be applied both during pre- and post-processing stages. The stage parameter controls this aspect of QRPs. While we set a logical default values for each method, we can enforce the execution of a method out of its usual stage. Here we list all available stages, as well as methods that are usually being applied during this stage: Setup DataCollection Stopping Data Collection PreProcessing Outliers Removal PostProcessing Outliers Removal Optional Stopping Fabricating Data Falsifying Data Reporting Questionable Rounding","title":"Hacking Stages"},{"location":"journal-configurations/","text":"Journal Configurations \u00b6 At the end of the research workflow , the Researcher has either decided to discard his research, or, is preparing to submit his final submission to the Journal. At this point, he passes his manuscript to the Journal, and thereafter he will have no control over its destiny anymore. Journal module is designed to simulate the reviewing process. After receiving the submission (ie. Manuscript) from the Researcher, the Journal asses the quality of the research and decide on whether to accept or reject the submission. Journal\u2019s assessment is being conducted using a group of pre-defined algorithms, referred to as Selection Strategies . Figure 1. Journal\u2019s Reviewing Workflow Figure 1 shows the steps taken by the Journal during the review process. The Journal starts by querying the selection strategy for its verdict on whether the quality of the given submission. For example, a selection strategy that\u2019s designed to mimic publication bias might base its decision on availability of positive significant effect, and therefore reject 95% of non-significant results. If selection strategy approves the \u201cquality\u201d of the submission, submission will be accepted and stored in a database of accepted submissions, a.k.a, publications list . In contrast, rejected outcomes will not be published and stored in rejected submissions list . At the end of the simulation, journal may export any or all of these lists as CSV files for further analysis. Journal parameters are in general less elaborate than other modules and are divided into two main sections, Selection Strategy and Meta Analysis . max_pubs , integer , Indicates the maximum number of publications that is going to be accepted by Journal . selection_strategy , object , Indicates the specification of the Selection Strategy . meta_analysis_metrics , list , List of meta analysis methods together with their corresponding parameters. TODO: Explain the example below! Journal's Configurations \"journal_parameters\" : { \"max_pubs\" : 24 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.005 , \"pub_bias\" : 0.2 , \"side\" : 0 }, \"meta_analysis_metrics\" : [ { \"name\" : \"FixedEffectEstimator\" }, { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } ]","title":"Introduction"},{"location":"journal-configurations/#journal-configurations","text":"At the end of the research workflow , the Researcher has either decided to discard his research, or, is preparing to submit his final submission to the Journal. At this point, he passes his manuscript to the Journal, and thereafter he will have no control over its destiny anymore. Journal module is designed to simulate the reviewing process. After receiving the submission (ie. Manuscript) from the Researcher, the Journal asses the quality of the research and decide on whether to accept or reject the submission. Journal\u2019s assessment is being conducted using a group of pre-defined algorithms, referred to as Selection Strategies . Figure 1. Journal\u2019s Reviewing Workflow Figure 1 shows the steps taken by the Journal during the review process. The Journal starts by querying the selection strategy for its verdict on whether the quality of the given submission. For example, a selection strategy that\u2019s designed to mimic publication bias might base its decision on availability of positive significant effect, and therefore reject 95% of non-significant results. If selection strategy approves the \u201cquality\u201d of the submission, submission will be accepted and stored in a database of accepted submissions, a.k.a, publications list . In contrast, rejected outcomes will not be published and stored in rejected submissions list . At the end of the simulation, journal may export any or all of these lists as CSV files for further analysis. Journal parameters are in general less elaborate than other modules and are divided into two main sections, Selection Strategy and Meta Analysis . max_pubs , integer , Indicates the maximum number of publications that is going to be accepted by Journal . selection_strategy , object , Indicates the specification of the Selection Strategy . meta_analysis_metrics , list , List of meta analysis methods together with their corresponding parameters. TODO: Explain the example below! Journal's Configurations \"journal_parameters\" : { \"max_pubs\" : 24 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.005 , \"pub_bias\" : 0.2 , \"side\" : 0 }, \"meta_analysis_metrics\" : [ { \"name\" : \"FixedEffectEstimator\" }, { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } ]","title":"Journal Configurations"},{"location":"meta-analyses/","text":"Meta Analysis \u00b6 Meta analysis methods are being used by the Journal for two main purposes: Meta-Analytic Outputs . The Journal may use the specified meta-analysis methods to combine result of multiple studies, ie., publications list , at the end of each simulation cycle, ie., when it has collected max_pubs publications. Adaptive Selection Strategies . The Journal may use the meta-analytic outcomes to adjust its Selection Strategy and its acceptance rate. [under development] Meta-Analytic Outputs \u00b6 Collecting meta-analytic outputs is the main use-case of adding meta-analysis methods to Jouranl's configuration. This is done by adding each method to a list of meta_analysis_metrics under journal_parameters section. Like before, we can add any method-specific parameters to the list. In the case where we prefer using one method with two sets of different parameters, we can simply add a new method with the modified parameters. After each simulation cycle, when the list of accepted publications is ready, The Journal traveses through the list of methods, and computes their outcomes. Before restarting the simulation \u2014 and getting ready for a new set of submissions to arrive \u2014 the Journal saves all its publications, and their corresponding meta-analyses to different CSV files for further analysis by the user. Simulation configurations section lists all the different available output parameters. \"journal_parameters\" : { \"max_pubs\" : 24 , \"selection_strategy\" : { ... }, \"meta_analysis_metrics\" : [ { \"name\" : \"MethodName\" , \"param\" : ... }, { \"name\" : \"MethodName\" , \"param\" : ... }, ... ] } SAM offers a short list of meta-analysis methods and publication bias metrics, as presented in the rest of this section. Fixed Effect Estimator \u00b6 Fixed Effect Estimator Configurations { \"name\" : \"FixedEffectEstimator\" } Random Effect Estimator \u00b6 Random Effect Estimator Configurations { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" } List of available estimators are: DerSimonian-Laird Estimator 1 Egger's Test Estimator 2 \u00b6 Egger's Test Estimator Configurations { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } Trim and Fill Method 3 \u00b6 Trim and Fill Method Configurations { \"name\" : \"TrimAndFill\" , \"alpha\" : 0.1 , \"estimator\" : \"R0\" , \"side\" : \"auto\" } Begg's Rank Correlation 4 \u00b6 Rank Correlation Configurations { \"name\" : \"RankCorrelation\" , \"alpha\" : 0.1 , \"alternative\" : \"TwoSided\" } Test of Excess of Significant Findings 5 \u00b6 Test of Excess of Significant Findings Configurations { \"name\" : \"TestOfObsOverExptSig\" , \"alpha\" : 0.1 } Adaptive Selection Strategies \u00b6 Rebecca DerSimonian and Nan Laird. Meta-analysis in clinical trials. Controlled Clinical Trials , 7 3 3 :177\u2013188, sep 1986. URL: https://doi.org/10.1016%2F0197-2456%2886%2990046-2 , doi:10.1016/0197-2456 86 86 90046-2 . \u21a9 Matthias Egger, George Davey Smith, Martin Schneider, and Christoph Minder. Bias in meta-analysis detected by a simple, graphical test. BMJ , 315 7109 7109 :629\u2013634, 1997. \u21a9 Sue Duval and Richard Tweedie. Trim and fill: a simple funnel-plot\u2013based method of testing and adjusting for publication bias in meta-analysis. Biometrics , 56 2 2 :455\u2013463, 2000. URL: https://onlinelibrary.wiley.com/doi/abs/10.1111/j.0006-341X.2000.00455.x , arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.0006-341X.2000.00455.x , doi:10.1111/j.0006-341X.2000.00455.x . \u21a9 Colin B. Begg and Madhuchhanda Mazumdar. Operating characteristics of a rank correlation test for publication bias. Biometrics , 50 4 4 :1088\u20131101, 1994. URL: http://www.jstor.org/stable/2533446 . \u21a9 John PA Ioannidis and Thomas A Trikalinos. An exploratory test for an excess of significant findings. Clinical Trials: Journal of the Society for Clinical Trials , 4 3 3 :245\u2013253, jun 2007. URL: https://doi.org/10.1177%2F1740774507079441 , doi:10.1177/1740774507079441 . \u21a9","title":"Meta Analysis"},{"location":"meta-analyses/#meta-analysis","text":"Meta analysis methods are being used by the Journal for two main purposes: Meta-Analytic Outputs . The Journal may use the specified meta-analysis methods to combine result of multiple studies, ie., publications list , at the end of each simulation cycle, ie., when it has collected max_pubs publications. Adaptive Selection Strategies . The Journal may use the meta-analytic outcomes to adjust its Selection Strategy and its acceptance rate. [under development]","title":"Meta Analysis"},{"location":"meta-analyses/#meta-analytic-outputs","text":"Collecting meta-analytic outputs is the main use-case of adding meta-analysis methods to Jouranl's configuration. This is done by adding each method to a list of meta_analysis_metrics under journal_parameters section. Like before, we can add any method-specific parameters to the list. In the case where we prefer using one method with two sets of different parameters, we can simply add a new method with the modified parameters. After each simulation cycle, when the list of accepted publications is ready, The Journal traveses through the list of methods, and computes their outcomes. Before restarting the simulation \u2014 and getting ready for a new set of submissions to arrive \u2014 the Journal saves all its publications, and their corresponding meta-analyses to different CSV files for further analysis by the user. Simulation configurations section lists all the different available output parameters. \"journal_parameters\" : { \"max_pubs\" : 24 , \"selection_strategy\" : { ... }, \"meta_analysis_metrics\" : [ { \"name\" : \"MethodName\" , \"param\" : ... }, { \"name\" : \"MethodName\" , \"param\" : ... }, ... ] } SAM offers a short list of meta-analysis methods and publication bias metrics, as presented in the rest of this section.","title":"Meta-Analytic Outputs"},{"location":"meta-analyses/#fixed-effect-estimator","text":"Fixed Effect Estimator Configurations { \"name\" : \"FixedEffectEstimator\" }","title":"Fixed Effect Estimator"},{"location":"meta-analyses/#random-effect-estimator","text":"Random Effect Estimator Configurations { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" } List of available estimators are: DerSimonian-Laird Estimator 1","title":"Random Effect Estimator"},{"location":"meta-analyses/#eggers-test-estimator2","text":"Egger's Test Estimator Configurations { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 }","title":"Egger's Test Estimator2"},{"location":"meta-analyses/#trim-and-fill-method3","text":"Trim and Fill Method Configurations { \"name\" : \"TrimAndFill\" , \"alpha\" : 0.1 , \"estimator\" : \"R0\" , \"side\" : \"auto\" }","title":"Trim and Fill Method3"},{"location":"meta-analyses/#beggs-rank-correlation4","text":"Rank Correlation Configurations { \"name\" : \"RankCorrelation\" , \"alpha\" : 0.1 , \"alternative\" : \"TwoSided\" }","title":"Begg's Rank Correlation4"},{"location":"meta-analyses/#test-of-excess-of-significant-findings5","text":"Test of Excess of Significant Findings Configurations { \"name\" : \"TestOfObsOverExptSig\" , \"alpha\" : 0.1 }","title":"Test of Excess of Significant Findings5"},{"location":"meta-analyses/#adaptive-selection-strategies","text":"Rebecca DerSimonian and Nan Laird. Meta-analysis in clinical trials. Controlled Clinical Trials , 7 3 3 :177\u2013188, sep 1986. URL: https://doi.org/10.1016%2F0197-2456%2886%2990046-2 , doi:10.1016/0197-2456 86 86 90046-2 . \u21a9 Matthias Egger, George Davey Smith, Martin Schneider, and Christoph Minder. Bias in meta-analysis detected by a simple, graphical test. BMJ , 315 7109 7109 :629\u2013634, 1997. \u21a9 Sue Duval and Richard Tweedie. Trim and fill: a simple funnel-plot\u2013based method of testing and adjusting for publication bias in meta-analysis. Biometrics , 56 2 2 :455\u2013463, 2000. URL: https://onlinelibrary.wiley.com/doi/abs/10.1111/j.0006-341X.2000.00455.x , arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.0006-341X.2000.00455.x , doi:10.1111/j.0006-341X.2000.00455.x . \u21a9 Colin B. Begg and Madhuchhanda Mazumdar. Operating characteristics of a rank correlation test for publication bias. Biometrics , 50 4 4 :1088\u20131101, 1994. URL: http://www.jstor.org/stable/2533446 . \u21a9 John PA Ioannidis and Thomas A Trikalinos. An exploratory test for an excess of significant findings. Clinical Trials: Journal of the Society for Clinical Trials , 4 3 3 :245\u2013253, jun 2007. URL: https://doi.org/10.1177%2F1740774507079441 , doi:10.1177/1740774507079441 . \u21a9","title":"Adaptive Selection Strategies"},{"location":"modules/","text":"Modules \u00b6 In the previous section , we listed main components and entities involved in the different stages of conducting research, e.g., Experiment Setup, Experiment, Researcher, Submission, and Journal. In our model , each component is a semi-independent entity while the whole system and its processes (i.e. conducting scientific research) are defined through their interactions. One of our main design goals with SAM was to achieve a level of flexibility where we could change different aspects of each component. In order to achieve this, we decoupled the system to smaller \u2014 but conceptually meaningful \u2014 routines and entities. Figure 1. shows these components, and their dependencies and interactions with each other. SAM's main components and their interactions Attention Throughout this document, we use the color assigned to each module in Figure 1. to refer to them in different sections. This section describes the design principles behind each component, what they model in the real world and how they work and interact with each others to collectively simulate the process of producing scientific research. SAM's Main Components \u00b6 SAM consists of 3 main components, Experiment, Researcher and Journal . Each component mimics one of the subprocesses or entities that are discussed in the Introduction The list below briefly introduces each component alongside their roles. The Experiment comprises of several parts, each dealing with different aspects of a research, e.g., setup, data, test, effect. Experiment Setup holds the specification of the design. The Researcher can only set these parameters once, at the start of an experiment. In fact, the Experiment Setup implementation simulates the concept of pre-registration . Data Strategy is a routine used to generate data based on specified parameters in the Experiment Setup . Test Strategy is the statistical method of choice in the Experiment Setup for testing the result of an Experiment . Effect Strategy defines the method of calculating effect sizes in an Experiment . The Researcher module imitates the behaviors of a researcher, including possible questionable research practices conducted by him/her. The Researcher defines the Experiment Setup, generates and collects data, runs the statistical test, decides whether to preform any QRPs, prepares the Submission record, and finally submits its finding(s) to the Journal of her/his choice. Decision Strategy is the underlying logic and steps of performing the research, as well as selecting and reporting specific variables as the primary outcome in an Experiment . Hacking Strategy is a list of questionable research practices in the researcher's arsenal. In the case where the researcher decides to hack his/her way to finding significant results, he/she can use these methods. The Journal is a container of publications. The Journal keeps track of its publications and can utilize different metrics to adapts its selection strategy. Selection Strategy is the internal algorithm by which the journal decides whether a submission will be accepted. Submission is a concise report, acting as a scientific paper, or a manuscript that it is going to be submitted for review to the Journal. Note Unlike a real scientific journal that covers a wide range of research tracks, SAM's Journal in its current implementation assumes that all submitted publications are from one research track. In other words, SAM's journals are mainly acting as a pool for related studies ready to be analyzed using meta-analyses methods. The rest of this section discusses each component properties and rule in more details, and more information about each component can be found in their dedicated pages. Experiment \u00b6 As mentioned, an Experiment object acts as an umbrella for everything related to an actual experiment. This includes metadata (a.k.a Experiment Setup), raw data, method/model for generating the data, e.g., Linear Model , methods of testing the hypothesis, and calculating the effect. The Researcher object has complete control over every aspect of an Experiment with one exception : it can only read and not change the Experiment Setup object. This is an important factor when later on we discuss the concept of pre-registration. The main components of the Experiment are: Experiment Setup Data, an object containing actual data points Experiment Setup \u00b6 After the initialization phase, SAM treats the Experiment Setup object as a read-only object. During the initialization phase, SAM initializes and randomizes the Experiment Setup based on given parameters. Thereafter, Experiment Setup will stay intact in the code and will be used as a reference point in different stages. The main components of the Experiment Setup are: Design Parameters Number of conditions Number of dependent variables Number of observations per group Data Strategy Test Strategy Effect Strategy Data Strategy \u00b6 Data Strategy acts as the population of the study, i.e., data source. In most cases, an instance of the Data Strategy object uses a statistical model to sample data points and populates the Data object of the Experiment. Moreover, with certain p -hacking methods, e.g., optional stopping , the data strategy will be used to generate extra data points as requested by the optional stopping. Available data strategies are: Linear Model Graded Response Model Latent Model (under development) Test Strategy \u00b6 TestStrategy provides a routine for testing the hypothesis. TestStrategy can access the entire Experiment object but often it is restricted to only modifying relevant variables, e.g., pvalue, statistics, sig . Test Strategies already implemented: T-Test F-Test Yuen T-Test Wilcoxon Test Effect Strategy \u00b6 EffectStrategy defines a method of calculating the magnitude of effect between two experimental groups. Available effect strategies: Mean Difference Cohen's D Hedge's G Odd Ratio Journal \u00b6 In SAM, a Journal is a container for accepted publications. Journal is designed to mimic the reviewing process. Therefore, it uses an arbitrary algorithm for deciding whether a submission will be accepted. The Journal's components are: Selection Strategy Accepted List, ie., Publications List Rejected List Meta-analytic Methods Meta-analytic Results Selection Strategy \u00b6 Selection Strategy implements the logic behind accepting or rejecting a submission. The simplest algorithms are based on p -values and their decision is a simple threshold check. However, more elaborate selection strategies incorporate different metrics or criteria (e.g., pre-registration, sample sizes, or meta-analysis) into their final decision. For instance, if appropriate, a journal can have an updated estimation of the effect size from its current publications pool and use that information to accept or reject new submissions. List of available selection strategies are: Significant Selection Random Selection Free Selection Submission \u00b6 A Submission is a container, created by the Researcher and provided to the Journal. It provides a simple interface between Journal, Experiment and Researcher objects. In fact, a Submission resembles a manuscript when it is at the hand of the researcher and a publication after being accepted by the journal. After performing the test and choosing an outcome variable, the Researcher puts together a report containing necessary information for the Journal to decide whether to accept or reject the submitted finding(s). This representation allows us to mimic several important concepts related to publication habits, e.g., the file-drawer effect, pre-registration. Researcher \u00b6 The Researcher object is the main player in the simulation. It uses the Experiment Setup to prepare the Experiment and send the final outcome to the Journal for the reviewing process. After the initialization of the Experiment Setup, the Researcher prepares the Experiment object by collecting data via the Data Strategy, tests the hypothesis via the Test Strategy, and calculates the effect sizes using the Effect Strategy. Then, if configured to, it applies different QRPs on the Experiment and hacks its way to a satisfactory result. In the end, the researcher prepares a Submission record and sends it to the Journal for review. This process is discussed in more detail in Execution Flow and Research Workflow . Decision Strategy \u00b6 Decision Strategy models the decision making process during the research process. The Researcher relies on the verdict of the decision strategy two main ways, Selection and Decision policies . Selection policies are used by Researchers to filter and select an outcome from a group of outcomes. For instance, if a Researcher only considers outcomes with significant p -values satisfactory, a selection policy will help her to only select for those among all available outcomes. Decision policies process, are used to make certain decisions during the research process. For instance, whether a researcher should start applying QRPs on an experiment, or whether it should submit the final submission to the journal. Selection and Decision policies follows each other in this order. In most cases, a decision should be made about the already selected outcome. For instance, as the researcher applies a QRP on an experiment, he uses a Selection policy to look for his preferred outcome, then, he needs to make a decision whether he is going to continue with the next QRP or if he finds the selection satisfactory. The notion of satisfactory outcome will be decided by a Decision policy. As we will discuss later, we\u2019ll be able to define various criteria (policies) for selection and decision processes. Some of the Selection\u2192Decision sequences available are: Initial Selection Policy Will be Hacking Decision Policy each hacking strategy will end with a selection-decision of its own Selection Decision Between Hacked Outcomes Selection Policies Will Continue Replicating Decision Policies Will be Submitting To Journal Decision Policy Decision Strategy is one of the more elaborated pieces of SAM. It engages in different stages of conducting the research by researcher and different hacking strategies. This process will be clarified in Flow and Research Workflow and Decision Strategy . Hacking Strategies \u00b6 Hacking Strategy is an abstract representation of different p -hacking and QRP methods. The Researcher performs a hacking strategy by sending a copy of its Experiment to a chosen method. The Hacking Strategy takes control of the experiment, modifies it, (e.g., adding new values, removing values), recomputes the statistics, reruns the test, and finally returns the modified Experiment. Finally, the researcher can evaluate the hacked experiment, and select the hacked result if satisfactory. If more than one hacking strategies are registered, The Researcher navigates through them by the logic defined in Decision Strategy and decides whether any of the hacked experiments will be used for constructing the Submission . This process will be discussed in more detail, in Decision Strategy and Hacking Strategy . The available hacking strategies are: Optional Stopping Outliers Removal Subjective Outliers Removal Questionable Rounding Falsifying Data Fabricating Data Stopping Data Collection","title":"Modules"},{"location":"modules/#modules","text":"In the previous section , we listed main components and entities involved in the different stages of conducting research, e.g., Experiment Setup, Experiment, Researcher, Submission, and Journal. In our model , each component is a semi-independent entity while the whole system and its processes (i.e. conducting scientific research) are defined through their interactions. One of our main design goals with SAM was to achieve a level of flexibility where we could change different aspects of each component. In order to achieve this, we decoupled the system to smaller \u2014 but conceptually meaningful \u2014 routines and entities. Figure 1. shows these components, and their dependencies and interactions with each other. SAM's main components and their interactions Attention Throughout this document, we use the color assigned to each module in Figure 1. to refer to them in different sections. This section describes the design principles behind each component, what they model in the real world and how they work and interact with each others to collectively simulate the process of producing scientific research.","title":"Modules"},{"location":"modules/#sams-main-components","text":"SAM consists of 3 main components, Experiment, Researcher and Journal . Each component mimics one of the subprocesses or entities that are discussed in the Introduction The list below briefly introduces each component alongside their roles. The Experiment comprises of several parts, each dealing with different aspects of a research, e.g., setup, data, test, effect. Experiment Setup holds the specification of the design. The Researcher can only set these parameters once, at the start of an experiment. In fact, the Experiment Setup implementation simulates the concept of pre-registration . Data Strategy is a routine used to generate data based on specified parameters in the Experiment Setup . Test Strategy is the statistical method of choice in the Experiment Setup for testing the result of an Experiment . Effect Strategy defines the method of calculating effect sizes in an Experiment . The Researcher module imitates the behaviors of a researcher, including possible questionable research practices conducted by him/her. The Researcher defines the Experiment Setup, generates and collects data, runs the statistical test, decides whether to preform any QRPs, prepares the Submission record, and finally submits its finding(s) to the Journal of her/his choice. Decision Strategy is the underlying logic and steps of performing the research, as well as selecting and reporting specific variables as the primary outcome in an Experiment . Hacking Strategy is a list of questionable research practices in the researcher's arsenal. In the case where the researcher decides to hack his/her way to finding significant results, he/she can use these methods. The Journal is a container of publications. The Journal keeps track of its publications and can utilize different metrics to adapts its selection strategy. Selection Strategy is the internal algorithm by which the journal decides whether a submission will be accepted. Submission is a concise report, acting as a scientific paper, or a manuscript that it is going to be submitted for review to the Journal. Note Unlike a real scientific journal that covers a wide range of research tracks, SAM's Journal in its current implementation assumes that all submitted publications are from one research track. In other words, SAM's journals are mainly acting as a pool for related studies ready to be analyzed using meta-analyses methods. The rest of this section discusses each component properties and rule in more details, and more information about each component can be found in their dedicated pages.","title":"SAM's Main Components"},{"location":"modules/#experiment","text":"As mentioned, an Experiment object acts as an umbrella for everything related to an actual experiment. This includes metadata (a.k.a Experiment Setup), raw data, method/model for generating the data, e.g., Linear Model , methods of testing the hypothesis, and calculating the effect. The Researcher object has complete control over every aspect of an Experiment with one exception : it can only read and not change the Experiment Setup object. This is an important factor when later on we discuss the concept of pre-registration. The main components of the Experiment are: Experiment Setup Data, an object containing actual data points","title":"Experiment"},{"location":"modules/#experiment-setup","text":"After the initialization phase, SAM treats the Experiment Setup object as a read-only object. During the initialization phase, SAM initializes and randomizes the Experiment Setup based on given parameters. Thereafter, Experiment Setup will stay intact in the code and will be used as a reference point in different stages. The main components of the Experiment Setup are: Design Parameters Number of conditions Number of dependent variables Number of observations per group Data Strategy Test Strategy Effect Strategy","title":"Experiment Setup"},{"location":"modules/#data-strategy","text":"Data Strategy acts as the population of the study, i.e., data source. In most cases, an instance of the Data Strategy object uses a statistical model to sample data points and populates the Data object of the Experiment. Moreover, with certain p -hacking methods, e.g., optional stopping , the data strategy will be used to generate extra data points as requested by the optional stopping. Available data strategies are: Linear Model Graded Response Model Latent Model (under development)","title":"Data Strategy"},{"location":"modules/#test-strategy","text":"TestStrategy provides a routine for testing the hypothesis. TestStrategy can access the entire Experiment object but often it is restricted to only modifying relevant variables, e.g., pvalue, statistics, sig . Test Strategies already implemented: T-Test F-Test Yuen T-Test Wilcoxon Test","title":"Test Strategy"},{"location":"modules/#effect-strategy","text":"EffectStrategy defines a method of calculating the magnitude of effect between two experimental groups. Available effect strategies: Mean Difference Cohen's D Hedge's G Odd Ratio","title":"Effect Strategy"},{"location":"modules/#journal","text":"In SAM, a Journal is a container for accepted publications. Journal is designed to mimic the reviewing process. Therefore, it uses an arbitrary algorithm for deciding whether a submission will be accepted. The Journal's components are: Selection Strategy Accepted List, ie., Publications List Rejected List Meta-analytic Methods Meta-analytic Results","title":"Journal"},{"location":"modules/#selection-strategy","text":"Selection Strategy implements the logic behind accepting or rejecting a submission. The simplest algorithms are based on p -values and their decision is a simple threshold check. However, more elaborate selection strategies incorporate different metrics or criteria (e.g., pre-registration, sample sizes, or meta-analysis) into their final decision. For instance, if appropriate, a journal can have an updated estimation of the effect size from its current publications pool and use that information to accept or reject new submissions. List of available selection strategies are: Significant Selection Random Selection Free Selection","title":"Selection Strategy"},{"location":"modules/#submission","text":"A Submission is a container, created by the Researcher and provided to the Journal. It provides a simple interface between Journal, Experiment and Researcher objects. In fact, a Submission resembles a manuscript when it is at the hand of the researcher and a publication after being accepted by the journal. After performing the test and choosing an outcome variable, the Researcher puts together a report containing necessary information for the Journal to decide whether to accept or reject the submitted finding(s). This representation allows us to mimic several important concepts related to publication habits, e.g., the file-drawer effect, pre-registration.","title":"Submission"},{"location":"modules/#researcher","text":"The Researcher object is the main player in the simulation. It uses the Experiment Setup to prepare the Experiment and send the final outcome to the Journal for the reviewing process. After the initialization of the Experiment Setup, the Researcher prepares the Experiment object by collecting data via the Data Strategy, tests the hypothesis via the Test Strategy, and calculates the effect sizes using the Effect Strategy. Then, if configured to, it applies different QRPs on the Experiment and hacks its way to a satisfactory result. In the end, the researcher prepares a Submission record and sends it to the Journal for review. This process is discussed in more detail in Execution Flow and Research Workflow .","title":"Researcher"},{"location":"modules/#decision-strategy","text":"Decision Strategy models the decision making process during the research process. The Researcher relies on the verdict of the decision strategy two main ways, Selection and Decision policies . Selection policies are used by Researchers to filter and select an outcome from a group of outcomes. For instance, if a Researcher only considers outcomes with significant p -values satisfactory, a selection policy will help her to only select for those among all available outcomes. Decision policies process, are used to make certain decisions during the research process. For instance, whether a researcher should start applying QRPs on an experiment, or whether it should submit the final submission to the journal. Selection and Decision policies follows each other in this order. In most cases, a decision should be made about the already selected outcome. For instance, as the researcher applies a QRP on an experiment, he uses a Selection policy to look for his preferred outcome, then, he needs to make a decision whether he is going to continue with the next QRP or if he finds the selection satisfactory. The notion of satisfactory outcome will be decided by a Decision policy. As we will discuss later, we\u2019ll be able to define various criteria (policies) for selection and decision processes. Some of the Selection\u2192Decision sequences available are: Initial Selection Policy Will be Hacking Decision Policy each hacking strategy will end with a selection-decision of its own Selection Decision Between Hacked Outcomes Selection Policies Will Continue Replicating Decision Policies Will be Submitting To Journal Decision Policy Decision Strategy is one of the more elaborated pieces of SAM. It engages in different stages of conducting the research by researcher and different hacking strategies. This process will be clarified in Flow and Research Workflow and Decision Strategy .","title":"Decision Strategy"},{"location":"modules/#hacking-strategies","text":"Hacking Strategy is an abstract representation of different p -hacking and QRP methods. The Researcher performs a hacking strategy by sending a copy of its Experiment to a chosen method. The Hacking Strategy takes control of the experiment, modifies it, (e.g., adding new values, removing values), recomputes the statistics, reruns the test, and finally returns the modified Experiment. Finally, the researcher can evaluate the hacked experiment, and select the hacked result if satisfactory. If more than one hacking strategies are registered, The Researcher navigates through them by the logic defined in Decision Strategy and decides whether any of the hacked experiments will be used for constructing the Submission . This process will be discussed in more detail, in Decision Strategy and Hacking Strategy . The available hacking strategies are: Optional Stopping Outliers Removal Subjective Outliers Removal Questionable Rounding Falsifying Data Fabricating Data Stopping Data Collection","title":"Hacking Strategies"},{"location":"research-workflow/","text":"Research Workflow \u00b6 After introducing general steps of conducting research, in this section, we will get into the details of Decision Strategy and Research Workflow. Figure 1 combines all the previously discussed processes and flowcharts of the Execution Flow , and gives an overview of the entire research workflow. The diagram can be separated into two main processes, Main Research Line and Hacking Workflow . Additionally, there are several Selection\u2192Decision sequences spread throughout the flowchart (highlighted in red) that helps the Researcher to navigate between stages, and make certain decisions. Figure 1. An overview of Research and Hacking Workflow. This section will walk you through each process and discuss each step in more detail. Initial Stage \u00b6 As discussed in the Design section, research starts by initializing the Experiment Setup and thereafter preparation of the Experiment which consists of generating data, calculating statistics, running tests, calculating effects, etc. When the Experiment is fully initialized, the Researcher is able to asses the quality of results, and select her preferred outcome among all available outcome variables across all conditions and dependent variables. This is beingdone during the first selection stage, Initial Selection . At this stage, the Researcher can query all available outcomes using specific set of rules. For example, by using [\"sig\", \"min(pvalue)\"] Policy , she will seek an outcome with minimum p -value between those that are significant. Despite the success of failure of the Initial Selection , the Researcher decides on whether to embark on a journy of exploring QPRs. This is done at the Will be Hacking Decision stage, where the Researcher uses a chain of policies to determine her next move. For instance, if she is looking for an outcome with positive effect (ie., [\"effect > 0\"] ) and the previously selected outcome does not have a positive effect, researcher might opt-in for applying some hacking strategies. Hacking Workflow \u00b6 If the Researcher is not satisfied with the selected submission, and the configuration indicates that he is going to apply some QRPs, then, he continues to the Hacking Workflow stage. In this stage, the Researcher selects the first hacking strategy from his list, H\u2081 and applies it on the Experiment. This process is highlighted in light blue, Hack Experiment using H\u1d62 . After each QRP, researcher has a chance to collect the altered results for later investigation, we refer to this process as Stashing . Whether the Researcher performs a stashing process, he continues to another Selection\u2192Decision sequence where he evaluates the altered the Experiment after applying H\u2081. The selection procedure is defined by an another set of policy chains \u2014 After Hacking Selection \u2014 which either leads to an empty submission or an unique submission. Right after selection, researcher needs to decide whether he is going to continue the hacking procedure \u2014 Will Continue Hacking Decision. If researcher decides to continue the hacking procedure, he would then choose the next hacking strategy, H i+1 , and repeat the same process. Stashing and Post-QRP Selection \u00b6 Stashing policy indicates what type of outcomes should temporary be stored by the Researcher for further exploration of his results. After leaving the Hacking Workflow, the Researcher is equipped with a set of outcomes selected from his ventures into his QRP arsenal. The Researcher is being given the chance of selecting an outcome from his stashed outcome, Hacked Outcomes DB. , if he finds it necessary. In a real world scenario, this process mimic a very greedy and inconsiderate researcher who is trying everything to achieve a certain goal, ie., significance ( [\"sig\"] ), and collect every modifications and outcomes to ultimately select an outcome from his stashed of altered results. Post-QRP Decision and Replication Stage \u00b6 Researcher's final selected outcome, S F\u1d62 will be stored in an another dataset, Rep. Outcomes DB. If researcher is intending to perform more than one replication of his research, n_reps , see configuration file . Then, he faces another decision, Will Continue Replication Decision . If the verdict is a yes, researcher stores the current selected outcome, S F\u1d62 , and initiates a replication of the Experiment using the parameters defined in the Experiment Setup. After performing n_reps replication, or negative ruling of Will Continue Replicating Decision (which leads termination of the replication process), the Researcher moves to the final stage of his research. Throughout another Selection\u2192Decision sequence, the Researcher selects an outcome among all those stored from every replications, and decides on whether he is going to submit that submission to the Journal. The final decision stage acts as researcher's final call to whether his research is good enough (in his terms) to be submitted as a manuscript to the Journal. Finally \u00b6 By the time that Final Submission, S F , is out of Researcher's hand and at Journal's mercy, the process of conducting research by the Researcher is finalized. At this point, the Journal decides on whether the manuscript is \"publishable\".","title":"Research Workflow"},{"location":"research-workflow/#research-workflow","text":"After introducing general steps of conducting research, in this section, we will get into the details of Decision Strategy and Research Workflow. Figure 1 combines all the previously discussed processes and flowcharts of the Execution Flow , and gives an overview of the entire research workflow. The diagram can be separated into two main processes, Main Research Line and Hacking Workflow . Additionally, there are several Selection\u2192Decision sequences spread throughout the flowchart (highlighted in red) that helps the Researcher to navigate between stages, and make certain decisions. Figure 1. An overview of Research and Hacking Workflow. This section will walk you through each process and discuss each step in more detail.","title":"Research Workflow"},{"location":"research-workflow/#initial-stage","text":"As discussed in the Design section, research starts by initializing the Experiment Setup and thereafter preparation of the Experiment which consists of generating data, calculating statistics, running tests, calculating effects, etc. When the Experiment is fully initialized, the Researcher is able to asses the quality of results, and select her preferred outcome among all available outcome variables across all conditions and dependent variables. This is beingdone during the first selection stage, Initial Selection . At this stage, the Researcher can query all available outcomes using specific set of rules. For example, by using [\"sig\", \"min(pvalue)\"] Policy , she will seek an outcome with minimum p -value between those that are significant. Despite the success of failure of the Initial Selection , the Researcher decides on whether to embark on a journy of exploring QPRs. This is done at the Will be Hacking Decision stage, where the Researcher uses a chain of policies to determine her next move. For instance, if she is looking for an outcome with positive effect (ie., [\"effect > 0\"] ) and the previously selected outcome does not have a positive effect, researcher might opt-in for applying some hacking strategies.","title":"Initial Stage"},{"location":"research-workflow/#hacking-workflow","text":"If the Researcher is not satisfied with the selected submission, and the configuration indicates that he is going to apply some QRPs, then, he continues to the Hacking Workflow stage. In this stage, the Researcher selects the first hacking strategy from his list, H\u2081 and applies it on the Experiment. This process is highlighted in light blue, Hack Experiment using H\u1d62 . After each QRP, researcher has a chance to collect the altered results for later investigation, we refer to this process as Stashing . Whether the Researcher performs a stashing process, he continues to another Selection\u2192Decision sequence where he evaluates the altered the Experiment after applying H\u2081. The selection procedure is defined by an another set of policy chains \u2014 After Hacking Selection \u2014 which either leads to an empty submission or an unique submission. Right after selection, researcher needs to decide whether he is going to continue the hacking procedure \u2014 Will Continue Hacking Decision. If researcher decides to continue the hacking procedure, he would then choose the next hacking strategy, H i+1 , and repeat the same process.","title":"Hacking Workflow"},{"location":"research-workflow/#stashing-and-post-qrp-selection","text":"Stashing policy indicates what type of outcomes should temporary be stored by the Researcher for further exploration of his results. After leaving the Hacking Workflow, the Researcher is equipped with a set of outcomes selected from his ventures into his QRP arsenal. The Researcher is being given the chance of selecting an outcome from his stashed outcome, Hacked Outcomes DB. , if he finds it necessary. In a real world scenario, this process mimic a very greedy and inconsiderate researcher who is trying everything to achieve a certain goal, ie., significance ( [\"sig\"] ), and collect every modifications and outcomes to ultimately select an outcome from his stashed of altered results.","title":"Stashing and Post-QRP Selection"},{"location":"research-workflow/#post-qrp-decision-and-replication-stage","text":"Researcher's final selected outcome, S F\u1d62 will be stored in an another dataset, Rep. Outcomes DB. If researcher is intending to perform more than one replication of his research, n_reps , see configuration file . Then, he faces another decision, Will Continue Replication Decision . If the verdict is a yes, researcher stores the current selected outcome, S F\u1d62 , and initiates a replication of the Experiment using the parameters defined in the Experiment Setup. After performing n_reps replication, or negative ruling of Will Continue Replicating Decision (which leads termination of the replication process), the Researcher moves to the final stage of his research. Throughout another Selection\u2192Decision sequence, the Researcher selects an outcome among all those stored from every replications, and decides on whether he is going to submit that submission to the Journal. The final decision stage acts as researcher's final call to whether his research is good enough (in his terms) to be submitted as a manuscript to the Journal.","title":"Post-QRP Decision and Replication Stage"},{"location":"research-workflow/#finally","text":"By the time that Final Submission, S F , is out of Researcher's hand and at Journal's mercy, the process of conducting research by the Researcher is finalized. At this point, the Journal decides on whether the manuscript is \"publishable\".","title":"Finally"},{"location":"researcher-configurations/","text":"Researcher Configurations \u00b6 This section defines the behavior of the Researcher. Researcher's parameters can be separated into two main parts, Decision Strategies , Hacking Behaviors and Hacking Strategies . Researcher's parameters seection is divided into three main sub-sections as listed below: decision_strategy , dict , specification of Decision Strategy Hacking Behavior , a group of parameters defining the overall behavior and personality of the Researcher, e.g., probability_of_being_a_hacker , number , Indicates the probability of a researcher deciding to apply any of the hacking strategies. Hacking Behaviors . see Hacking Behavior for more detail. hacking_strategies , list , a list of hacking strategies and their corresponding selection \u2192 decision sequences. TODO: Add a full example","title":"Introduction"},{"location":"researcher-configurations/#researcher-configurations","text":"This section defines the behavior of the Researcher. Researcher's parameters can be separated into two main parts, Decision Strategies , Hacking Behaviors and Hacking Strategies . Researcher's parameters seection is divided into three main sub-sections as listed below: decision_strategy , dict , specification of Decision Strategy Hacking Behavior , a group of parameters defining the overall behavior and personality of the Researcher, e.g., probability_of_being_a_hacker , number , Indicates the probability of a researcher deciding to apply any of the hacking strategies. Hacking Behaviors . see Hacking Behavior for more detail. hacking_strategies , list , a list of hacking strategies and their corresponding selection \u2192 decision sequences. TODO: Add a full example","title":"Researcher Configurations"},{"location":"selection-strategies/","text":"Selection Strategies \u00b6 Two primary built-in selection strategies are Random Selection and Significant Selection. While the former algorithm flips a coin for accepting each submission, the latter mimics the publication bias phenomena. Besides these two strategies, more elaborate selection strategies can be deployed at the Journal. In this section we list a few of the available strategies. Free Selection \u00b6 With free selection method, the Journal does not impose any restriction during the reviewing process and every submission applied for the review is going to be accepted. This strategy is suitable for cases where we are interested in the intact population of the publications rather. Free Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"FreeSelection\" } } Random Selection \u00b6 Random selection method is the simplest form of selection where the Journal flips a coin to decide whether a submission is going to be accepted. Using p = 0 will lead to a Journal that does not accept anything, and p = 1 defines a Journal that accepts everything. Random Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"RandomSelection\" , \"probability\" : p } } Significant Selection (Biased Selection) \u00b6 As the name suggests, the significant selection strategy incorporates the concept of publication bias [cite] into Journal's review process. Therefore, a submission will be accepted if it is significant, if not, it has a (1 - P\u0299) chance of being accepted. Sifnigicant Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : \u0251 , \"pub_bias\" : Pb , \"side\" : 0 } } Policy Based Selection \u00b6 Policy based selection strategy are using policy chains to evalute the \"quality\" of a submission, and therefore come to their verdict. In addition to the given criteria, we can adjust the acceptance rate , pub_chance , and the publication bias rate , pub_bias . The Journal first evaluates whether the selection_policy can be satisfied; then, a random draw decides whether the publication is lucky enough to be accepted, and finally, odds of being actually published will be evaluted against the publication bias rate. Notice that the flexibilty of the selection policy and availability of publication bias rate will allow for construction of the Journal with specific biases, e.g., positive effects, large study sizes, etc. Policy Based Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"PolicyBasedSelection\" , \"selection_policy_defs\" : [ \"effect > 0\" , \"sig\" ], \"pub_chance\" : Pc , \"pub_bias\" : Pb } }","title":"Selection Strategies"},{"location":"selection-strategies/#selection-strategies","text":"Two primary built-in selection strategies are Random Selection and Significant Selection. While the former algorithm flips a coin for accepting each submission, the latter mimics the publication bias phenomena. Besides these two strategies, more elaborate selection strategies can be deployed at the Journal. In this section we list a few of the available strategies.","title":"Selection Strategies"},{"location":"selection-strategies/#free-selection","text":"With free selection method, the Journal does not impose any restriction during the reviewing process and every submission applied for the review is going to be accepted. This strategy is suitable for cases where we are interested in the intact population of the publications rather. Free Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"FreeSelection\" } }","title":"Free Selection"},{"location":"selection-strategies/#random-selection","text":"Random selection method is the simplest form of selection where the Journal flips a coin to decide whether a submission is going to be accepted. Using p = 0 will lead to a Journal that does not accept anything, and p = 1 defines a Journal that accepts everything. Random Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"RandomSelection\" , \"probability\" : p } }","title":"Random Selection"},{"location":"selection-strategies/#significant-selection-biased-selection","text":"As the name suggests, the significant selection strategy incorporates the concept of publication bias [cite] into Journal's review process. Therefore, a submission will be accepted if it is significant, if not, it has a (1 - P\u0299) chance of being accepted. Sifnigicant Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : \u0251 , \"pub_bias\" : Pb , \"side\" : 0 } }","title":"Significant Selection (Biased Selection)"},{"location":"selection-strategies/#policy-based-selection","text":"Policy based selection strategy are using policy chains to evalute the \"quality\" of a submission, and therefore come to their verdict. In addition to the given criteria, we can adjust the acceptance rate , pub_chance , and the publication bias rate , pub_bias . The Journal first evaluates whether the selection_policy can be satisfied; then, a random draw decides whether the publication is lucky enough to be accepted, and finally, odds of being actually published will be evaluted against the publication bias rate. Notice that the flexibilty of the selection policy and availability of publication bias rate will allow for construction of the Journal with specific biases, e.g., positive effects, large study sizes, etc. Policy Based Selection \"journal_parameters\" : { \"selection_strategy\" : { \"name\" : \"PolicyBasedSelection\" , \"selection_policy_defs\" : [ \"effect > 0\" , \"sig\" ], \"pub_chance\" : Pc , \"pub_bias\" : Pb } }","title":"Policy Based Selection"},{"location":"simulation-configurations/","text":"Simulation Configurations \u00b6 This section of configuration file specifies general parameters of the simulation. These parameters are mainly defining higher-level behaviors of SAM regarding input and output. \"simulation_parameters\" : { \"n_sims\" : 1 , \"master_seed\" : \"random\" , \"log_level\" : \"info\" , \"progress\" : false , \"output_path\" : \"../outputs/\" , \"output_prefix\" : \"sample_sim\" , \"update_config\" : true , \"save_all_pubs\" : false , \"save_meta\" : true , \"save_overall_summaries\" : true , \"save_pubs_per_sim_summaries\" : true , \"save_rejected\" : false } The list below describes the type and functoin of each parameters: n_sims , int , indicates the total number of simulations. master_seed , int / \"random\" , indicates the intial seed of the RNG engine. If set to \"random\", a random number will be used at the start of the execution. log_level , string , indicates the logging level of the simulation progress , boolean , indicates whether a progress bar should be displayed output_path , string , indicates a path to be used for output files output_prefix , string , indicates a prefix to be added to all output filenames update_config , boolean , indicates whether the config file should be updated after the simulation. Note: This might overwrite master_seed or output_path save_all_pubs , boolean , indicates whether all publications should be saved. One CSV file with the name of output_prefix_Publications.csv , containing all accepted publications across all simulations, will be created save_meta , boolean , indicates whether outputs of meta-analysis methods should be saved. For each given meta-analysis method, one CSV file with the name of output_prefix_MetaAnalysisMethodName.csv , containing records of meta-analysis output from each simulation, will be created save_overall_summaries , boolean , indicates whether the summary of entire simulation should be calculated and saved One CSV file for the entire simulation with the name of output_prefix_Publications_Summaries.csv , containing one record of several statistics from all publications, will be created for each output parameters, SAM calcuate the overall mean, standard deviation, variance, min, max, range One CSV file for the entire simulation with the name of output_prefix_MetaAnalysisMethodName_Summaries.csv , containing one record of several statistics from all meta analysis outputs, will be created. save_pubs_per_sim_summaries , boolean , indicates whether the summary of each simulation run should be calucated and saved. One CSV file for the entire simulation with the name of output_prefix_Publications_Per_Sim_Summaries.csv , containing records of several statistics from each publications list, will be created. save_rejected , boolean , Indicates whether rejected publications should be stored and saved. One CSV file for the entire simulation with the name of output_prefix_Rejected.csv , containing all rejected publications across all simulations, will be created","title":"Simulation"},{"location":"simulation-configurations/#simulation-configurations","text":"This section of configuration file specifies general parameters of the simulation. These parameters are mainly defining higher-level behaviors of SAM regarding input and output. \"simulation_parameters\" : { \"n_sims\" : 1 , \"master_seed\" : \"random\" , \"log_level\" : \"info\" , \"progress\" : false , \"output_path\" : \"../outputs/\" , \"output_prefix\" : \"sample_sim\" , \"update_config\" : true , \"save_all_pubs\" : false , \"save_meta\" : true , \"save_overall_summaries\" : true , \"save_pubs_per_sim_summaries\" : true , \"save_rejected\" : false } The list below describes the type and functoin of each parameters: n_sims , int , indicates the total number of simulations. master_seed , int / \"random\" , indicates the intial seed of the RNG engine. If set to \"random\", a random number will be used at the start of the execution. log_level , string , indicates the logging level of the simulation progress , boolean , indicates whether a progress bar should be displayed output_path , string , indicates a path to be used for output files output_prefix , string , indicates a prefix to be added to all output filenames update_config , boolean , indicates whether the config file should be updated after the simulation. Note: This might overwrite master_seed or output_path save_all_pubs , boolean , indicates whether all publications should be saved. One CSV file with the name of output_prefix_Publications.csv , containing all accepted publications across all simulations, will be created save_meta , boolean , indicates whether outputs of meta-analysis methods should be saved. For each given meta-analysis method, one CSV file with the name of output_prefix_MetaAnalysisMethodName.csv , containing records of meta-analysis output from each simulation, will be created save_overall_summaries , boolean , indicates whether the summary of entire simulation should be calculated and saved One CSV file for the entire simulation with the name of output_prefix_Publications_Summaries.csv , containing one record of several statistics from all publications, will be created for each output parameters, SAM calcuate the overall mean, standard deviation, variance, min, max, range One CSV file for the entire simulation with the name of output_prefix_MetaAnalysisMethodName_Summaries.csv , containing one record of several statistics from all meta analysis outputs, will be created. save_pubs_per_sim_summaries , boolean , indicates whether the summary of each simulation run should be calucated and saved. One CSV file for the entire simulation with the name of output_prefix_Publications_Per_Sim_Summaries.csv , containing records of several statistics from each publications list, will be created. save_rejected , boolean , Indicates whether rejected publications should be stored and saved. One CSV file for the entire simulation with the name of output_prefix_Rejected.csv , containing all rejected publications across all simulations, will be created","title":"Simulation Configurations"},{"location":"test-strategies/","text":"Test Strategies \u00b6 Test strategy defines the method of hypothesis testing. After collecting data, the Researcher runs a statistical test on the Experiment, and calculates appropriate statistics, and p -values for each outcome variables. Thereafter, based on the calculated p -value, and given \u0251, Test Strategy decides whether the test result is significant. Similar to Data Strategy, we configure the Test Strategy by specifying the method name, follwing with its setting their specific parameters. Most tests should be accompanied by an \u0251 level. This \u0251 is going to be used throughout the rest of SAM to evaluate the significance level of an outcome. For instance, when a policy queies for significance of an outcome, SAM asks Test Strategy to see whether for a given outcome, the test is significant. Configuration: Test Strategy { \"experiment_parameters\" : { ... , \"data_strategy\" : { ... }, \"test_strategy\" : { \"name\" : \"MethodName\" , \"alpha\" : 0.5 } } } While SAM offers a few test strategies out of the box, it is possible to extend this list by implementing your own methods using the provided API. T-Test \u00b6 TODO: Add descsription and reference In order to configure a t-test , we need to set some general parameters, as follow: T-Test Configurations \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } F-Test \u00b6 TODO: Add descsription and reference F-Test Configurations \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 } Yuen T-Test 1 \u00b6 TODO: Add descsription and reference Yuen Test Configurations \"test_strategy\" : { \"name\" : \"YuenTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"trim\" : 0.2 , \"paired\" : true } Wilcoxon Test 2 \u00b6 TODO: Add descsription and reference Wilcoxon Test Configurations \"test_strategy\" : { \"name\" : \"WilcoxonTest\" , \"alpha\" : 0.05 , \"use_continuity\" : true } KAREN K. YUEN. The two-sample trimmed t for unequal population variances. Biometrika , 61 1 1 :165\u2013170, 04 1974. URL: https://doi.org/10.1093/biomet/61.1.165 , doi:10.1093/biomet/61.1.165 . \u21a9 Frank Wilcoxon. Individual Comparisons by Ranking Methods , pages 196\u2013202. Springer New York, New York, NY, 1992. URL: https://doi.org/10.1007/978-1-4612-4380-9_16 , doi:10.1007/978-1-4612-4380-9_16 . \u21a9","title":"Test Strategies"},{"location":"test-strategies/#test-strategies","text":"Test strategy defines the method of hypothesis testing. After collecting data, the Researcher runs a statistical test on the Experiment, and calculates appropriate statistics, and p -values for each outcome variables. Thereafter, based on the calculated p -value, and given \u0251, Test Strategy decides whether the test result is significant. Similar to Data Strategy, we configure the Test Strategy by specifying the method name, follwing with its setting their specific parameters. Most tests should be accompanied by an \u0251 level. This \u0251 is going to be used throughout the rest of SAM to evaluate the significance level of an outcome. For instance, when a policy queies for significance of an outcome, SAM asks Test Strategy to see whether for a given outcome, the test is significant. Configuration: Test Strategy { \"experiment_parameters\" : { ... , \"data_strategy\" : { ... }, \"test_strategy\" : { \"name\" : \"MethodName\" , \"alpha\" : 0.5 } } } While SAM offers a few test strategies out of the box, it is possible to extend this list by implementing your own methods using the provided API.","title":"Test Strategies"},{"location":"test-strategies/#t-test","text":"TODO: Add descsription and reference In order to configure a t-test , we need to set some general parameters, as follow: T-Test Configurations \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true }","title":"T-Test"},{"location":"test-strategies/#f-test","text":"TODO: Add descsription and reference F-Test Configurations \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 }","title":"F-Test"},{"location":"test-strategies/#yuen-t-test1","text":"TODO: Add descsription and reference Yuen Test Configurations \"test_strategy\" : { \"name\" : \"YuenTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"trim\" : 0.2 , \"paired\" : true }","title":"Yuen T-Test1"},{"location":"test-strategies/#wilcoxon-test2","text":"TODO: Add descsription and reference Wilcoxon Test Configurations \"test_strategy\" : { \"name\" : \"WilcoxonTest\" , \"alpha\" : 0.05 , \"use_continuity\" : true } KAREN K. YUEN. The two-sample trimmed t for unequal population variances. Biometrika , 61 1 1 :165\u2013170, 04 1974. URL: https://doi.org/10.1093/biomet/61.1.165 , doi:10.1093/biomet/61.1.165 . \u21a9 Frank Wilcoxon. Individual Comparisons by Ranking Methods , pages 196\u2013202. Springer New York, New York, NY, 1992. URL: https://doi.org/10.1007/978-1-4612-4380-9_16 , doi:10.1007/978-1-4612-4380-9_16 . \u21a9","title":"Wilcoxon Test2"},{"location":"doxygen/","text":"SAM is designed to be flexible, modular and extensible. While you can take advantages of its flexibility and molecularity without fully understanding its underlying implementation; when you decide to expand its functionality, e.g., adding a new Hacking Strategy, you need to dive deeper into the framework itself and familiar yourself with its design and constructs. Here, you are presented with the Doxygen documentation of SAM's C++ code, e.g., the classes and module groups. Before starting to navigate the code, we highly recommend that you study the Design and Configuration sections thoroughly. While they do not discretely talk about the API, they will help you understand the structure of SAM framework in great details. Important You do not need to understand SAM's API to use SAM. Head to Design and Configuration sections if you only wants to use SAM to design and run a simulation based on currently available methods and strategies. However, if you cannot find everything you need, and you have a good understanding of C++ programming language, this section comes handy when you want to implement your own methods.","title":"Introduction"},{"location":"doxygen/Classes/","text":"Classes \u00b6 namespace sam class CohensD class ConditionDropping struct Parameters class DataStrategy Abstract class for Data Strategies. class DefaultResearchStrategy The deceleration of the default research strategy. struct Parameters The parameters of the strategy. class DependentVariable Declaration of DependentVariable class. class EffectStrategy Abstract class for Effect Size Strategy. class EggersTestEstimator Egger's Test of Funnel Plot Symmetry. struct Parameters Parameters of the EggersTestEstimator . struct ResultType class Experiment Experiment encapsulates data and methods needed by the Researcher to conduct its research. class ExperimentSetup Declaration of ExperimentSetup class. class ExperimentSetupBuilder class FTest struct Parameters struct ResultType class FabricatingData struct Parameters class FalsifyingData struct Parameters class FixedEffectEstimator Fixed Effect Estimator. struct ResultType class FrankenbachStrategy struct Parameters class FreeSelection FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted. struct Parameters Parameters of free selection. class GRMDataStrategy Simulate data based on General Graded Response Model. struct Parameters class GroupPooling struct Parameters class HackingProbabilityStrategy class HackingStrategy Abstract Class of Hacking Strategies. class HedgesG class Journal Journal Class. class LatentDataStrategy \u26a0\ufe0f TO BE IMPLEMENTED! class LinearModelStrategy Linear Model Data Strategy. struct Parameters Parameters of LinearModelStrategy . class MeanDifference class MetaAnalysis class OptionalDropping struct Parameters class OptionalStopping struct Parameters class OutliersRemoval Declaration of Outlier Removal hacking method based on items' distance from their sample mean. struct Parameters class Parameter An abstract representation of a random variable parameter. class PeekingOutliersRemoval struct Parameters class PersistenceManager class Reader class Writer Declaration of the Writer class. struct Policy Implementation of the Policy class. class PolicyBasedSelection Policy-based Selection Strategy. struct Parameters Parameters of the Policy-based Selection. struct PolicyChain Implementation of the PolicyChain class. struct PolicyChainSet class QuestionableRounding struct Parameters class RandomEffectEstimator Random Effect Estimator. struct Parameters Parameters of the RandomEffectEstimator . struct ResultType class RandomSelection Random Selection Strategy. struct Parameters Parameter of Random Selection review strategy. class RankCorrelation Begg's Rank Correlation Test. struct Parameters Parameters of RankCorrelation . struct ResultType class ResearchStrategy Abstract class for different research strategies. class Researcher This class describes a researcher. class ResearcherBuilder class SignificantSelection Significant-based Selection Strategy. struct Parameters class StandardizedMeanDifference class StoppingDataCollection struct Parameters class SubjectiveOutlierRemoval The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. struct Parameters SubjectiveOutlierRemoval 's parameters. class Submission class TTest Declration of t-test. struct Parameters struct ResultType class TestOfObsOverExptSig Test of Excess of Significant Findings. struct Parameters struct ResultType class TestStrategy Abstract class for defining test strategies. class TrimAndFill Trim and Fill Publication Bias Test. struct Parameters Parameters of the TrimAndFill . struct ResultType class WilcoxonTest struct Parameters struct ResultType class YuenTest struct Parameters struct ResultType Updated on 29 June 2021 at 16:13:48 CEST","title":"Classes"},{"location":"doxygen/Classes/#classes","text":"namespace sam class CohensD class ConditionDropping struct Parameters class DataStrategy Abstract class for Data Strategies. class DefaultResearchStrategy The deceleration of the default research strategy. struct Parameters The parameters of the strategy. class DependentVariable Declaration of DependentVariable class. class EffectStrategy Abstract class for Effect Size Strategy. class EggersTestEstimator Egger's Test of Funnel Plot Symmetry. struct Parameters Parameters of the EggersTestEstimator . struct ResultType class Experiment Experiment encapsulates data and methods needed by the Researcher to conduct its research. class ExperimentSetup Declaration of ExperimentSetup class. class ExperimentSetupBuilder class FTest struct Parameters struct ResultType class FabricatingData struct Parameters class FalsifyingData struct Parameters class FixedEffectEstimator Fixed Effect Estimator. struct ResultType class FrankenbachStrategy struct Parameters class FreeSelection FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted. struct Parameters Parameters of free selection. class GRMDataStrategy Simulate data based on General Graded Response Model. struct Parameters class GroupPooling struct Parameters class HackingProbabilityStrategy class HackingStrategy Abstract Class of Hacking Strategies. class HedgesG class Journal Journal Class. class LatentDataStrategy \u26a0\ufe0f TO BE IMPLEMENTED! class LinearModelStrategy Linear Model Data Strategy. struct Parameters Parameters of LinearModelStrategy . class MeanDifference class MetaAnalysis class OptionalDropping struct Parameters class OptionalStopping struct Parameters class OutliersRemoval Declaration of Outlier Removal hacking method based on items' distance from their sample mean. struct Parameters class Parameter An abstract representation of a random variable parameter. class PeekingOutliersRemoval struct Parameters class PersistenceManager class Reader class Writer Declaration of the Writer class. struct Policy Implementation of the Policy class. class PolicyBasedSelection Policy-based Selection Strategy. struct Parameters Parameters of the Policy-based Selection. struct PolicyChain Implementation of the PolicyChain class. struct PolicyChainSet class QuestionableRounding struct Parameters class RandomEffectEstimator Random Effect Estimator. struct Parameters Parameters of the RandomEffectEstimator . struct ResultType class RandomSelection Random Selection Strategy. struct Parameters Parameter of Random Selection review strategy. class RankCorrelation Begg's Rank Correlation Test. struct Parameters Parameters of RankCorrelation . struct ResultType class ResearchStrategy Abstract class for different research strategies. class Researcher This class describes a researcher. class ResearcherBuilder class SignificantSelection Significant-based Selection Strategy. struct Parameters class StandardizedMeanDifference class StoppingDataCollection struct Parameters class SubjectiveOutlierRemoval The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. struct Parameters SubjectiveOutlierRemoval 's parameters. class Submission class TTest Declration of t-test. struct Parameters struct ResultType class TestOfObsOverExptSig Test of Excess of Significant Findings. struct Parameters struct ResultType class TestStrategy Abstract class for defining test strategies. class TrimAndFill Trim and Fill Publication Bias Test. struct Parameters Parameters of the TrimAndFill . struct ResultType class WilcoxonTest struct Parameters struct ResultType class YuenTest struct Parameters struct ResultType Updated on 29 June 2021 at 16:13:48 CEST","title":"Classes"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/","text":"sam::CohensD \u00b6 Module: Effect Strategies Inherits from sam::EffectStrategy Public Functions \u00b6 Name CohensD () =default virtual void computeEffects ( Experiment * experiment) override Additional inherited members \u00b6 Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0 Public Functions Documentation \u00b6 function CohensD \u00b6 explicit CohensD () = default function computeEffects \u00b6 virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::CohensD"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/#samcohensd","text":"Module: Effect Strategies Inherits from sam::EffectStrategy","title":"sam::CohensD"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/#public-functions","text":"Name CohensD () =default virtual void computeEffects ( Experiment * experiment) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/#additional-inherited-members","text":"Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/#function-cohensd","text":"explicit CohensD () = default","title":"function CohensD"},{"location":"doxygen/Classes/classsam_1_1_cohens_d/#function-computeeffects","text":"virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Updated on 29 June 2021 at 16:13:47 CEST","title":"function computeEffects"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/","text":"sam::ConditionDropping \u00b6 Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name ConditionDropping (const Parameters & p) ConditionDropping () Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Public Functions Documentation \u00b6 function ConditionDropping \u00b6 inline explicit ConditionDropping ( const Parameters & p ) function ConditionDropping \u00b6 inline ConditionDropping () Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::ConditionDropping"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#samconditiondropping","text":"Inherits from sam::HackingStrategy","title":"sam::ConditionDropping"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#public-functions","text":"Name ConditionDropping (const Parameters & p) ConditionDropping ()","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#function-conditiondropping","text":"inline explicit ConditionDropping ( const Parameters & p )","title":"function ConditionDropping"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#function-conditiondropping_1","text":"inline ConditionDropping ()","title":"function ConditionDropping"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_condition_dropping/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:46 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/","text":"sam::DataStrategy \u00b6 Module: Data Strategies Abstract class for Data Strategies. More... #include <DataStrategy.h> Inherited by sam::GRMDataStrategy , sam::LatentDataStrategy , sam::LinearModelStrategy Public Types \u00b6 Name enum DataModel Public Functions \u00b6 Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class. virtual void genData ( Experiment * experiment) =0 Generates data based on the selected DataModel. virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) =0 Generates n_new_obs new observations for each group. Detailed Description \u00b6 class sam :: DataStrategy ; Abstract class for Data Strategies. A DataGenStrategy should at least two methods, genData and genNewObservationForAllGroups . The former is mainly used to populate a new Experiment while the latter is being used by some hacking strategies, e.g. OptionalStopping , where new data \u2014 from the same population \u2014 is needed. Public Types Documentation \u00b6 enum DataModel \u00b6 Enumerator Value Description LinearModel LatentModel GradedResponseModel Public Functions Documentation \u00b6 function build \u00b6 static std :: unique_ptr < DataStrategy > build ( json & data_strategy_config ) DataStrategy Factory Method. Parameters : data_strategy_config The data strategy configuration Return : A unique_ptr to a new DataStrategy function ~DataStrategy \u00b6 virtual ~ DataStrategy () = 0 Pure destructors of the DataStrategy abstract class. function genData \u00b6 virtual void genData ( Experiment * experiment ) = 0 Generates data based on the selected DataModel. Parameters : experiment A pointer to an Experiment object Reimplemented by : sam::LinearModelStrategy::genData , sam::LatentDataStrategy::genData , sam::GRMDataStrategy::genData Populates the experiment->groups_->measurements with data based on the parameters specified in setup . function genNewObservationsForAllGroups \u00b6 virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) = 0 Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplemented by : sam::LinearModelStrategy::genNewObservationsForAllGroups , sam::LatentDataStrategy::genNewObservationsForAllGroups , sam::GRMDataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::DataStrategy"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#samdatastrategy","text":"Module: Data Strategies Abstract class for Data Strategies. More... #include <DataStrategy.h> Inherited by sam::GRMDataStrategy , sam::LatentDataStrategy , sam::LinearModelStrategy","title":"sam::DataStrategy"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#public-types","text":"Name enum DataModel","title":"Public Types"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#public-functions","text":"Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class. virtual void genData ( Experiment * experiment) =0 Generates data based on the selected DataModel. virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) =0 Generates n_new_obs new observations for each group.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#detailed-description","text":"class sam :: DataStrategy ; Abstract class for Data Strategies. A DataGenStrategy should at least two methods, genData and genNewObservationForAllGroups . The former is mainly used to populate a new Experiment while the latter is being used by some hacking strategies, e.g. OptionalStopping , where new data \u2014 from the same population \u2014 is needed.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#enum-datamodel","text":"Enumerator Value Description LinearModel LatentModel GradedResponseModel","title":"enum DataModel"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#function-build","text":"static std :: unique_ptr < DataStrategy > build ( json & data_strategy_config ) DataStrategy Factory Method. Parameters : data_strategy_config The data strategy configuration Return : A unique_ptr to a new DataStrategy","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#function-datastrategy","text":"virtual ~ DataStrategy () = 0 Pure destructors of the DataStrategy abstract class.","title":"function ~DataStrategy"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#function-gendata","text":"virtual void genData ( Experiment * experiment ) = 0 Generates data based on the selected DataModel. Parameters : experiment A pointer to an Experiment object Reimplemented by : sam::LinearModelStrategy::genData , sam::LatentDataStrategy::genData , sam::GRMDataStrategy::genData Populates the experiment->groups_->measurements with data based on the parameters specified in setup .","title":"function genData"},{"location":"doxygen/Classes/classsam_1_1_data_strategy/#function-gennewobservationsforallgroups","text":"virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) = 0 Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplemented by : sam::LinearModelStrategy::genNewObservationsForAllGroups , sam::LatentDataStrategy::genNewObservationsForAllGroups , sam::GRMDataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"function genNewObservationsForAllGroups"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/","text":"sam::DecisionStrategy \u00b6 Abstract class for different decision strategies. #include <DecisionStrategy.h> Inherited by sam::DefaultDecisionMaker Public Functions \u00b6 Name virtual ~DecisionStrategy () =0 DecisionStrategy () virtual bool willStartHacking () Indicates whether the researcher will start going to the hacking procedure. The default here is to not go for hacking if we already have one candidate; but this can be overridden in different decision strategies. virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) This will be used by letTheHackBegin and uses the decision policy to decide whether the next hacking strategy is going to be executed ! bool willBeSubmitting (const std::optional< Submission > & sub, PolicyChain & pchain) Submission . virtual bool willContinueReplicating ( PolicyChain & pchain) void clear () void reset () virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) =0 Implementation of decision-making procedure. virtual DecisionStrategy & selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) =0 void saveEveryOutcome ( Experiment & experiment) void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::unique_ptr< DecisionStrategy > build (json & decision_strategy_config) Protected Functions \u00b6 Name void saveCurrentSubmissionCandidate () void selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) void selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Public Attributes \u00b6 Name sol::state lua json config_ std::optional< Submission > submission_candidate SubmissionPool submissions_pool List of selected Submission by the researcher, during the hacking procedure. PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_hacks_selection_policies PolicyChainSet between_reps_policies PolicyChain will_start_hacking_decision_policies PolicyChain will_continue_replicating_decision_policy PolicyChain stashing_policy Public Functions Documentation \u00b6 function ~DecisionStrategy \u00b6 virtual ~ DecisionStrategy () = 0 Pure deconstructor of DecisionStrategy . This is necessary for proper deconstruction of derived classes. function DecisionStrategy \u00b6 DecisionStrategy () function willStartHacking \u00b6 inline virtual bool willStartHacking () Indicates whether the researcher will start going to the hacking procedure. The default here is to not go for hacking if we already have one candidate; but this can be overridden in different decision strategies. Reimplemented by : sam::DefaultDecisionMaker::willStartHacking function willContinueHacking \u00b6 inline virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) This will be used by letTheHackBegin and uses the decision policy to decide whether the next hacking strategy is going to be executed ! Parameters : experiment A reference to the experiment Reimplemented by : sam::DefaultDecisionMaker::willContinueHacking function willBeSubmitting \u00b6 bool willBeSubmitting ( const std :: optional < Submission > & sub , PolicyChain & pchain ) Submission . function willContinueReplicating \u00b6 inline virtual bool willContinueReplicating ( PolicyChain & pchain ) Reimplemented by : sam::DefaultDecisionMaker::willContinueReplicating function clear \u00b6 inline void clear () Clear the contents of the decision strategy, this include the submission pools or other collected information by the decision strategy. function reset \u00b6 inline void reset () Todo : : This needs to be private but currently, I don't have a good place to put it. The verdict system is broken, and if reset it after the selectionBetweenSubmission, it's werid and I cannot just call it in any other methods because then it's hidden Reset the internal state of the decision strategy function selectOutcomeFromExperiment \u00b6 virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) = 0 Implementation of decision-making procedure. Reimplemented by : sam::DefaultDecisionMaker::selectOutcomeFromExperiment function selectOutcomeFromPool \u00b6 virtual DecisionStrategy & selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) = 0 Reimplemented by : sam::DefaultDecisionMaker::selectOutcomeFromPool function saveEveryOutcome \u00b6 inline void saveEveryOutcome ( Experiment & experiment ) function saveOutcomes \u00b6 void saveOutcomes ( Experiment & experiment , PolicyChain & pchain ) Parameters : experiment a reference to the experiment pchain a policy chain, usually stored in stashing_policy in the config file experiment a reference to the experiment pchain a policy chain, usually stored in stashing_policy in the config file Create and save all possible submissions from an experiment, if they pass the given policy predicate Create and save all possible submissions from an experiment, if the satisfy all of the given policies in the pchain. function build \u00b6 static std :: unique_ptr < DecisionStrategy > build ( json & decision_strategy_config ) Parameters : decision_strategy_config A JSON object containing information about each decision strategy. DecisionStrategy factory method. Protected Functions Documentation \u00b6 function saveCurrentSubmissionCandidate \u00b6 inline void saveCurrentSubmissionCandidate () A helper method to save the current submission. This needs to be called after verdict. function selectOutcome \u00b6 void selectOutcome ( Experiment & experiment , PolicyChainSet & pchain_set ) Parameters : experiment a reference to an experiment pchain_set a reference to a policy chain set Select an unique outcome from an experiment, if at some point, a PolicyChain finds a group of outcomes instread of a unique outcome, the selection will be saved and the will await for processing in a different stages. We check all available PolicyChains in the given chain set, and will stop as soon as any chain returns something ! TodoI probably should check this somewhere else, and don't throw here! If we find many, we just collect them, and quit update: I think this is actually an incorrect behavior. I think I was confusing this with stashing! I think I designed pchain operator to be able to return more than one outcome but didn't test for it function selectBetweenSubmissions \u00b6 void selectBetweenSubmissions ( SubmissionPool & spool , PolicyChainSet & pchain_set ) Parameters : spool a collection of submissions collected in previous stages, e.g., selectOutcome pchain_set a set of policy chains Note If submission_candidate is empty to this point, and we cannot find anything here, we'll continue with nothing, and the current experiment will most likely be discarded. Select a unique submission from the given pool of submissions. If none of the submissions satisfies all the policies, we just return, and submission_candidate will not be rewritten. TodoCheck what this actually means! TodoThis is the same issue as it was in selectOutcome, if I return here, I'll not go through the rest of then chain Public Attributes Documentation \u00b6 variable lua \u00b6 sol :: state lua ; variable config_ \u00b6 json config_ ; variable submission_candidate \u00b6 std :: optional < Submission > submission_candidate ; variable submissions_pool \u00b6 SubmissionPool submissions_pool ; List of selected Submission by the researcher, during the hacking procedure. variable initial_selection_policies \u00b6 PolicyChainSet initial_selection_policies ; Todo : : These guys should move to their own class, I don't have to keep everything here! variable submission_decision_policies \u00b6 PolicyChain submission_decision_policies ; variable between_hacks_selection_policies \u00b6 PolicyChainSet between_hacks_selection_policies ; variable between_reps_policies \u00b6 PolicyChainSet between_reps_policies ; variable will_start_hacking_decision_policies \u00b6 PolicyChain will_start_hacking_decision_policies ; variable will_continue_replicating_decision_policy \u00b6 PolicyChain will_continue_replicating_decision_policy ; variable stashing_policy \u00b6 PolicyChain stashing_policy ;","title":"sam::DecisionStrategy"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#samdecisionstrategy","text":"Abstract class for different decision strategies. #include <DecisionStrategy.h> Inherited by sam::DefaultDecisionMaker","title":"sam::DecisionStrategy"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#public-functions","text":"Name virtual ~DecisionStrategy () =0 DecisionStrategy () virtual bool willStartHacking () Indicates whether the researcher will start going to the hacking procedure. The default here is to not go for hacking if we already have one candidate; but this can be overridden in different decision strategies. virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) This will be used by letTheHackBegin and uses the decision policy to decide whether the next hacking strategy is going to be executed ! bool willBeSubmitting (const std::optional< Submission > & sub, PolicyChain & pchain) Submission . virtual bool willContinueReplicating ( PolicyChain & pchain) void clear () void reset () virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) =0 Implementation of decision-making procedure. virtual DecisionStrategy & selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) =0 void saveEveryOutcome ( Experiment & experiment) void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::unique_ptr< DecisionStrategy > build (json & decision_strategy_config)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#protected-functions","text":"Name void saveCurrentSubmissionCandidate () void selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) void selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set)","title":"Protected Functions"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#public-attributes","text":"Name sol::state lua json config_ std::optional< Submission > submission_candidate SubmissionPool submissions_pool List of selected Submission by the researcher, during the hacking procedure. PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_hacks_selection_policies PolicyChainSet between_reps_policies PolicyChain will_start_hacking_decision_policies PolicyChain will_continue_replicating_decision_policy PolicyChain stashing_policy","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-decisionstrategy","text":"virtual ~ DecisionStrategy () = 0 Pure deconstructor of DecisionStrategy . This is necessary for proper deconstruction of derived classes.","title":"function ~DecisionStrategy"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-decisionstrategy_1","text":"DecisionStrategy ()","title":"function DecisionStrategy"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-willstarthacking","text":"inline virtual bool willStartHacking () Indicates whether the researcher will start going to the hacking procedure. The default here is to not go for hacking if we already have one candidate; but this can be overridden in different decision strategies. Reimplemented by : sam::DefaultDecisionMaker::willStartHacking","title":"function willStartHacking"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-willcontinuehacking","text":"inline virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) This will be used by letTheHackBegin and uses the decision policy to decide whether the next hacking strategy is going to be executed ! Parameters : experiment A reference to the experiment Reimplemented by : sam::DefaultDecisionMaker::willContinueHacking","title":"function willContinueHacking"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-willbesubmitting","text":"bool willBeSubmitting ( const std :: optional < Submission > & sub , PolicyChain & pchain ) Submission .","title":"function willBeSubmitting"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-willcontinuereplicating","text":"inline virtual bool willContinueReplicating ( PolicyChain & pchain ) Reimplemented by : sam::DefaultDecisionMaker::willContinueReplicating","title":"function willContinueReplicating"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-clear","text":"inline void clear () Clear the contents of the decision strategy, this include the submission pools or other collected information by the decision strategy.","title":"function clear"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-reset","text":"inline void reset () Todo : : This needs to be private but currently, I don't have a good place to put it. The verdict system is broken, and if reset it after the selectionBetweenSubmission, it's werid and I cannot just call it in any other methods because then it's hidden Reset the internal state of the decision strategy","title":"function reset"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-selectoutcomefromexperiment","text":"virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) = 0 Implementation of decision-making procedure. Reimplemented by : sam::DefaultDecisionMaker::selectOutcomeFromExperiment","title":"function selectOutcomeFromExperiment"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-selectoutcomefrompool","text":"virtual DecisionStrategy & selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) = 0 Reimplemented by : sam::DefaultDecisionMaker::selectOutcomeFromPool","title":"function selectOutcomeFromPool"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-saveeveryoutcome","text":"inline void saveEveryOutcome ( Experiment & experiment )","title":"function saveEveryOutcome"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-saveoutcomes","text":"void saveOutcomes ( Experiment & experiment , PolicyChain & pchain ) Parameters : experiment a reference to the experiment pchain a policy chain, usually stored in stashing_policy in the config file experiment a reference to the experiment pchain a policy chain, usually stored in stashing_policy in the config file Create and save all possible submissions from an experiment, if they pass the given policy predicate Create and save all possible submissions from an experiment, if the satisfy all of the given policies in the pchain.","title":"function saveOutcomes"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-build","text":"static std :: unique_ptr < DecisionStrategy > build ( json & decision_strategy_config ) Parameters : decision_strategy_config A JSON object containing information about each decision strategy. DecisionStrategy factory method.","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-savecurrentsubmissioncandidate","text":"inline void saveCurrentSubmissionCandidate () A helper method to save the current submission. This needs to be called after verdict.","title":"function saveCurrentSubmissionCandidate"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-selectoutcome","text":"void selectOutcome ( Experiment & experiment , PolicyChainSet & pchain_set ) Parameters : experiment a reference to an experiment pchain_set a reference to a policy chain set Select an unique outcome from an experiment, if at some point, a PolicyChain finds a group of outcomes instread of a unique outcome, the selection will be saved and the will await for processing in a different stages. We check all available PolicyChains in the given chain set, and will stop as soon as any chain returns something ! TodoI probably should check this somewhere else, and don't throw here! If we find many, we just collect them, and quit update: I think this is actually an incorrect behavior. I think I was confusing this with stashing! I think I designed pchain operator to be able to return more than one outcome but didn't test for it","title":"function selectOutcome"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#function-selectbetweensubmissions","text":"void selectBetweenSubmissions ( SubmissionPool & spool , PolicyChainSet & pchain_set ) Parameters : spool a collection of submissions collected in previous stages, e.g., selectOutcome pchain_set a set of policy chains Note If submission_candidate is empty to this point, and we cannot find anything here, we'll continue with nothing, and the current experiment will most likely be discarded. Select a unique submission from the given pool of submissions. If none of the submissions satisfies all the policies, we just return, and submission_candidate will not be rewritten. TodoCheck what this actually means! TodoThis is the same issue as it was in selectOutcome, if I return here, I'll not go through the rest of then chain","title":"function selectBetweenSubmissions"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-lua","text":"sol :: state lua ;","title":"variable lua"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-config_","text":"json config_ ;","title":"variable config_"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-submission_candidate","text":"std :: optional < Submission > submission_candidate ;","title":"variable submission_candidate"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-submissions_pool","text":"SubmissionPool submissions_pool ; List of selected Submission by the researcher, during the hacking procedure.","title":"variable submissions_pool"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-initial_selection_policies","text":"PolicyChainSet initial_selection_policies ; Todo : : These guys should move to their own class, I don't have to keep everything here!","title":"variable initial_selection_policies"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-submission_decision_policies","text":"PolicyChain submission_decision_policies ;","title":"variable submission_decision_policies"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-between_hacks_selection_policies","text":"PolicyChainSet between_hacks_selection_policies ;","title":"variable between_hacks_selection_policies"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-between_reps_policies","text":"PolicyChainSet between_reps_policies ;","title":"variable between_reps_policies"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-will_start_hacking_decision_policies","text":"PolicyChain will_start_hacking_decision_policies ;","title":"variable will_start_hacking_decision_policies"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-will_continue_replicating_decision_policy","text":"PolicyChain will_continue_replicating_decision_policy ;","title":"variable will_continue_replicating_decision_policy"},{"location":"doxygen/Classes/classsam_1_1_decision_strategy/#variable-stashing_policy","text":"PolicyChain stashing_policy ;","title":"variable stashing_policy"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/","text":"sam::DefaultDecisionMaker \u00b6 Module: Decision Strategies Inherits from sam::DecisionStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name DefaultDecisionMaker (const Parameters & p) virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) override Implementation of decision-making procedure. virtual DecisionStrategy & selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) override virtual bool willStartHacking () override Decides whether we are going to start hacking. In this canse, we only check if the current_submission complies with will_start_hacking_decision_policies roles; if yes, we will start hacking if no, then we will not continue to the hacking procedure. virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) override virtual bool willContinueReplicating ( PolicyChain & pchain) override Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::DecisionStrategy Name virtual ~DecisionStrategy () =0 DecisionStrategy () bool willBeSubmitting (const std::optional< Submission > & sub, PolicyChain & pchain) Submission . void clear () void reset () void saveEveryOutcome ( Experiment & experiment) void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::unique_ptr< DecisionStrategy > build (json & decision_strategy_config) Protected Functions inherited from sam::DecisionStrategy Name void saveCurrentSubmissionCandidate () void selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) void selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Public Attributes inherited from sam::DecisionStrategy Name sol::state lua json config_ std::optional< Submission > submission_candidate SubmissionPool submissions_pool List of selected Submission by the researcher, during the hacking procedure. PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_hacks_selection_policies PolicyChainSet between_reps_policies PolicyChain will_start_hacking_decision_policies PolicyChain will_continue_replicating_decision_policy PolicyChain stashing_policy Public Functions Documentation \u00b6 function DefaultDecisionMaker \u00b6 inline explicit DefaultDecisionMaker ( const Parameters & p ) function selectOutcomeFromExperiment \u00b6 virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) override Implementation of decision-making procedure. Reimplements : sam::DecisionStrategy::selectOutcomeFromExperiment function selectOutcomeFromPool \u00b6 virtual DecisionStrategy & selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) override Reimplements : sam::DecisionStrategy::selectOutcomeFromPool function willStartHacking \u00b6 virtual bool willStartHacking () override Decides whether we are going to start hacking. In this canse, we only check if the current_submission complies with will_start_hacking_decision_policies roles; if yes, we will start hacking if no, then we will not continue to the hacking procedure. Reimplements : sam::DecisionStrategy::willStartHacking Todothis can be replaced by Policy->oprator() function willContinueHacking \u00b6 virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) override Parameters : pchain a reference to the given policy chain Note The important difference between this and willBeSubmitting is the fact that, the latter will check if all of the rules are passing. Todo : This probably needs to be replaced by something inside the PolicyChain Reimplements : sam::DecisionStrategy::willContinueHacking Determines whether the final_submission_candidates complies with any of the given policies. function willContinueReplicating \u00b6 virtual bool willContinueReplicating ( PolicyChain & pchain ) override Reimplements : sam::DecisionStrategy::willContinueReplicating Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ;","title":"sam::DefaultDecisionMaker"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#samdefaultdecisionmaker","text":"Module: Decision Strategies Inherits from sam::DecisionStrategy","title":"sam::DefaultDecisionMaker"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#public-functions","text":"Name DefaultDecisionMaker (const Parameters & p) virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) override Implementation of decision-making procedure. virtual DecisionStrategy & selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) override virtual bool willStartHacking () override Decides whether we are going to start hacking. In this canse, we only check if the current_submission complies with will_start_hacking_decision_policies roles; if yes, we will start hacking if no, then we will not continue to the hacking procedure. virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) override virtual bool willContinueReplicating ( PolicyChain & pchain) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#additional-inherited-members","text":"Public Functions inherited from sam::DecisionStrategy Name virtual ~DecisionStrategy () =0 DecisionStrategy () bool willBeSubmitting (const std::optional< Submission > & sub, PolicyChain & pchain) Submission . void clear () void reset () void saveEveryOutcome ( Experiment & experiment) void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::unique_ptr< DecisionStrategy > build (json & decision_strategy_config) Protected Functions inherited from sam::DecisionStrategy Name void saveCurrentSubmissionCandidate () void selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) void selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Public Attributes inherited from sam::DecisionStrategy Name sol::state lua json config_ std::optional< Submission > submission_candidate SubmissionPool submissions_pool List of selected Submission by the researcher, during the hacking procedure. PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_hacks_selection_policies PolicyChainSet between_reps_policies PolicyChain will_start_hacking_decision_policies PolicyChain will_continue_replicating_decision_policy PolicyChain stashing_policy","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#function-defaultdecisionmaker","text":"inline explicit DefaultDecisionMaker ( const Parameters & p )","title":"function DefaultDecisionMaker"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#function-selectoutcomefromexperiment","text":"virtual DecisionStrategy & selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) override Implementation of decision-making procedure. Reimplements : sam::DecisionStrategy::selectOutcomeFromExperiment","title":"function selectOutcomeFromExperiment"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#function-selectoutcomefrompool","text":"virtual DecisionStrategy & selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) override Reimplements : sam::DecisionStrategy::selectOutcomeFromPool","title":"function selectOutcomeFromPool"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#function-willstarthacking","text":"virtual bool willStartHacking () override Decides whether we are going to start hacking. In this canse, we only check if the current_submission complies with will_start_hacking_decision_policies roles; if yes, we will start hacking if no, then we will not continue to the hacking procedure. Reimplements : sam::DecisionStrategy::willStartHacking Todothis can be replaced by Policy->oprator()","title":"function willStartHacking"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#function-willcontinuehacking","text":"virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) override Parameters : pchain a reference to the given policy chain Note The important difference between this and willBeSubmitting is the fact that, the latter will check if all of the rules are passing. Todo : This probably needs to be replaced by something inside the PolicyChain Reimplements : sam::DecisionStrategy::willContinueHacking Determines whether the final_submission_candidates complies with any of the given policies.","title":"function willContinueHacking"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#function-willcontinuereplicating","text":"virtual bool willContinueReplicating ( PolicyChain & pchain ) override Reimplements : sam::DecisionStrategy::willContinueReplicating","title":"function willContinueReplicating"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_default_decision_maker/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/","text":"sam::DefaultResearchStrategy \u00b6 Module: Research Strategies The deceleration of the default research strategy. More... #include <ResearchStrategy.h> Inherits from sam::ResearchStrategy Public Classes \u00b6 Name struct Parameters The parameters of the strategy. Public Functions \u00b6 Name DefaultResearchStrategy (const Parameters & p) virtual std::optional< SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) override Returns the result of applying the policy chain set on the Experiment . virtual std::optional< SubmissionPool > selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) override virtual bool willStartHacking (std::optional< SubmissionPool > & subs) override virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) override Determines whether or not the researcher is going to continue hacking. virtual bool willContinueHacking (std::optional< SubmissionPool > & subs, PolicyChain & pchain) override Determines whether or not the researcher is going to continue hacking. virtual bool willContinueReplicating (SubmissionPool & subs) override Determines whether or not the replication procedure is going to place. Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::ResearchStrategy Name virtual ~ResearchStrategy () =0 ResearchStrategy () bool willBeSubmitting (const std::optional< SubmissionPool > & sub, PolicyChain & pchain) void reset () Resets the internal state of the research strategy. std::optional< SubmissionPool > stashedSubmissions () Returns a copy of the stashed_submissions . void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::optional< SubmissionPool > selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the Experiment . std::optional< SubmissionPool > selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the submission pool. std::unique_ptr< ResearchStrategy > build (json & research_strategy_config) ResearchStrategy factory method. Public Attributes inherited from sam::ResearchStrategy Name sol::state lua PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_stashed_selection_policies PolicyChainSet between_reps_policies PolicyChain will_not_start_hacking_decision_policies PolicyChain will_not_continue_replicating_decision_policy PolicyChain stashing_policy Protected Attributes inherited from sam::ResearchStrategy Name std::optional< SubmissionPool > submission_candidates SubmissionPool stashed_submissions Detailed Description \u00b6 class sam :: DefaultResearchStrategy ; The deceleration of the default research strategy. See : Researcher::research() Note : Researcher is in charge of research strategy and it executes its command personally. The default research strategy is the only available strategy at the moment. It is designed to use all the policies explicitly and do not intervene with the given logic. Therefore, it has a very linear flow. Public Functions Documentation \u00b6 function DefaultResearchStrategy \u00b6 inline explicit DefaultResearchStrategy ( const Parameters & p ) function selectOutcomeFromExperiment \u00b6 virtual std :: optional < SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) override Returns the result of applying the policy chain set on the Experiment . Parameters : experiment The experiment pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplements : sam::ResearchStrategy::selectOutcomeFromExperiment If necessasry (ie., if stashing_policy is specified), it stashes some submissions from the experiment and also it returns the result of applying policy chain set on the experiment, if any. TodoCheck if you can implement this a bit nicer function selectOutcomeFromPool \u00b6 virtual std :: optional < SubmissionPool > selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) override Parameters : spool The submission pool pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplements : sam::ResearchStrategy::selectOutcomeFromPool Returns the results of applying the policy chain set on the list of submissions function willStartHacking \u00b6 virtual bool willStartHacking ( std :: optional < SubmissionPool > & subs ) override Parameters : subs A list of submission candidates Return : Returns true if the researcher has to proceed with the hacking strategies. Note : Basically, if at least one of the submissions satisfy all of the criteria, the researcher will not commit to the hacking. Reimplements : sam::ResearchStrategy::willStartHacking Determines whether or not the researcher is going to starting the hacking / procedure In this case, researcher checks if the list of current submissions complies with will_not_start_hacking_decision_policies ; if so, it will NOT start hacking; otherwise, it WILL start the hacking procedure, and proceed to either stashing or replicating. function willContinueHacking \u00b6 virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) override Determines whether or not the researcher is going to continue hacking. Parameters : pchain a reference to the given policy chain Return : Retruns true is the researcher should proceed with the next hacking strategy Reimplements : sam::ResearchStrategy::willContinueHacking Similar to the willStartHacking() checks whether any of the dependent variables are satisfying all pchain policies. function willContinueHacking \u00b6 virtual bool willContinueHacking ( std :: optional < SubmissionPool > & subs , PolicyChain & pchain ) override Determines whether or not the researcher is going to continue hacking. Parameters : subs The list of submissions, if any pchain The policy chain Return : Retruns true if the researcher should proceed with the next hacking strategy Reimplements : sam::ResearchStrategy::willContinueHacking Overload of the willContinueHacking() that operates on a list of submissions instead of an experiment. function willContinueReplicating \u00b6 virtual bool willContinueReplicating ( SubmissionPool & subs ) override Determines whether or not the replication procedure is going to place. Parameters : subs A list of submission candidates Return : Retruns true if the researcher has to continue the replication procedure Reimplements : sam::ResearchStrategy::willContinueReplicating Similar to the willContinueHacking() , but uses will_not_continue_replicating_decision_policy instead. Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::DefaultResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#samdefaultresearchstrategy","text":"Module: Research Strategies The deceleration of the default research strategy. More... #include <ResearchStrategy.h> Inherits from sam::ResearchStrategy","title":"sam::DefaultResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#public-classes","text":"Name struct Parameters The parameters of the strategy.","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#public-functions","text":"Name DefaultResearchStrategy (const Parameters & p) virtual std::optional< SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) override Returns the result of applying the policy chain set on the Experiment . virtual std::optional< SubmissionPool > selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) override virtual bool willStartHacking (std::optional< SubmissionPool > & subs) override virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) override Determines whether or not the researcher is going to continue hacking. virtual bool willContinueHacking (std::optional< SubmissionPool > & subs, PolicyChain & pchain) override Determines whether or not the researcher is going to continue hacking. virtual bool willContinueReplicating (SubmissionPool & subs) override Determines whether or not the replication procedure is going to place.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#additional-inherited-members","text":"Public Functions inherited from sam::ResearchStrategy Name virtual ~ResearchStrategy () =0 ResearchStrategy () bool willBeSubmitting (const std::optional< SubmissionPool > & sub, PolicyChain & pchain) void reset () Resets the internal state of the research strategy. std::optional< SubmissionPool > stashedSubmissions () Returns a copy of the stashed_submissions . void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::optional< SubmissionPool > selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the Experiment . std::optional< SubmissionPool > selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the submission pool. std::unique_ptr< ResearchStrategy > build (json & research_strategy_config) ResearchStrategy factory method. Public Attributes inherited from sam::ResearchStrategy Name sol::state lua PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_stashed_selection_policies PolicyChainSet between_reps_policies PolicyChain will_not_start_hacking_decision_policies PolicyChain will_not_continue_replicating_decision_policy PolicyChain stashing_policy Protected Attributes inherited from sam::ResearchStrategy Name std::optional< SubmissionPool > submission_candidates SubmissionPool stashed_submissions","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#detailed-description","text":"class sam :: DefaultResearchStrategy ; The deceleration of the default research strategy. See : Researcher::research() Note : Researcher is in charge of research strategy and it executes its command personally. The default research strategy is the only available strategy at the moment. It is designed to use all the policies explicitly and do not intervene with the given logic. Therefore, it has a very linear flow.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-defaultresearchstrategy","text":"inline explicit DefaultResearchStrategy ( const Parameters & p )","title":"function DefaultResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-selectoutcomefromexperiment","text":"virtual std :: optional < SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) override Returns the result of applying the policy chain set on the Experiment . Parameters : experiment The experiment pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplements : sam::ResearchStrategy::selectOutcomeFromExperiment If necessasry (ie., if stashing_policy is specified), it stashes some submissions from the experiment and also it returns the result of applying policy chain set on the experiment, if any. TodoCheck if you can implement this a bit nicer","title":"function selectOutcomeFromExperiment"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-selectoutcomefrompool","text":"virtual std :: optional < SubmissionPool > selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) override Parameters : spool The submission pool pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplements : sam::ResearchStrategy::selectOutcomeFromPool Returns the results of applying the policy chain set on the list of submissions","title":"function selectOutcomeFromPool"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-willstarthacking","text":"virtual bool willStartHacking ( std :: optional < SubmissionPool > & subs ) override Parameters : subs A list of submission candidates Return : Returns true if the researcher has to proceed with the hacking strategies. Note : Basically, if at least one of the submissions satisfy all of the criteria, the researcher will not commit to the hacking. Reimplements : sam::ResearchStrategy::willStartHacking Determines whether or not the researcher is going to starting the hacking / procedure In this case, researcher checks if the list of current submissions complies with will_not_start_hacking_decision_policies ; if so, it will NOT start hacking; otherwise, it WILL start the hacking procedure, and proceed to either stashing or replicating.","title":"function willStartHacking"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-willcontinuehacking","text":"virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) override Determines whether or not the researcher is going to continue hacking. Parameters : pchain a reference to the given policy chain Return : Retruns true is the researcher should proceed with the next hacking strategy Reimplements : sam::ResearchStrategy::willContinueHacking Similar to the willStartHacking() checks whether any of the dependent variables are satisfying all pchain policies.","title":"function willContinueHacking"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-willcontinuehacking_1","text":"virtual bool willContinueHacking ( std :: optional < SubmissionPool > & subs , PolicyChain & pchain ) override Determines whether or not the researcher is going to continue hacking. Parameters : subs The list of submissions, if any pchain The policy chain Return : Retruns true if the researcher should proceed with the next hacking strategy Reimplements : sam::ResearchStrategy::willContinueHacking Overload of the willContinueHacking() that operates on a list of submissions instead of an experiment.","title":"function willContinueHacking"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#function-willcontinuereplicating","text":"virtual bool willContinueReplicating ( SubmissionPool & subs ) override Determines whether or not the replication procedure is going to place. Parameters : subs A list of submission candidates Return : Retruns true if the researcher has to continue the replication procedure Reimplements : sam::ResearchStrategy::willContinueReplicating Similar to the willContinueHacking() , but uses will_not_continue_replicating_decision_policy instead.","title":"function willContinueReplicating"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_default_research_strategy/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/","text":"sam::DependentVariable \u00b6 Declaration of DependentVariable class. More... #include <DependentVariable.h> Public Functions \u00b6 Name bool isModified () const bool isHacked () const bool isCandidate () const auto begin () auto end () float & operator[] (std::size_t idx) const float & operator[] (std::size_t idx) const DependentVariable () =default DependentVariable (const arma::Row< float > & data) void setHackedStatus (const bool status) Sets the hacking status. void setCandidateStatus (const bool status) Sets the candidacy status. arma::Row< float > & measurements () Getter / Setter. const arma::Row< float > & measurements () const void setMeasurements (const arma::Row< float > & meas) Sets the raw measurements values. void addNewMeasurements (const arma::Row< float > & new_meas) Adds new measurements to the currently available data. void removeMeasurements (const arma::uvec & idxs) Removes the measurements by their indices. void updateStats () Updates the descriptive statistics of the dependent variable. void clear () Reset the internal state of the dependent variable. std::vector< std::string > Columns () List the name of all avaliable variables. Public Attributes \u00b6 Name float true_nobs_ float true_mean_ float true_std_ int nobs_ float mean_ float var_ float stddev_ float sei_ float stats_ float pvalue_ bool sig_ float effect_ float var_effect_ float se_effect_ int eff_side_ bool is_hacked_ int n_added_obs int n_removed_obs int id_ bool is_candidate_ Submission Meta Data. Detailed Description \u00b6 class sam :: DependentVariable ; Declaration of DependentVariable class. This class is an abstract representation of a dependant variable. It contains raw data, test statistics, and effect size measurements as well as some meta data for keeping track of true nobs, mean, and std values. Public Functions Documentation \u00b6 function isModified \u00b6 inline bool isModified () const function isHacked \u00b6 inline bool isHacked () const function isCandidate \u00b6 inline bool isCandidate () const function begin \u00b6 inline auto begin () function end \u00b6 inline auto end () function operator[] \u00b6 inline float & operator []( std :: size_t idx ) function operator[] \u00b6 inline const float & operator []( std :: size_t idx ) const function DependentVariable \u00b6 DependentVariable () = default function DependentVariable \u00b6 inline explicit DependentVariable ( const arma :: Row < float > & data ) function setHackedStatus \u00b6 inline void setHackedStatus ( const bool status ) Sets the hacking status. function setCandidateStatus \u00b6 inline void setCandidateStatus ( const bool status ) Sets the candidacy status. function measurements \u00b6 inline arma :: Row < float > & measurements () Getter / Setter. function measurements \u00b6 inline const arma :: Row < float > & measurements () const function setMeasurements \u00b6 inline void setMeasurements ( const arma :: Row < float > & meas ) Sets the raw measurements values. function addNewMeasurements \u00b6 inline void addNewMeasurements ( const arma :: Row < float > & new_meas ) Adds new measurements to the currently available data. function removeMeasurements \u00b6 inline void removeMeasurements ( const arma :: uvec & idxs ) Removes the measurements by their indices. function updateStats \u00b6 void updateStats () Updates the descriptive statistics of the dependent variable. This updates all the descriptive statistics of the dependent variable. function clear \u00b6 void clear () Reset the internal state of the dependent variable. This clears and resets the internal state of the class. function Columns \u00b6 static std :: vector < std :: string > Columns () List the name of all avaliable variables. This is being used by the PersistenceManager::Writer to determine the name and number of columns Public Attributes Documentation \u00b6 variable true_nobs_ \u00b6 float true_nobs_ { 0 }; variable true_mean_ \u00b6 float true_mean_ { 0 }; variable true_std_ \u00b6 float true_std_ { 0 }; variable nobs_ \u00b6 int nobs_ { 0 }; variable mean_ \u00b6 float mean_ { 0 }; variable var_ \u00b6 float var_ { 0 }; variable stddev_ \u00b6 float stddev_ { 0 }; variable sei_ \u00b6 float sei_ { 0 }; variable stats_ \u00b6 float stats_ { 0 }; variable pvalue_ \u00b6 float pvalue_ { 0 }; variable sig_ \u00b6 bool sig_ { false }; variable effect_ \u00b6 float effect_ { 0 }; variable var_effect_ \u00b6 float var_effect_ { 0 }; variable se_effect_ \u00b6 float se_effect_ { 0 }; variable eff_side_ \u00b6 int eff_side_ { 0 }; variable is_hacked_ \u00b6 bool is_hacked_ { false }; variable n_added_obs \u00b6 int n_added_obs { 0 }; variable n_removed_obs \u00b6 int n_removed_obs { 0 }; variable id_ \u00b6 int id_ ; Dependent variable's ID. This is being used by Policy to perform some searches variable is_candidate_ \u00b6 bool is_candidate_ { false }; Submission Meta Data. Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::DependentVariable"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#samdependentvariable","text":"Declaration of DependentVariable class. More... #include <DependentVariable.h>","title":"sam::DependentVariable"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#public-functions","text":"Name bool isModified () const bool isHacked () const bool isCandidate () const auto begin () auto end () float & operator[] (std::size_t idx) const float & operator[] (std::size_t idx) const DependentVariable () =default DependentVariable (const arma::Row< float > & data) void setHackedStatus (const bool status) Sets the hacking status. void setCandidateStatus (const bool status) Sets the candidacy status. arma::Row< float > & measurements () Getter / Setter. const arma::Row< float > & measurements () const void setMeasurements (const arma::Row< float > & meas) Sets the raw measurements values. void addNewMeasurements (const arma::Row< float > & new_meas) Adds new measurements to the currently available data. void removeMeasurements (const arma::uvec & idxs) Removes the measurements by their indices. void updateStats () Updates the descriptive statistics of the dependent variable. void clear () Reset the internal state of the dependent variable. std::vector< std::string > Columns () List the name of all avaliable variables.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#public-attributes","text":"Name float true_nobs_ float true_mean_ float true_std_ int nobs_ float mean_ float var_ float stddev_ float sei_ float stats_ float pvalue_ bool sig_ float effect_ float var_effect_ float se_effect_ int eff_side_ bool is_hacked_ int n_added_obs int n_removed_obs int id_ bool is_candidate_ Submission Meta Data.","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#detailed-description","text":"class sam :: DependentVariable ; Declaration of DependentVariable class. This class is an abstract representation of a dependant variable. It contains raw data, test statistics, and effect size measurements as well as some meta data for keeping track of true nobs, mean, and std values.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-ismodified","text":"inline bool isModified () const","title":"function isModified"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-ishacked","text":"inline bool isHacked () const","title":"function isHacked"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-iscandidate","text":"inline bool isCandidate () const","title":"function isCandidate"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-begin","text":"inline auto begin ()","title":"function begin"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-end","text":"inline auto end ()","title":"function end"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-operator","text":"inline float & operator []( std :: size_t idx )","title":"function operator[]"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-operator_1","text":"inline const float & operator []( std :: size_t idx ) const","title":"function operator[]"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-dependentvariable","text":"DependentVariable () = default","title":"function DependentVariable"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-dependentvariable_1","text":"inline explicit DependentVariable ( const arma :: Row < float > & data )","title":"function DependentVariable"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-sethackedstatus","text":"inline void setHackedStatus ( const bool status ) Sets the hacking status.","title":"function setHackedStatus"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-setcandidatestatus","text":"inline void setCandidateStatus ( const bool status ) Sets the candidacy status.","title":"function setCandidateStatus"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-measurements","text":"inline arma :: Row < float > & measurements () Getter / Setter.","title":"function measurements"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-measurements_1","text":"inline const arma :: Row < float > & measurements () const","title":"function measurements"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-setmeasurements","text":"inline void setMeasurements ( const arma :: Row < float > & meas ) Sets the raw measurements values.","title":"function setMeasurements"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-addnewmeasurements","text":"inline void addNewMeasurements ( const arma :: Row < float > & new_meas ) Adds new measurements to the currently available data.","title":"function addNewMeasurements"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-removemeasurements","text":"inline void removeMeasurements ( const arma :: uvec & idxs ) Removes the measurements by their indices.","title":"function removeMeasurements"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-updatestats","text":"void updateStats () Updates the descriptive statistics of the dependent variable. This updates all the descriptive statistics of the dependent variable.","title":"function updateStats"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-clear","text":"void clear () Reset the internal state of the dependent variable. This clears and resets the internal state of the class.","title":"function clear"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#function-columns","text":"static std :: vector < std :: string > Columns () List the name of all avaliable variables. This is being used by the PersistenceManager::Writer to determine the name and number of columns","title":"function Columns"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-true_nobs_","text":"float true_nobs_ { 0 };","title":"variable true_nobs_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-true_mean_","text":"float true_mean_ { 0 };","title":"variable true_mean_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-true_std_","text":"float true_std_ { 0 };","title":"variable true_std_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-nobs_","text":"int nobs_ { 0 };","title":"variable nobs_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-mean_","text":"float mean_ { 0 };","title":"variable mean_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-var_","text":"float var_ { 0 };","title":"variable var_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-stddev_","text":"float stddev_ { 0 };","title":"variable stddev_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-sei_","text":"float sei_ { 0 };","title":"variable sei_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-stats_","text":"float stats_ { 0 };","title":"variable stats_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-pvalue_","text":"float pvalue_ { 0 };","title":"variable pvalue_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-sig_","text":"bool sig_ { false };","title":"variable sig_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-effect_","text":"float effect_ { 0 };","title":"variable effect_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-var_effect_","text":"float var_effect_ { 0 };","title":"variable var_effect_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-se_effect_","text":"float se_effect_ { 0 };","title":"variable se_effect_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-eff_side_","text":"int eff_side_ { 0 };","title":"variable eff_side_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-is_hacked_","text":"bool is_hacked_ { false };","title":"variable is_hacked_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-n_added_obs","text":"int n_added_obs { 0 };","title":"variable n_added_obs"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-n_removed_obs","text":"int n_removed_obs { 0 };","title":"variable n_removed_obs"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-id_","text":"int id_ ; Dependent variable's ID. This is being used by Policy to perform some searches","title":"variable id_"},{"location":"doxygen/Classes/classsam_1_1_dependent_variable/#variable-is_candidate_","text":"bool is_candidate_ { false }; Submission Meta Data. Updated on 29 June 2021 at 16:13:46 CEST","title":"variable is_candidate_"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/","text":"sam::EffectStrategy \u00b6 Abstract class for Effect Size Strategy. #include <EffectStrategy.h> Inherited by sam::CohensD , sam::HedgesG , sam::MeanDifference , sam::StandardizedMeanDifference Public Types \u00b6 Name enum EffectEstimator Public Functions \u00b6 Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0 virtual void computeEffects ( Experiment * experiment) =0 Public Types Documentation \u00b6 enum EffectEstimator \u00b6 Enumerator Value Description CohensD HedgesG OddRatio StandardizedMeanDifference Public Functions Documentation \u00b6 function build \u00b6 static std :: unique_ptr < EffectStrategy > build ( json & effect_strategy_config ) function ~EffectStrategy \u00b6 virtual ~ EffectStrategy () = 0 function computeEffects \u00b6 virtual void computeEffects ( Experiment * experiment ) = 0 Reimplemented by : sam::MeanDifference::computeEffects , sam::StandardizedMeanDifference::computeEffects , sam::CohensD::computeEffects , sam::HedgesG::computeEffects Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::EffectStrategy"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#sameffectstrategy","text":"Abstract class for Effect Size Strategy. #include <EffectStrategy.h> Inherited by sam::CohensD , sam::HedgesG , sam::MeanDifference , sam::StandardizedMeanDifference","title":"sam::EffectStrategy"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#public-types","text":"Name enum EffectEstimator","title":"Public Types"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#public-functions","text":"Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0 virtual void computeEffects ( Experiment * experiment) =0","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#enum-effectestimator","text":"Enumerator Value Description CohensD HedgesG OddRatio StandardizedMeanDifference","title":"enum EffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#function-build","text":"static std :: unique_ptr < EffectStrategy > build ( json & effect_strategy_config )","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#function-effectstrategy","text":"virtual ~ EffectStrategy () = 0","title":"function ~EffectStrategy"},{"location":"doxygen/Classes/classsam_1_1_effect_strategy/#function-computeeffects","text":"virtual void computeEffects ( Experiment * experiment ) = 0 Reimplemented by : sam::MeanDifference::computeEffects , sam::StandardizedMeanDifference::computeEffects , sam::CohensD::computeEffects , sam::HedgesG::computeEffects Updated on 29 June 2021 at 16:13:46 CEST","title":"function computeEffects"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/","text":"sam::EggersTestEstimator \u00b6 Module: Meta Analysis Methods Egger's Test of Funnel Plot Symmetry. More... #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis Public Classes \u00b6 Name struct Parameters Parameters of the EggersTestEstimator . struct ResultType Public Functions \u00b6 Name EggersTestEstimator () =default EggersTestEstimator (const Parameters & p) virtual void estimate ( Journal * journal) ResultType EggersTest (const arma::Row< float > & yi, const arma::Row< float > & vi, float alpha) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Detailed Description \u00b6 class sam :: EggersTestEstimator ; Egger's Test of Funnel Plot Symmetry. A strategy performing Egger's Test on the available list of Journal 's publications. List of available parameters and the format of output can be found in Parameters , and ResultType . Public Functions Documentation \u00b6 function EggersTestEstimator \u00b6 EggersTestEstimator () = default function EggersTestEstimator \u00b6 inline EggersTestEstimator ( const Parameters & p ) function estimate \u00b6 virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate function EggersTest \u00b6 static ResultType EggersTest ( const arma :: Row < float > & yi , const arma :: Row < float > & vi , float alpha ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::EggersTestEstimator"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#sameggerstestestimator","text":"Module: Meta Analysis Methods Egger's Test of Funnel Plot Symmetry. More... #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis","title":"sam::EggersTestEstimator"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#public-classes","text":"Name struct Parameters Parameters of the EggersTestEstimator . struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#public-functions","text":"Name EggersTestEstimator () =default EggersTestEstimator (const Parameters & p) virtual void estimate ( Journal * journal) ResultType EggersTest (const arma::Row< float > & yi, const arma::Row< float > & vi, float alpha)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#additional-inherited-members","text":"Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#detailed-description","text":"class sam :: EggersTestEstimator ; Egger's Test of Funnel Plot Symmetry. A strategy performing Egger's Test on the available list of Journal 's publications. List of available parameters and the format of output can be found in Parameters , and ResultType .","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#function-eggerstestestimator","text":"EggersTestEstimator () = default","title":"function EggersTestEstimator"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#function-eggerstestestimator_1","text":"inline EggersTestEstimator ( const Parameters & p )","title":"function EggersTestEstimator"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#function-estimate","text":"virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#function-eggerstest","text":"static ResultType EggersTest ( const arma :: Row < float > & yi , const arma :: Row < float > & vi , float alpha )","title":"function EggersTest"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_eggers_test_estimator/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_experiment/","text":"sam::Experiment \u00b6 Module: Experiment Modules Experiment encapsulates data and methods needed by the Researcher to conduct its research. More... #include <Experiment.h> Public Functions \u00b6 Name DependentVariable & operator[] (std::size_t idx) const DependentVariable & operator[] (std::size_t idx) const auto begin () auto end () auto begin () const auto end () const Experiment () =default Default constructor. Experiment (json & experiment_config) Constructs an Experiment object using the given JSON configuration. Experiment ( ExperimentSetup & e) Constructs an Experiment using an already initialized ExperimentSetup . Experiment ( ExperimentSetup & e, std::shared_ptr< DataStrategy > & ds, std::shared_ptr< TestStrategy > & ts, std::shared_ptr< EffectStrategy > & es) Directly constructs an Experiment from its components. void addNewCondition () void addNewCondition (const std::vector< DependentVariable > & dvs) void addNewDependentVariable (const DependentVariable & dv) Adds a new dependent variable to the list. void addNewCandidates (const std::vector< Submission > & subs) Adds new submissions to the list of submissions. void setHackedStatus (const bool status) Sets the hacked status of the experiment. void setPublishedStatus (const bool status) Sets the published status of the experiment. void setHackedStatusOf (const std::vector< size_t > & idxs, const bool status) Sets the hacked status of a group of dvs. void setCandidateStatusOf (const std::vector< size_t > & idxs, const bool status) Sets the candidate status of a group of dvs. bool isHacked () const Returns true if the experiment is hacked. bool isModified () const Returns true if the experiment has been modified in anyway. bool hasCandidates () const Returns true if there is an candidate in the experiment. bool hasCovariants () const Returns true if there is an candidate in the experiment. bool isPublished () const Returns true if the experiment has been published by the Journal . size_t nCandidates () const Returns the number of candidate DVs. int nCovariants () const void reset () Clears and re-initializes the dependent variables. void generateData () Uses the DataStrategy to populate every DVs with raw the data. void generateCovariants () Generates covariants data. void calculateStatistics () Asks each DependentVariable to update its general statistics, e.g., mean, var. void calculateTests () Uses the TestStrategy to run the statistical test. void calculateEffects () Uses the EffectStrategy to calculates the effect sizes. void recalculateEverything () Runs calculateStatistics() , calculateTests() , and calculateEffects() in order. void clear () Clears the content of the experiment. void setTestStrategy (std::shared_ptr< TestStrategy > & ts) void setDataStrategy (std::shared_ptr< DataStrategy > & ds) void setEffectSizeEstimator (std::shared_ptr< EffectStrategy > & es) Public Attributes \u00b6 Name int simid int exprid int repid int n_covariants Indicates the number of covariants. arma::Mat< int > covariants ExperimentSetup setup std::shared_ptr< DataStrategy > data_strategy std::shared_ptr< TestStrategy > test_strategy std::shared_ptr< EffectStrategy > effect_strategy std::vector< DependentVariable > dvs_ std::optional< std::vector< Submission > > candidates List of all possible candidates from this experiment so far! Detailed Description \u00b6 class sam :: Experiment ; Experiment encapsulates data and methods needed by the Researcher to conduct its research. Experiment has a full access to all data-related strategies, e.g., DataStrategy , TestStrategy , and EffectStrategy . It also contains the raw research data in the form of list of DependentVariable(s). Moreover, the Experiment stores a copy of the ExperimentSetup where most study parameters are stored in. Public Functions Documentation \u00b6 function operator[] \u00b6 DependentVariable & operator []( std :: size_t idx ) Todo : I'm not the fan of this find_if here, and I think I can do better. I think I can avoid this search if I use std::reference_wrapper These operators are returning the correct group, even if the group list is not sorted. function operator[] \u00b6 const DependentVariable & operator []( std :: size_t idx ) const function begin \u00b6 inline auto begin () function end \u00b6 inline auto end () function begin \u00b6 inline auto begin () const function end \u00b6 inline auto end () const function Experiment \u00b6 Experiment () = default Default constructor. function Experiment \u00b6 Experiment ( json & experiment_config ) Constructs an Experiment object using the given JSON configuration. This constructs an Experiment , and allocates the resources necessary for the experiment to setup its dependent variables, etc. Using the config parameters of the Data, Test, and Effect strategies, it also initializes those to be used by the Researcher or the Experiment itself function Experiment \u00b6 Experiment ( ExperimentSetup & e ) Constructs an Experiment using an already initialized ExperimentSetup . Note : This can be used in cases where the underlying strategies should be preserved while some experiment parameters needs to be modified. Since ExperimentSetup already contains the definition of Data, Test, and Effect strategies, this method accepts the ExperimentSetup as it is, and only initialize those strategies. function Experiment \u00b6 Experiment ( ExperimentSetup & e , std :: shared_ptr < DataStrategy > & ds , std :: shared_ptr < TestStrategy > & ts , std :: shared_ptr < EffectStrategy > & es ) Directly constructs an Experiment from its components. Note : This is mainly used by the ExperimentBuilder This directly constructs the experiment by directly constructing its internal based on the set of given parameters. function addNewCondition \u00b6 void addNewCondition () Adds a new condition @TODO TO BE IMPLEMENTED! function addNewCondition \u00b6 void addNewCondition ( const std :: vector < DependentVariable > & dvs ) Adds a new condition @TODO TO BE IMPLEMENTED! function addNewDependentVariable \u00b6 void addNewDependentVariable ( const DependentVariable & dv ) Adds a new dependent variable to the list. function addNewCandidates \u00b6 void addNewCandidates ( const std :: vector < Submission > & subs ) Adds new submissions to the list of submissions. Adds new candidates to the list of selected candidates function setHackedStatus \u00b6 void setHackedStatus ( const bool status ) Sets the hacked status of the experiment. Attention : Setting this to true will make the [isHacked()](/doxygen/Classes/classsam_1_1_experiment/#function-ishacked) to return true . Basically, this overrules the status of the dependent variables, but it doesn't overwrite them! It sets the overall hacked status of the experiment to status. function setPublishedStatus \u00b6 void setPublishedStatus ( const bool status ) Sets the published status of the experiment. function setHackedStatusOf \u00b6 void setHackedStatusOf ( const std :: vector < size_t > & idxs , const bool status ) Sets the hacked status of a group of dvs. function setCandidateStatusOf \u00b6 void setCandidateStatusOf ( const std :: vector < size_t > & idxs , const bool status ) Sets the candidate status of a group of dvs. function isHacked \u00b6 bool isHacked () const Returns true if the experiment is hacked. An experiment is hacked if its hacked status has been set to true , or one of its dependent variables has been flagged as hacked function isModified \u00b6 bool isModified () const Returns true if the experiment has been modified in anyway. function hasCandidates \u00b6 bool hasCandidates () const Returns true if there is an candidate in the experiment. function hasCovariants \u00b6 bool hasCovariants () const Returns true if there is an candidate in the experiment. function isPublished \u00b6 bool isPublished () const Returns true if the experiment has been published by the Journal . function nCandidates \u00b6 size_t nCandidates () const Returns the number of candidate DVs. function nCovariants \u00b6 int nCovariants () const function reset \u00b6 void reset () Clears and re-initializes the dependent variables. This cleanup the Experiment , and reallocate its memory again. Technically, preparing the experiment for a new run. function generateData \u00b6 void generateData () Uses the DataStrategy to populate every DVs with raw the data. function generateCovariants \u00b6 void generateCovariants () Generates covariants data. @Todo Check if all groups are the same size function calculateStatistics \u00b6 void calculateStatistics () Asks each DependentVariable to update its general statistics, e.g., mean, var. function calculateTests \u00b6 void calculateTests () Uses the TestStrategy to run the statistical test. function calculateEffects \u00b6 void calculateEffects () Uses the EffectStrategy to calculates the effect sizes. function recalculateEverything \u00b6 void recalculateEverything () Runs calculateStatistics() , calculateTests() , and calculateEffects() in order. function clear \u00b6 void clear () Clears the content of the experiment. Todo : I think this is a bad implementation, and I should probably just discard the list of DVs and recreate them for the new Experiment , which is probably safer! Something like dvs_.clear() It clears every DVs individually, and also sort them back into the correct order. function setTestStrategy \u00b6 inline void setTestStrategy ( std :: shared_ptr < TestStrategy > & ts ) Parameters : t A reference to a Test Strategy instance Set or re-set the Test Strategy function setDataStrategy \u00b6 inline void setDataStrategy ( std :: shared_ptr < DataStrategy > & ds ) Parameters : d A reference to a Data Strategy instance Set or re-set the Data Strategy function setEffectSizeEstimator \u00b6 inline void setEffectSizeEstimator ( std :: shared_ptr < EffectStrategy > & es ) Parameters : es A reference to an Effect Strategy instance. Set or re-set the Effect Strategy Public Attributes Documentation \u00b6 variable simid \u00b6 int simid { 0 }; variable exprid \u00b6 int exprid { 0 }; variable repid \u00b6 int repid { 0 }; variable n_covariants \u00b6 int n_covariants { 0 }; Indicates the number of covariants. variable covariants \u00b6 arma :: Mat < int > covariants ; variable setup \u00b6 ExperimentSetup setup ; An instance of the ExperimentSetup . All other strategies can access and query it for meta information about the Experiment variable data_strategy \u00b6 std :: shared_ptr < DataStrategy > data_strategy ; variable test_strategy \u00b6 std :: shared_ptr < TestStrategy > test_strategy ; variable effect_strategy \u00b6 std :: shared_ptr < EffectStrategy > effect_strategy ; variable dvs_ \u00b6 std :: vector < DependentVariable > dvs_ ; variable candidates \u00b6 std :: optional < std :: vector < Submission > > candidates ; List of all possible candidates from this experiment so far! Note : This is not yet in use! This is a list of any dvs that has been flagged as submissions during the lifespan of this experiment Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::Experiment"},{"location":"doxygen/Classes/classsam_1_1_experiment/#samexperiment","text":"Module: Experiment Modules Experiment encapsulates data and methods needed by the Researcher to conduct its research. More... #include <Experiment.h>","title":"sam::Experiment"},{"location":"doxygen/Classes/classsam_1_1_experiment/#public-functions","text":"Name DependentVariable & operator[] (std::size_t idx) const DependentVariable & operator[] (std::size_t idx) const auto begin () auto end () auto begin () const auto end () const Experiment () =default Default constructor. Experiment (json & experiment_config) Constructs an Experiment object using the given JSON configuration. Experiment ( ExperimentSetup & e) Constructs an Experiment using an already initialized ExperimentSetup . Experiment ( ExperimentSetup & e, std::shared_ptr< DataStrategy > & ds, std::shared_ptr< TestStrategy > & ts, std::shared_ptr< EffectStrategy > & es) Directly constructs an Experiment from its components. void addNewCondition () void addNewCondition (const std::vector< DependentVariable > & dvs) void addNewDependentVariable (const DependentVariable & dv) Adds a new dependent variable to the list. void addNewCandidates (const std::vector< Submission > & subs) Adds new submissions to the list of submissions. void setHackedStatus (const bool status) Sets the hacked status of the experiment. void setPublishedStatus (const bool status) Sets the published status of the experiment. void setHackedStatusOf (const std::vector< size_t > & idxs, const bool status) Sets the hacked status of a group of dvs. void setCandidateStatusOf (const std::vector< size_t > & idxs, const bool status) Sets the candidate status of a group of dvs. bool isHacked () const Returns true if the experiment is hacked. bool isModified () const Returns true if the experiment has been modified in anyway. bool hasCandidates () const Returns true if there is an candidate in the experiment. bool hasCovariants () const Returns true if there is an candidate in the experiment. bool isPublished () const Returns true if the experiment has been published by the Journal . size_t nCandidates () const Returns the number of candidate DVs. int nCovariants () const void reset () Clears and re-initializes the dependent variables. void generateData () Uses the DataStrategy to populate every DVs with raw the data. void generateCovariants () Generates covariants data. void calculateStatistics () Asks each DependentVariable to update its general statistics, e.g., mean, var. void calculateTests () Uses the TestStrategy to run the statistical test. void calculateEffects () Uses the EffectStrategy to calculates the effect sizes. void recalculateEverything () Runs calculateStatistics() , calculateTests() , and calculateEffects() in order. void clear () Clears the content of the experiment. void setTestStrategy (std::shared_ptr< TestStrategy > & ts) void setDataStrategy (std::shared_ptr< DataStrategy > & ds) void setEffectSizeEstimator (std::shared_ptr< EffectStrategy > & es)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_experiment/#public-attributes","text":"Name int simid int exprid int repid int n_covariants Indicates the number of covariants. arma::Mat< int > covariants ExperimentSetup setup std::shared_ptr< DataStrategy > data_strategy std::shared_ptr< TestStrategy > test_strategy std::shared_ptr< EffectStrategy > effect_strategy std::vector< DependentVariable > dvs_ std::optional< std::vector< Submission > > candidates List of all possible candidates from this experiment so far!","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_experiment/#detailed-description","text":"class sam :: Experiment ; Experiment encapsulates data and methods needed by the Researcher to conduct its research. Experiment has a full access to all data-related strategies, e.g., DataStrategy , TestStrategy , and EffectStrategy . It also contains the raw research data in the form of list of DependentVariable(s). Moreover, the Experiment stores a copy of the ExperimentSetup where most study parameters are stored in.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_experiment/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-operator","text":"DependentVariable & operator []( std :: size_t idx ) Todo : I'm not the fan of this find_if here, and I think I can do better. I think I can avoid this search if I use std::reference_wrapper These operators are returning the correct group, even if the group list is not sorted.","title":"function operator[]"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-operator_1","text":"const DependentVariable & operator []( std :: size_t idx ) const","title":"function operator[]"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-begin","text":"inline auto begin ()","title":"function begin"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-end","text":"inline auto end ()","title":"function end"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-begin_1","text":"inline auto begin () const","title":"function begin"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-end_1","text":"inline auto end () const","title":"function end"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-experiment","text":"Experiment () = default Default constructor.","title":"function Experiment"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-experiment_1","text":"Experiment ( json & experiment_config ) Constructs an Experiment object using the given JSON configuration. This constructs an Experiment , and allocates the resources necessary for the experiment to setup its dependent variables, etc. Using the config parameters of the Data, Test, and Effect strategies, it also initializes those to be used by the Researcher or the Experiment itself","title":"function Experiment"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-experiment_2","text":"Experiment ( ExperimentSetup & e ) Constructs an Experiment using an already initialized ExperimentSetup . Note : This can be used in cases where the underlying strategies should be preserved while some experiment parameters needs to be modified. Since ExperimentSetup already contains the definition of Data, Test, and Effect strategies, this method accepts the ExperimentSetup as it is, and only initialize those strategies.","title":"function Experiment"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-experiment_3","text":"Experiment ( ExperimentSetup & e , std :: shared_ptr < DataStrategy > & ds , std :: shared_ptr < TestStrategy > & ts , std :: shared_ptr < EffectStrategy > & es ) Directly constructs an Experiment from its components. Note : This is mainly used by the ExperimentBuilder This directly constructs the experiment by directly constructing its internal based on the set of given parameters.","title":"function Experiment"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-addnewcondition","text":"void addNewCondition () Adds a new condition @TODO TO BE IMPLEMENTED!","title":"function addNewCondition"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-addnewcondition_1","text":"void addNewCondition ( const std :: vector < DependentVariable > & dvs ) Adds a new condition @TODO TO BE IMPLEMENTED!","title":"function addNewCondition"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-addnewdependentvariable","text":"void addNewDependentVariable ( const DependentVariable & dv ) Adds a new dependent variable to the list.","title":"function addNewDependentVariable"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-addnewcandidates","text":"void addNewCandidates ( const std :: vector < Submission > & subs ) Adds new submissions to the list of submissions. Adds new candidates to the list of selected candidates","title":"function addNewCandidates"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-sethackedstatus","text":"void setHackedStatus ( const bool status ) Sets the hacked status of the experiment. Attention : Setting this to true will make the [isHacked()](/doxygen/Classes/classsam_1_1_experiment/#function-ishacked) to return true . Basically, this overrules the status of the dependent variables, but it doesn't overwrite them! It sets the overall hacked status of the experiment to status.","title":"function setHackedStatus"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-setpublishedstatus","text":"void setPublishedStatus ( const bool status ) Sets the published status of the experiment.","title":"function setPublishedStatus"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-sethackedstatusof","text":"void setHackedStatusOf ( const std :: vector < size_t > & idxs , const bool status ) Sets the hacked status of a group of dvs.","title":"function setHackedStatusOf"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-setcandidatestatusof","text":"void setCandidateStatusOf ( const std :: vector < size_t > & idxs , const bool status ) Sets the candidate status of a group of dvs.","title":"function setCandidateStatusOf"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-ishacked","text":"bool isHacked () const Returns true if the experiment is hacked. An experiment is hacked if its hacked status has been set to true , or one of its dependent variables has been flagged as hacked","title":"function isHacked"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-ismodified","text":"bool isModified () const Returns true if the experiment has been modified in anyway.","title":"function isModified"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-hascandidates","text":"bool hasCandidates () const Returns true if there is an candidate in the experiment.","title":"function hasCandidates"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-hascovariants","text":"bool hasCovariants () const Returns true if there is an candidate in the experiment.","title":"function hasCovariants"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-ispublished","text":"bool isPublished () const Returns true if the experiment has been published by the Journal .","title":"function isPublished"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-ncandidates","text":"size_t nCandidates () const Returns the number of candidate DVs.","title":"function nCandidates"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-ncovariants","text":"int nCovariants () const","title":"function nCovariants"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-reset","text":"void reset () Clears and re-initializes the dependent variables. This cleanup the Experiment , and reallocate its memory again. Technically, preparing the experiment for a new run.","title":"function reset"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-generatedata","text":"void generateData () Uses the DataStrategy to populate every DVs with raw the data.","title":"function generateData"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-generatecovariants","text":"void generateCovariants () Generates covariants data. @Todo Check if all groups are the same size","title":"function generateCovariants"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-calculatestatistics","text":"void calculateStatistics () Asks each DependentVariable to update its general statistics, e.g., mean, var.","title":"function calculateStatistics"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-calculatetests","text":"void calculateTests () Uses the TestStrategy to run the statistical test.","title":"function calculateTests"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-calculateeffects","text":"void calculateEffects () Uses the EffectStrategy to calculates the effect sizes.","title":"function calculateEffects"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-recalculateeverything","text":"void recalculateEverything () Runs calculateStatistics() , calculateTests() , and calculateEffects() in order.","title":"function recalculateEverything"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-clear","text":"void clear () Clears the content of the experiment. Todo : I think this is a bad implementation, and I should probably just discard the list of DVs and recreate them for the new Experiment , which is probably safer! Something like dvs_.clear() It clears every DVs individually, and also sort them back into the correct order.","title":"function clear"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-setteststrategy","text":"inline void setTestStrategy ( std :: shared_ptr < TestStrategy > & ts ) Parameters : t A reference to a Test Strategy instance Set or re-set the Test Strategy","title":"function setTestStrategy"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-setdatastrategy","text":"inline void setDataStrategy ( std :: shared_ptr < DataStrategy > & ds ) Parameters : d A reference to a Data Strategy instance Set or re-set the Data Strategy","title":"function setDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_experiment/#function-seteffectsizeestimator","text":"inline void setEffectSizeEstimator ( std :: shared_ptr < EffectStrategy > & es ) Parameters : es A reference to an Effect Strategy instance. Set or re-set the Effect Strategy","title":"function setEffectSizeEstimator"},{"location":"doxygen/Classes/classsam_1_1_experiment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-simid","text":"int simid { 0 };","title":"variable simid"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-exprid","text":"int exprid { 0 };","title":"variable exprid"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-repid","text":"int repid { 0 };","title":"variable repid"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-n_covariants","text":"int n_covariants { 0 }; Indicates the number of covariants.","title":"variable n_covariants"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-covariants","text":"arma :: Mat < int > covariants ;","title":"variable covariants"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-setup","text":"ExperimentSetup setup ; An instance of the ExperimentSetup . All other strategies can access and query it for meta information about the Experiment","title":"variable setup"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-data_strategy","text":"std :: shared_ptr < DataStrategy > data_strategy ;","title":"variable data_strategy"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-test_strategy","text":"std :: shared_ptr < TestStrategy > test_strategy ;","title":"variable test_strategy"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-effect_strategy","text":"std :: shared_ptr < EffectStrategy > effect_strategy ;","title":"variable effect_strategy"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-dvs_","text":"std :: vector < DependentVariable > dvs_ ;","title":"variable dvs_"},{"location":"doxygen/Classes/classsam_1_1_experiment/#variable-candidates","text":"std :: optional < std :: vector < Submission > > candidates ; List of all possible candidates from this experiment so far! Note : This is not yet in use! This is a list of any dvs that has been flagged as submissions during the lifespan of this experiment Updated on 29 June 2021 at 16:13:47 CEST","title":"variable candidates"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/","text":"sam::ExperimentSetup \u00b6 Module: Experiment Modules Declaration of ExperimentSetup class. More... #include <ExperimentSetup.h> Public Functions \u00b6 Name void setObs (const json & config, size_t n_c, size_t n_d) void setObs ( Parameter < int > nobs, size_t n_c, size_t n_d) void setObs (const arma::Row< int > & nobs, size_t n_c, size_t n_d) ExperimentSetupBuilder create () ExperimentSetup () =default ExperimentSetup (json & config) Constructs and initializes the ExperimentSetup . int nc () const Returns the number of conditions. void setNC (int n_c) Sets the number of conditions. int nd () const Returns the number of dependent variables in each conditions. void setND (int n_d) Sets the number of dependent variables in each group. int ng () const Returns the total number of groups. int nreps () const Returns the total number of planned replications. void setNR (int n_reps) Sets the number of replications. const arma::Row< int > & nobs () const Returns the original number of observations per group. void randomize () Randomizes the internal parameters of the Experiment , if necessary. Public Attributes \u00b6 Name json tsp_conf Test Strategy Parameters. json dsp_conf Data Strategy Parameters. json esp_conf Effect Estimator Parameters. Friends \u00b6 Name class ExperimentSetupBuilder Detailed Description \u00b6 class sam :: ExperimentSetup ; Declaration of ExperimentSetup class. ExperimentSetup stores all the necessary parameters concerning the experiment design, e.g., number of conditions, number of dependent variables, etc. It also stores a copy of the data, test, and effect strategies' configurations. Public Functions Documentation \u00b6 function setObs \u00b6 inline void setObs ( const json & config , size_t n_c , size_t n_d ) function setObs \u00b6 inline void setObs ( Parameter < int > nobs , size_t n_c , size_t n_d ) function setObs \u00b6 inline void setObs ( const arma :: Row < int > & nobs , size_t n_c , size_t n_d ) function create \u00b6 static ExperimentSetupBuilder create () Return : An instance of the builder. Create a new ExperimentSetup by invoking a ExperimentSetupBuilder . function ExperimentSetup \u00b6 ExperimentSetup () = default function ExperimentSetup \u00b6 explicit ExperimentSetup ( json & config ) Constructs and initializes the ExperimentSetup . Parameters : config A JSON configuration object This set and calculates design parameters of the experiment. It also archives the definition of data, test, and effect strategies. These archives may later be retrieved by the Journal during the review process. function nc \u00b6 inline int nc () const Returns the number of conditions. function setNC \u00b6 inline void setNC ( int n_c ) Sets the number of conditions. function nd \u00b6 inline int nd () const Returns the number of dependent variables in each conditions. function setND \u00b6 inline void setND ( int n_d ) Sets the number of dependent variables in each group. function ng \u00b6 inline int ng () const Returns the total number of groups. This is an internal parameters and it's mainly used to iterate over conditions and dependent variables. It's calculated as n_g = n_c \\times n_d n_g = n_c \\times n_d function nreps \u00b6 inline int nreps () const Returns the total number of planned replications. function setNR \u00b6 inline void setNR ( int n_reps ) Sets the number of replications. function nobs \u00b6 inline const arma :: Row < int > & nobs () const Returns the original number of observations per group. function randomize \u00b6 void randomize () Randomizes the internal parameters of the Experiment , if necessary. This randomizes all those parameters of the ExperimentSetup that are defined by a distribution Public Attributes Documentation \u00b6 variable tsp_conf \u00b6 json tsp_conf ; Test Strategy Parameters. variable dsp_conf \u00b6 json dsp_conf ; Data Strategy Parameters. variable esp_conf \u00b6 json esp_conf ; Effect Estimator Parameters. Friends \u00b6 friend ExperimentSetupBuilder \u00b6 friend class ExperimentSetupBuilder ( ExperimentSetupBuilder ); Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::ExperimentSetup"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#samexperimentsetup","text":"Module: Experiment Modules Declaration of ExperimentSetup class. More... #include <ExperimentSetup.h>","title":"sam::ExperimentSetup"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#public-functions","text":"Name void setObs (const json & config, size_t n_c, size_t n_d) void setObs ( Parameter < int > nobs, size_t n_c, size_t n_d) void setObs (const arma::Row< int > & nobs, size_t n_c, size_t n_d) ExperimentSetupBuilder create () ExperimentSetup () =default ExperimentSetup (json & config) Constructs and initializes the ExperimentSetup . int nc () const Returns the number of conditions. void setNC (int n_c) Sets the number of conditions. int nd () const Returns the number of dependent variables in each conditions. void setND (int n_d) Sets the number of dependent variables in each group. int ng () const Returns the total number of groups. int nreps () const Returns the total number of planned replications. void setNR (int n_reps) Sets the number of replications. const arma::Row< int > & nobs () const Returns the original number of observations per group. void randomize () Randomizes the internal parameters of the Experiment , if necessary.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#public-attributes","text":"Name json tsp_conf Test Strategy Parameters. json dsp_conf Data Strategy Parameters. json esp_conf Effect Estimator Parameters.","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#friends","text":"Name class ExperimentSetupBuilder","title":"Friends"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#detailed-description","text":"class sam :: ExperimentSetup ; Declaration of ExperimentSetup class. ExperimentSetup stores all the necessary parameters concerning the experiment design, e.g., number of conditions, number of dependent variables, etc. It also stores a copy of the data, test, and effect strategies' configurations.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-setobs","text":"inline void setObs ( const json & config , size_t n_c , size_t n_d )","title":"function setObs"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-setobs_1","text":"inline void setObs ( Parameter < int > nobs , size_t n_c , size_t n_d )","title":"function setObs"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-setobs_2","text":"inline void setObs ( const arma :: Row < int > & nobs , size_t n_c , size_t n_d )","title":"function setObs"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-create","text":"static ExperimentSetupBuilder create () Return : An instance of the builder. Create a new ExperimentSetup by invoking a ExperimentSetupBuilder .","title":"function create"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-experimentsetup","text":"ExperimentSetup () = default","title":"function ExperimentSetup"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-experimentsetup_1","text":"explicit ExperimentSetup ( json & config ) Constructs and initializes the ExperimentSetup . Parameters : config A JSON configuration object This set and calculates design parameters of the experiment. It also archives the definition of data, test, and effect strategies. These archives may later be retrieved by the Journal during the review process.","title":"function ExperimentSetup"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-nc","text":"inline int nc () const Returns the number of conditions.","title":"function nc"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-setnc","text":"inline void setNC ( int n_c ) Sets the number of conditions.","title":"function setNC"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-nd","text":"inline int nd () const Returns the number of dependent variables in each conditions.","title":"function nd"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-setnd","text":"inline void setND ( int n_d ) Sets the number of dependent variables in each group.","title":"function setND"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-ng","text":"inline int ng () const Returns the total number of groups. This is an internal parameters and it's mainly used to iterate over conditions and dependent variables. It's calculated as n_g = n_c \\times n_d n_g = n_c \\times n_d","title":"function ng"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-nreps","text":"inline int nreps () const Returns the total number of planned replications.","title":"function nreps"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-setnr","text":"inline void setNR ( int n_reps ) Sets the number of replications.","title":"function setNR"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-nobs","text":"inline const arma :: Row < int > & nobs () const Returns the original number of observations per group.","title":"function nobs"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#function-randomize","text":"void randomize () Randomizes the internal parameters of the Experiment , if necessary. This randomizes all those parameters of the ExperimentSetup that are defined by a distribution","title":"function randomize"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#variable-tsp_conf","text":"json tsp_conf ; Test Strategy Parameters.","title":"variable tsp_conf"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#variable-dsp_conf","text":"json dsp_conf ; Data Strategy Parameters.","title":"variable dsp_conf"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#variable-esp_conf","text":"json esp_conf ; Effect Estimator Parameters.","title":"variable esp_conf"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup/#friend-experimentsetupbuilder","text":"friend class ExperimentSetupBuilder ( ExperimentSetupBuilder ); Updated on 29 June 2021 at 16:13:47 CEST","title":"friend ExperimentSetupBuilder"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/","text":"sam::ExperimentSetupBuilder \u00b6 Module: Abstract Factory Builders Public Functions \u00b6 Name ExperimentSetupBuilder () =default ExperimentSetupBuilder & fromConfigFile (json & config) Create and configure a new experiment setup based on the given configuration. ExperimentSetupBuilder & setSeed (const int s) Sets the seed for randomizing setup parameters. ExperimentSetupBuilder & setNumConditions (const int nc) ExperimentSetupBuilder & setNumDependentVariables (const int nd) ExperimentSetupBuilder & setNumItems (const int ni) ExperimentSetupBuilder & setNumObservations (const int nobs) ExperimentSetupBuilder & setNumObservations (const arma::Row< int > & nobs) ExperimentSetupBuilder & setTestStrategyParameters (json & test_strategy_config) ExperimentSetupBuilder & setDataStrategyParameters (json & data_strategy_config) ExperimentSetupBuilder & setEffectStrategyParameters (json & effect_strategy_config) ExperimentSetup build () Public Functions Documentation \u00b6 function ExperimentSetupBuilder \u00b6 ExperimentSetupBuilder () = default function fromConfigFile \u00b6 ExperimentSetupBuilder & fromConfigFile ( json & config ) Create and configure a new experiment setup based on the given configuration. function setSeed \u00b6 inline ExperimentSetupBuilder & setSeed ( const int s ) Sets the seed for randomizing setup parameters. Parameters : s seed Return : A reference to the builder function setNumConditions \u00b6 inline ExperimentSetupBuilder & setNumConditions ( const int nc ) function setNumDependentVariables \u00b6 inline ExperimentSetupBuilder & setNumDependentVariables ( const int nd ) function setNumItems \u00b6 inline ExperimentSetupBuilder & setNumItems ( const int ni ) function setNumObservations \u00b6 inline ExperimentSetupBuilder & setNumObservations ( const int nobs ) function setNumObservations \u00b6 inline ExperimentSetupBuilder & setNumObservations ( const arma :: Row < int > & nobs ) Todo: Recover this, it's been removed during the Parameter transition function setTestStrategyParameters \u00b6 inline ExperimentSetupBuilder & setTestStrategyParameters ( json & test_strategy_config ) function setDataStrategyParameters \u00b6 inline ExperimentSetupBuilder & setDataStrategyParameters ( json & data_strategy_config ) function setEffectStrategyParameters \u00b6 inline ExperimentSetupBuilder & setEffectStrategyParameters ( json & effect_strategy_config ) function build \u00b6 inline ExperimentSetup build () Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::ExperimentSetupBuilder"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#samexperimentsetupbuilder","text":"Module: Abstract Factory Builders","title":"sam::ExperimentSetupBuilder"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#public-functions","text":"Name ExperimentSetupBuilder () =default ExperimentSetupBuilder & fromConfigFile (json & config) Create and configure a new experiment setup based on the given configuration. ExperimentSetupBuilder & setSeed (const int s) Sets the seed for randomizing setup parameters. ExperimentSetupBuilder & setNumConditions (const int nc) ExperimentSetupBuilder & setNumDependentVariables (const int nd) ExperimentSetupBuilder & setNumItems (const int ni) ExperimentSetupBuilder & setNumObservations (const int nobs) ExperimentSetupBuilder & setNumObservations (const arma::Row< int > & nobs) ExperimentSetupBuilder & setTestStrategyParameters (json & test_strategy_config) ExperimentSetupBuilder & setDataStrategyParameters (json & data_strategy_config) ExperimentSetupBuilder & setEffectStrategyParameters (json & effect_strategy_config) ExperimentSetup build ()","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-experimentsetupbuilder","text":"ExperimentSetupBuilder () = default","title":"function ExperimentSetupBuilder"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-fromconfigfile","text":"ExperimentSetupBuilder & fromConfigFile ( json & config ) Create and configure a new experiment setup based on the given configuration.","title":"function fromConfigFile"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setseed","text":"inline ExperimentSetupBuilder & setSeed ( const int s ) Sets the seed for randomizing setup parameters. Parameters : s seed Return : A reference to the builder","title":"function setSeed"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setnumconditions","text":"inline ExperimentSetupBuilder & setNumConditions ( const int nc )","title":"function setNumConditions"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setnumdependentvariables","text":"inline ExperimentSetupBuilder & setNumDependentVariables ( const int nd )","title":"function setNumDependentVariables"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setnumitems","text":"inline ExperimentSetupBuilder & setNumItems ( const int ni )","title":"function setNumItems"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setnumobservations","text":"inline ExperimentSetupBuilder & setNumObservations ( const int nobs )","title":"function setNumObservations"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setnumobservations_1","text":"inline ExperimentSetupBuilder & setNumObservations ( const arma :: Row < int > & nobs ) Todo: Recover this, it's been removed during the Parameter transition","title":"function setNumObservations"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setteststrategyparameters","text":"inline ExperimentSetupBuilder & setTestStrategyParameters ( json & test_strategy_config )","title":"function setTestStrategyParameters"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-setdatastrategyparameters","text":"inline ExperimentSetupBuilder & setDataStrategyParameters ( json & data_strategy_config )","title":"function setDataStrategyParameters"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-seteffectstrategyparameters","text":"inline ExperimentSetupBuilder & setEffectStrategyParameters ( json & effect_strategy_config )","title":"function setEffectStrategyParameters"},{"location":"doxygen/Classes/classsam_1_1_experiment_setup_builder/#function-build","text":"inline ExperimentSetup build () Updated on 29 June 2021 at 16:13:48 CEST","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_f_test/","text":"sam::FTest \u00b6 Module: Test Strategies Inherits from sam::TestStrategy Public Classes \u00b6 Name struct Parameters struct ResultType Public Functions \u00b6 Name FTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType f_test (float Sd1, unsigned Sn1, float Sd2, unsigned Sn2, float alpha) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_ Public Functions Documentation \u00b6 function FTest \u00b6 inline FTest ( const Parameters & p ) function run \u00b6 virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run function run \u00b6 inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run function f_test \u00b6 static ResultType f_test ( float Sd1 , unsigned Sn1 , float Sd2 , unsigned Sn2 , float alpha ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::FTest"},{"location":"doxygen/Classes/classsam_1_1_f_test/#samftest","text":"Module: Test Strategies Inherits from sam::TestStrategy","title":"sam::FTest"},{"location":"doxygen/Classes/classsam_1_1_f_test/#public-classes","text":"Name struct Parameters struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_f_test/#public-functions","text":"Name FTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType f_test (float Sd1, unsigned Sn1, float Sd2, unsigned Sn2, float alpha)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_f_test/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_f_test/#additional-inherited-members","text":"Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_f_test/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_f_test/#function-ftest","text":"inline FTest ( const Parameters & p )","title":"function FTest"},{"location":"doxygen/Classes/classsam_1_1_f_test/#function-run","text":"virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_f_test/#function-run_1","text":"inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_f_test/#function-f_test","text":"static ResultType f_test ( float Sd1 , unsigned Sn1 , float Sd2 , unsigned Sn2 , float alpha )","title":"function f_test"},{"location":"doxygen/Classes/classsam_1_1_f_test/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_f_test/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/","text":"sam::FabricatingData \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name FabricatingData () =default FabricatingData (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment . Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: FabricatingData ; Fabricating Data Hacking Strategy Public Functions Documentation \u00b6 function FabricatingData \u00b6 FabricatingData () = default function FabricatingData \u00b6 inline explicit FabricatingData ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::FabricatingData"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#samfabricatingdata","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::FabricatingData"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#public-functions","text":"Name FabricatingData () =default FabricatingData (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#detailed-description","text":"class sam :: FabricatingData ; Fabricating Data Hacking Strategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#function-fabricatingdata","text":"FabricatingData () = default","title":"function FabricatingData"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#function-fabricatingdata_1","text":"inline explicit FabricatingData ( const Parameters & p )","title":"function FabricatingData"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_fabricating_data/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/","text":"sam::FalsifyingData \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name FalsifyingData () =default FalsifyingData (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment . Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: FalsifyingData ; Falsifying Data Hacking Strategy Public Functions Documentation \u00b6 function FalsifyingData \u00b6 FalsifyingData () = default function FalsifyingData \u00b6 inline explicit FalsifyingData ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::FalsifyingData"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#samfalsifyingdata","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::FalsifyingData"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#public-functions","text":"Name FalsifyingData () =default FalsifyingData (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#detailed-description","text":"class sam :: FalsifyingData ; Falsifying Data Hacking Strategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#function-falsifyingdata","text":"FalsifyingData () = default","title":"function FalsifyingData"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#function-falsifyingdata_1","text":"inline explicit FalsifyingData ( const Parameters & p )","title":"function FalsifyingData"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_falsifying_data/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/","text":"sam::FixedEffectEstimator \u00b6 Module: Meta Analysis Methods Fixed Effect Estimator. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis Public Classes \u00b6 Name struct ResultType Public Functions \u00b6 Name FixedEffectEstimator () =default virtual void estimate ( Journal * journal) ResultType FixedEffect (const arma::Row< float > & yi, const arma::Row< float > & vi) Additional inherited members \u00b6 Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Public Functions Documentation \u00b6 function FixedEffectEstimator \u00b6 FixedEffectEstimator () = default function estimate \u00b6 virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate function FixedEffect \u00b6 static inline ResultType FixedEffect ( const arma :: Row < float > & yi , const arma :: Row < float > & vi ) Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::FixedEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#samfixedeffectestimator","text":"Module: Meta Analysis Methods Fixed Effect Estimator. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis","title":"sam::FixedEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#public-classes","text":"Name struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#public-functions","text":"Name FixedEffectEstimator () =default virtual void estimate ( Journal * journal) ResultType FixedEffect (const arma::Row< float > & yi, const arma::Row< float > & vi)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#additional-inherited-members","text":"Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#function-fixedeffectestimator","text":"FixedEffectEstimator () = default","title":"function FixedEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#function-estimate","text":"virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_fixed_effect_estimator/#function-fixedeffect","text":"static inline ResultType FixedEffect ( const arma :: Row < float > & yi , const arma :: Row < float > & vi ) Updated on 29 June 2021 at 16:13:47 CEST","title":"function FixedEffect"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/","text":"sam::FrankenbachStrategy \u00b6 Inherits from sam::HackingProbabilityStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name FrankenbachStrategy () =default FrankenbachStrategy ( Parameters & p) virtual float estimate ( Experiment * experiment) override Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::HackingProbabilityStrategy Name virtual ~HackingProbabilityStrategy () =0 operator float () std::unique_ptr< HackingProbabilityStrategy > build (json & config) Public Attributes inherited from sam::HackingProbabilityStrategy Name float prob arma::Row< float > probabilities Public Functions Documentation \u00b6 function FrankenbachStrategy \u00b6 FrankenbachStrategy () = default function FrankenbachStrategy \u00b6 inline FrankenbachStrategy ( Parameters & p ) function estimate \u00b6 virtual float estimate ( Experiment * experiment ) override Reimplements : sam::HackingProbabilityStrategy::estimate We have something in the middle now, so, we are calculating based on the p-value we check for significance, if sig, then we return 0. else, then we assign a value I have a feeling this is a very inefficient implementation If the hacking probability is 1, then everything in this range is going to be hacked, a.k.a, hp = 1; Update: I think I had this wrong previously, where I assign the probability to everything, while it should only be assigned to those studies that are passing the effect test in the first place TodoRemember that you should consider some option here. At the moment, I'm returning the maximum of all probabilities, but that's not necessarily the best things to do, also, it works just fine in Frankenbach simulation because they have only one one outcome anyway Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::FrankenbachStrategy"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#samfrankenbachstrategy","text":"Inherits from sam::HackingProbabilityStrategy","title":"sam::FrankenbachStrategy"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#public-functions","text":"Name FrankenbachStrategy () =default FrankenbachStrategy ( Parameters & p) virtual float estimate ( Experiment * experiment) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#additional-inherited-members","text":"Public Functions inherited from sam::HackingProbabilityStrategy Name virtual ~HackingProbabilityStrategy () =0 operator float () std::unique_ptr< HackingProbabilityStrategy > build (json & config) Public Attributes inherited from sam::HackingProbabilityStrategy Name float prob arma::Row< float > probabilities","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#function-frankenbachstrategy","text":"FrankenbachStrategy () = default","title":"function FrankenbachStrategy"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#function-frankenbachstrategy_1","text":"inline FrankenbachStrategy ( Parameters & p )","title":"function FrankenbachStrategy"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#function-estimate","text":"virtual float estimate ( Experiment * experiment ) override Reimplements : sam::HackingProbabilityStrategy::estimate We have something in the middle now, so, we are calculating based on the p-value we check for significance, if sig, then we return 0. else, then we assign a value I have a feeling this is a very inefficient implementation If the hacking probability is 1, then everything in this range is going to be hacked, a.k.a, hp = 1; Update: I think I had this wrong previously, where I assign the probability to everything, while it should only be assigned to those studies that are passing the effect test in the first place TodoRemember that you should consider some option here. At the moment, I'm returning the maximum of all probabilities, but that's not necessarily the best things to do, also, it works just fine in Frankenbach simulation because they have only one one outcome anyway","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_frankenbach_strategy/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:46 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_free_selection/","text":"sam::FreeSelection \u00b6 Module: Review Strategies FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted. #include <ReviewStrategy.h> Inherits from ReviewStrategy Public Classes \u00b6 Name struct Parameters Parameters of free selection. Public Functions \u00b6 Name FreeSelection () =default bool review (const std::vector< Submission > & s) override It accepts everything. bool review (const Experiment & expr) override It accepts everything. Public Attributes \u00b6 Name Parameters params Public Functions Documentation \u00b6 function FreeSelection \u00b6 FreeSelection () = default function review \u00b6 inline bool review ( const std :: vector < Submission > & s ) override It accepts everything. function review \u00b6 inline bool review ( const Experiment & expr ) override It accepts everything. Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::FreeSelection"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#samfreeselection","text":"Module: Review Strategies FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted. #include <ReviewStrategy.h> Inherits from ReviewStrategy","title":"sam::FreeSelection"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#public-classes","text":"Name struct Parameters Parameters of free selection.","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#public-functions","text":"Name FreeSelection () =default bool review (const std::vector< Submission > & s) override It accepts everything. bool review (const Experiment & expr) override It accepts everything.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#function-freeselection","text":"FreeSelection () = default","title":"function FreeSelection"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#function-review","text":"inline bool review ( const std :: vector < Submission > & s ) override It accepts everything.","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#function-review_1","text":"inline bool review ( const Experiment & expr ) override It accepts everything.","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_free_selection/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/","text":"sam::GRMDataStrategy \u00b6 Module: Data Strategies Simulate data based on General Graded Response Model. More... #include <DataStrategy.h> Inherits from sam::DataStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name GRMDataStrategy () =default GRMDataStrategy (const Parameters & p) virtual void genData ( Experiment * experiment) override Generates data based on the selected DataModel. virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) override Generates n_new_obs new observations for each group. Additional inherited members \u00b6 Public Types inherited from sam::DataStrategy Name enum DataModel Public Functions inherited from sam::DataStrategy Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class. Detailed Description \u00b6 class sam :: GRMDataStrategy ; Simulate data based on General Graded Response Model. Note : : DVs in GRM are distinguished by their participant abilities to answer tests. Therefore, we'll have ng_ number of abilities . This value is being used to, in each group, to initialize a normal distribution of \\theta ~ N(abilities[i], 1) . \u03b2 Public Functions Documentation \u00b6 function GRMDataStrategy \u00b6 GRMDataStrategy () = default function GRMDataStrategy \u00b6 GRMDataStrategy ( const Parameters & p ) Some initialization function genData \u00b6 virtual void genData ( Experiment * experiment ) override Generates data based on the selected DataModel. Parameters : experiment A pointer to an Experiment object Reimplements : sam::DataStrategy::genData Populates the experiment->groups_->measurements with data based on the parameters specified in setup . function genNewObservationsForAllGroups \u00b6 virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) override Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplements : sam::DataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::GRMDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#samgrmdatastrategy","text":"Module: Data Strategies Simulate data based on General Graded Response Model. More... #include <DataStrategy.h> Inherits from sam::DataStrategy","title":"sam::GRMDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#public-functions","text":"Name GRMDataStrategy () =default GRMDataStrategy (const Parameters & p) virtual void genData ( Experiment * experiment) override Generates data based on the selected DataModel. virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) override Generates n_new_obs new observations for each group.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#additional-inherited-members","text":"Public Types inherited from sam::DataStrategy Name enum DataModel Public Functions inherited from sam::DataStrategy Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class.","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#detailed-description","text":"class sam :: GRMDataStrategy ; Simulate data based on General Graded Response Model. Note : : DVs in GRM are distinguished by their participant abilities to answer tests. Therefore, we'll have ng_ number of abilities . This value is being used to, in each group, to initialize a normal distribution of \\theta ~ N(abilities[i], 1) . \u03b2","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#function-grmdatastrategy","text":"GRMDataStrategy () = default","title":"function GRMDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#function-grmdatastrategy_1","text":"GRMDataStrategy ( const Parameters & p ) Some initialization","title":"function GRMDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#function-gendata","text":"virtual void genData ( Experiment * experiment ) override Generates data based on the selected DataModel. Parameters : experiment A pointer to an Experiment object Reimplements : sam::DataStrategy::genData Populates the experiment->groups_->measurements with data based on the parameters specified in setup .","title":"function genData"},{"location":"doxygen/Classes/classsam_1_1_g_r_m_data_strategy/#function-gennewobservationsforallgroups","text":"virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) override Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplements : sam::DataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"function genNewObservationsForAllGroups"},{"location":"doxygen/Classes/classsam_1_1_group/","text":"sam::Group \u00b6 Declartiong of Group class. More... #include <Group.h> Public Functions \u00b6 Name std::vector< std::string > Columns () Group () Group (int id_, GroupType type_) Group (arma::Row< double > & data) arma::Row< double > & measurements () Getter / Setter. const arma::Row< double > & measurements () const void set_measurements (const arma::Row< double > meas) void add_measurements (const arma::Row< double > new_meas) void del_measurements (const arma::uvec & idxs) auto begin () auto end () operator arma::Row< double > () void updateStats () void testAgaist (const Group & other_group, TestStrategy & test_strategy) void effectComparedTo (const Group & other_group, EffectStrategy & effect_strategy) void clear () Public Attributes \u00b6 Name int id_ GroupType gtype std::optional< double > true_nobs_ std::optional< double > true_mean_ std::optional< double > true_std_ int nobs_ \u2014 Descriptive statistics double mean_ double var_ double stddev_ double sei_ bool is_stats_up_to_date double stats_ double pvalue_ double effect_ double var_effect_ double se_effect_ int eff_side_ bool sig_ bool is_test_updated_ bool is_hacked_ \u2014 Hacking Meta std::vector< HackingMethod > hacking_history_ int n_added_obs int n_removed_obs Friends \u00b6 Name OStream & operator<< (OStream & os, const Group & data) Detailed Description \u00b6 class sam :: Group ; Declartiong of Group class. The Group class is an abstract representation of a dependant variable Public Functions Documentation \u00b6 function Columns \u00b6 static std :: vector < std :: string > Columns () function Group \u00b6 inline Group () function Group \u00b6 inline Group ( int id_ , GroupType type_ ) function Group \u00b6 inline Group ( arma :: Row < double > & data ) function measurements \u00b6 inline arma :: Row < double > & measurements () Getter / Setter. function measurements \u00b6 inline const arma :: Row < double > & measurements () const function set_measurements \u00b6 inline void set_measurements ( const arma :: Row < double > meas ) function add_measurements \u00b6 inline void add_measurements ( const arma :: Row < double > new_meas ) function del_measurements \u00b6 inline void del_measurements ( const arma :: uvec & idxs ) function begin \u00b6 inline auto begin () function end \u00b6 inline auto end () function operator arma::Row< double > \u00b6 operator arma :: Row < double > () function updateStats \u00b6 void updateStats () TodoBring this back, I'm removing this because group is not being notified with some of the changes, and this leads to SAM not updating the statistics, i.e., the type of changes that Falsifying Data will cause function testAgaist \u00b6 void testAgaist ( const Group & other_group , TestStrategy & test_strategy ) function effectComparedTo \u00b6 void effectComparedTo ( const Group & other_group , EffectStrategy & effect_strategy ) function clear \u00b6 void clear () Public Attributes Documentation \u00b6 variable id_ \u00b6 int id_ ; variable gtype \u00b6 GroupType gtype ; variable true_nobs_ \u00b6 std :: optional < double > true_nobs_ { 0 }; \u2014 Distribution/Population Parameters These can be their own type, and determined by the DataStrategies variable true_mean_ \u00b6 std :: optional < double > true_mean_ { 0 }; variable true_std_ \u00b6 std :: optional < double > true_std_ { 0 }; variable nobs_ \u00b6 int nobs_ { 0 }; \u2014 Descriptive statistics variable mean_ \u00b6 double mean_ { 0 }; variable var_ \u00b6 double var_ { 0 }; variable stddev_ \u00b6 double stddev_ { 0 }; variable sei_ \u00b6 double sei_ { 0 }; variable is_stats_up_to_date \u00b6 bool is_stats_up_to_date { false }; variable stats_ \u00b6 double stats_ { 0 }; \u2014 Test statistics ... These can be their own type, and determined by the TestStrategies variable pvalue_ \u00b6 double pvalue_ { 0 }; variable effect_ \u00b6 double effect_ { 0 }; variable var_effect_ \u00b6 double var_effect_ { 0 }; variable se_effect_ \u00b6 double se_effect_ { 0 }; variable eff_side_ \u00b6 int eff_side_ { 0 }; variable sig_ \u00b6 bool sig_ { false }; variable is_test_updated_ \u00b6 bool is_test_updated_ { false }; variable is_hacked_ \u00b6 bool is_hacked_ { false }; \u2014 Hacking Meta variable hacking_history_ \u00b6 std :: vector < HackingMethod > hacking_history_ ; variable n_added_obs \u00b6 int n_added_obs { 0 }; variable n_removed_obs \u00b6 int n_removed_obs { 0 }; Friends \u00b6 friend operator<< \u00b6 friend OStream & operator << ( OStream & os , const Group & data );","title":"sam::Group"},{"location":"doxygen/Classes/classsam_1_1_group/#samgroup","text":"Declartiong of Group class. More... #include <Group.h>","title":"sam::Group"},{"location":"doxygen/Classes/classsam_1_1_group/#public-functions","text":"Name std::vector< std::string > Columns () Group () Group (int id_, GroupType type_) Group (arma::Row< double > & data) arma::Row< double > & measurements () Getter / Setter. const arma::Row< double > & measurements () const void set_measurements (const arma::Row< double > meas) void add_measurements (const arma::Row< double > new_meas) void del_measurements (const arma::uvec & idxs) auto begin () auto end () operator arma::Row< double > () void updateStats () void testAgaist (const Group & other_group, TestStrategy & test_strategy) void effectComparedTo (const Group & other_group, EffectStrategy & effect_strategy) void clear ()","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_group/#public-attributes","text":"Name int id_ GroupType gtype std::optional< double > true_nobs_ std::optional< double > true_mean_ std::optional< double > true_std_ int nobs_ \u2014 Descriptive statistics double mean_ double var_ double stddev_ double sei_ bool is_stats_up_to_date double stats_ double pvalue_ double effect_ double var_effect_ double se_effect_ int eff_side_ bool sig_ bool is_test_updated_ bool is_hacked_ \u2014 Hacking Meta std::vector< HackingMethod > hacking_history_ int n_added_obs int n_removed_obs","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_group/#friends","text":"Name OStream & operator<< (OStream & os, const Group & data)","title":"Friends"},{"location":"doxygen/Classes/classsam_1_1_group/#detailed-description","text":"class sam :: Group ; Declartiong of Group class. The Group class is an abstract representation of a dependant variable","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_group/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_group/#function-columns","text":"static std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/classsam_1_1_group/#function-group","text":"inline Group ()","title":"function Group"},{"location":"doxygen/Classes/classsam_1_1_group/#function-group_1","text":"inline Group ( int id_ , GroupType type_ )","title":"function Group"},{"location":"doxygen/Classes/classsam_1_1_group/#function-group_2","text":"inline Group ( arma :: Row < double > & data )","title":"function Group"},{"location":"doxygen/Classes/classsam_1_1_group/#function-measurements","text":"inline arma :: Row < double > & measurements () Getter / Setter.","title":"function measurements"},{"location":"doxygen/Classes/classsam_1_1_group/#function-measurements_1","text":"inline const arma :: Row < double > & measurements () const","title":"function measurements"},{"location":"doxygen/Classes/classsam_1_1_group/#function-set_measurements","text":"inline void set_measurements ( const arma :: Row < double > meas )","title":"function set_measurements"},{"location":"doxygen/Classes/classsam_1_1_group/#function-add_measurements","text":"inline void add_measurements ( const arma :: Row < double > new_meas )","title":"function add_measurements"},{"location":"doxygen/Classes/classsam_1_1_group/#function-del_measurements","text":"inline void del_measurements ( const arma :: uvec & idxs )","title":"function del_measurements"},{"location":"doxygen/Classes/classsam_1_1_group/#function-begin","text":"inline auto begin ()","title":"function begin"},{"location":"doxygen/Classes/classsam_1_1_group/#function-end","text":"inline auto end ()","title":"function end"},{"location":"doxygen/Classes/classsam_1_1_group/#function-operator-armarow-double","text":"operator arma :: Row < double > ()","title":"function operator arma::Row&lt; double &gt;"},{"location":"doxygen/Classes/classsam_1_1_group/#function-updatestats","text":"void updateStats () TodoBring this back, I'm removing this because group is not being notified with some of the changes, and this leads to SAM not updating the statistics, i.e., the type of changes that Falsifying Data will cause","title":"function updateStats"},{"location":"doxygen/Classes/classsam_1_1_group/#function-testagaist","text":"void testAgaist ( const Group & other_group , TestStrategy & test_strategy )","title":"function testAgaist"},{"location":"doxygen/Classes/classsam_1_1_group/#function-effectcomparedto","text":"void effectComparedTo ( const Group & other_group , EffectStrategy & effect_strategy )","title":"function effectComparedTo"},{"location":"doxygen/Classes/classsam_1_1_group/#function-clear","text":"void clear ()","title":"function clear"},{"location":"doxygen/Classes/classsam_1_1_group/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-id_","text":"int id_ ;","title":"variable id_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-gtype","text":"GroupType gtype ;","title":"variable gtype"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-true_nobs_","text":"std :: optional < double > true_nobs_ { 0 }; \u2014 Distribution/Population Parameters These can be their own type, and determined by the DataStrategies","title":"variable true_nobs_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-true_mean_","text":"std :: optional < double > true_mean_ { 0 };","title":"variable true_mean_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-true_std_","text":"std :: optional < double > true_std_ { 0 };","title":"variable true_std_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-nobs_","text":"int nobs_ { 0 }; \u2014 Descriptive statistics","title":"variable nobs_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-mean_","text":"double mean_ { 0 };","title":"variable mean_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-var_","text":"double var_ { 0 };","title":"variable var_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-stddev_","text":"double stddev_ { 0 };","title":"variable stddev_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-sei_","text":"double sei_ { 0 };","title":"variable sei_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-is_stats_up_to_date","text":"bool is_stats_up_to_date { false };","title":"variable is_stats_up_to_date"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-stats_","text":"double stats_ { 0 }; \u2014 Test statistics ... These can be their own type, and determined by the TestStrategies","title":"variable stats_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-pvalue_","text":"double pvalue_ { 0 };","title":"variable pvalue_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-effect_","text":"double effect_ { 0 };","title":"variable effect_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-var_effect_","text":"double var_effect_ { 0 };","title":"variable var_effect_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-se_effect_","text":"double se_effect_ { 0 };","title":"variable se_effect_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-eff_side_","text":"int eff_side_ { 0 };","title":"variable eff_side_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-sig_","text":"bool sig_ { false };","title":"variable sig_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-is_test_updated_","text":"bool is_test_updated_ { false };","title":"variable is_test_updated_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-is_hacked_","text":"bool is_hacked_ { false }; \u2014 Hacking Meta","title":"variable is_hacked_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-hacking_history_","text":"std :: vector < HackingMethod > hacking_history_ ;","title":"variable hacking_history_"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-n_added_obs","text":"int n_added_obs { 0 };","title":"variable n_added_obs"},{"location":"doxygen/Classes/classsam_1_1_group/#variable-n_removed_obs","text":"int n_removed_obs { 0 };","title":"variable n_removed_obs"},{"location":"doxygen/Classes/classsam_1_1_group/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/classsam_1_1_group/#friend-operator","text":"friend OStream & operator << ( OStream & os , const Group & data );","title":"friend operator&lt;&lt;"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/","text":"sam::GroupPooling \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name GroupPooling () =default GroupPooling (const Parameters & p) virtual void perform ( Experiment * experiment) override Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: GroupPooling ; Declaration of GroupPooling hacking strategy Public Functions Documentation \u00b6 function GroupPooling \u00b6 GroupPooling () = default function GroupPooling \u00b6 inline explicit GroupPooling ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Parameters : experiment A pointer to researcher's experiment researchStrategy A pointer to researcher's research strategy Reimplements : sam::HackingStrategy::perform Perform Group Pooling on the given Experiment . Todothis can be replaced by addNewDependentVariable adding a new group TodoThis can be replaced by addNewCondition Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::GroupPooling"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#samgrouppooling","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::GroupPooling"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#public-functions","text":"Name GroupPooling () =default GroupPooling (const Parameters & p) virtual void perform ( Experiment * experiment) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#detailed-description","text":"class sam :: GroupPooling ; Declaration of GroupPooling hacking strategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#function-grouppooling","text":"GroupPooling () = default","title":"function GroupPooling"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#function-grouppooling_1","text":"inline explicit GroupPooling ( const Parameters & p )","title":"function GroupPooling"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Parameters : experiment A pointer to researcher's experiment researchStrategy A pointer to researcher's research strategy Reimplements : sam::HackingStrategy::perform Perform Group Pooling on the given Experiment . Todothis can be replaced by addNewDependentVariable adding a new group TodoThis can be replaced by addNewCondition","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_group_pooling/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/","text":"sam::HackingProbabilityStrategy \u00b6 Inherited by sam::FrankenbachStrategy Public Functions \u00b6 Name virtual ~HackingProbabilityStrategy () =0 virtual float estimate ( Experiment * experiment) =0 operator float () std::unique_ptr< HackingProbabilityStrategy > build (json & config) Public Attributes \u00b6 Name float prob arma::Row< float > probabilities Public Functions Documentation \u00b6 function ~HackingProbabilityStrategy \u00b6 virtual ~ HackingProbabilityStrategy () = 0 function estimate \u00b6 virtual float estimate ( Experiment * experiment ) = 0 Reimplemented by : sam::FrankenbachStrategy::estimate function operator float \u00b6 inline operator float () function build \u00b6 static std :: unique_ptr < HackingProbabilityStrategy > build ( json & config ) Public Attributes Documentation \u00b6 variable prob \u00b6 float prob ; variable probabilities \u00b6 arma :: Row < float > probabilities ; Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::HackingProbabilityStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#samhackingprobabilitystrategy","text":"Inherited by sam::FrankenbachStrategy","title":"sam::HackingProbabilityStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#public-functions","text":"Name virtual ~HackingProbabilityStrategy () =0 virtual float estimate ( Experiment * experiment) =0 operator float () std::unique_ptr< HackingProbabilityStrategy > build (json & config)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#public-attributes","text":"Name float prob arma::Row< float > probabilities","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#function-hackingprobabilitystrategy","text":"virtual ~ HackingProbabilityStrategy () = 0","title":"function ~HackingProbabilityStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#function-estimate","text":"virtual float estimate ( Experiment * experiment ) = 0 Reimplemented by : sam::FrankenbachStrategy::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#function-operator-float","text":"inline operator float ()","title":"function operator float"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#function-build","text":"static std :: unique_ptr < HackingProbabilityStrategy > build ( json & config )","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#variable-prob","text":"float prob ;","title":"variable prob"},{"location":"doxygen/Classes/classsam_1_1_hacking_probability_strategy/#variable-probabilities","text":"arma :: Row < float > probabilities ; Updated on 29 June 2021 at 16:13:46 CEST","title":"variable probabilities"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/","text":"sam::HackingStrategy \u00b6 Module: Hacking Strategies Abstract Class of Hacking Strategies. More... #include <HackingStrategy.h> Inherited by sam::ConditionDropping , sam::FabricatingData , sam::FalsifyingData , sam::GroupPooling , sam::OptionalDropping , sam::OptionalStopping , sam::OutliersRemoval , sam::PeekingOutliersRemoval , sam::QuestionableRounding , sam::StoppingDataCollection , sam::SubjectiveOutlierRemoval Public Functions \u00b6 Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes \u00b6 Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: HackingStrategy ; Abstract Class of Hacking Strategies. Each HackingStrategy should provide a perform() method. The perform() method will take over a pointer to an Experiment and apply the implemented hacking on it. Researcher decides if this is a pointer to a fresh copy of the Experiment or a pointer to a previously \"hacked\" Experiment . Public Functions Documentation \u00b6 function ~HackingStrategy \u00b6 virtual ~ HackingStrategy () = 0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. function HackingStrategy \u00b6 HackingStrategy () function operator() \u00b6 inline void operator ()( Experiment * experiment ) function defensibility \u00b6 inline float defensibility () const function prevalence \u00b6 inline float prevalence () const function stage \u00b6 inline HackingStage stage () const function target \u00b6 inline HackingTarget target () const function build \u00b6 static std :: unique_ptr < HackingStrategy > build ( json & hacking_strategy_config ) Factory method for building a HackingStrategy . Parameters : config A reference to an item of the \"json[\u2013hacking-strategy']`. Researcher::Builder is responsible for passing this object correctly. config A JSON object defining a hacking strategy, and its parameters Return : A new HackingStrategy Pointer to a HackingStrategy A Factory method for building hacking strategies Public Attributes Documentation \u00b6 variable lua \u00b6 sol :: state lua ; variable defensibility_ \u00b6 std :: optional < float > defensibility_ ; variable prevalence_ \u00b6 std :: optional < float > prevalence_ ; variable stage_ \u00b6 HackingStage stage_ ; variable target_ \u00b6 HackingTarget target_ ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::HackingStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#samhackingstrategy","text":"Module: Hacking Strategies Abstract Class of Hacking Strategies. More... #include <HackingStrategy.h> Inherited by sam::ConditionDropping , sam::FabricatingData , sam::FalsifyingData , sam::GroupPooling , sam::OptionalDropping , sam::OptionalStopping , sam::OutliersRemoval , sam::PeekingOutliersRemoval , sam::QuestionableRounding , sam::StoppingDataCollection , sam::SubjectiveOutlierRemoval","title":"sam::HackingStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#public-functions","text":"Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#public-attributes","text":"Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#detailed-description","text":"class sam :: HackingStrategy ; Abstract Class of Hacking Strategies. Each HackingStrategy should provide a perform() method. The perform() method will take over a pointer to an Experiment and apply the implemented hacking on it. Researcher decides if this is a pointer to a fresh copy of the Experiment or a pointer to a previously \"hacked\" Experiment .","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-hackingstrategy","text":"virtual ~ HackingStrategy () = 0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes.","title":"function ~HackingStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-hackingstrategy_1","text":"HackingStrategy ()","title":"function HackingStrategy"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-operator","text":"inline void operator ()( Experiment * experiment )","title":"function operator()"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-defensibility","text":"inline float defensibility () const","title":"function defensibility"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-prevalence","text":"inline float prevalence () const","title":"function prevalence"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-stage","text":"inline HackingStage stage () const","title":"function stage"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-target","text":"inline HackingTarget target () const","title":"function target"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#function-build","text":"static std :: unique_ptr < HackingStrategy > build ( json & hacking_strategy_config ) Factory method for building a HackingStrategy . Parameters : config A reference to an item of the \"json[\u2013hacking-strategy']`. Researcher::Builder is responsible for passing this object correctly. config A JSON object defining a hacking strategy, and its parameters Return : A new HackingStrategy Pointer to a HackingStrategy A Factory method for building hacking strategies","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#variable-lua","text":"sol :: state lua ;","title":"variable lua"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#variable-defensibility_","text":"std :: optional < float > defensibility_ ;","title":"variable defensibility_"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#variable-prevalence_","text":"std :: optional < float > prevalence_ ;","title":"variable prevalence_"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#variable-stage_","text":"HackingStage stage_ ;","title":"variable stage_"},{"location":"doxygen/Classes/classsam_1_1_hacking_strategy/#variable-target_","text":"HackingTarget target_ ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable target_"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/","text":"sam::HedgesG \u00b6 Module: Effect Strategies Inherits from sam::EffectStrategy Public Functions \u00b6 Name HedgesG () =default virtual void computeEffects ( Experiment * experiment) override Additional inherited members \u00b6 Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0 Public Functions Documentation \u00b6 function HedgesG \u00b6 explicit HedgesG () = default function computeEffects \u00b6 virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Skipping Treatment groups Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::HedgesG"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/#samhedgesg","text":"Module: Effect Strategies Inherits from sam::EffectStrategy","title":"sam::HedgesG"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/#public-functions","text":"Name HedgesG () =default virtual void computeEffects ( Experiment * experiment) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/#additional-inherited-members","text":"Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/#function-hedgesg","text":"explicit HedgesG () = default","title":"function HedgesG"},{"location":"doxygen/Classes/classsam_1_1_hedges_g/#function-computeeffects","text":"virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Skipping Treatment groups Updated on 29 June 2021 at 16:13:47 CEST","title":"function computeEffects"},{"location":"doxygen/Classes/classsam_1_1_journal/","text":"sam::Journal \u00b6 Journal Class. More... #include <Journal.h> Public Functions \u00b6 Name Journal () =default ~Journal () =default Journal (json & journal_config) Constructs a Journal from a JSON object. bool review (std::vector< Submission > & s) Review the Submission . void accept (const std::vector< Submission > & s) Accepts the Submission . void reject (const std::vector< Submission > & s) Rejects the Submission . bool isStillAccepting () const Indicates whether the Journal is still accepting outcomes or not. size_t nStudies () const Returns the number of studies. size_t nSubmissions () const Returns the number of publications. size_t nRejected () const Returns the number of rejected publications. void saveMetaAnalysis () Saves MetaAnalysis Results. void saveSummaries () Saves Overall Summaries. void storeMetaAnalysisResult (const MetaAnalysisOutcome & res) Stores the MetaAnalysisOutcome. void savePublicationsPerSimSummaries () Saves the Per Simulation summary of Publications. void clear () Clear the Journal . void reset () Completely resets the Journal . void prepareForMetaAnalysis () Prepares the Journal for running meta-analysis. void runMetaAnalysis () Runs the meta-analysis methods. void updateMetaStatsRunners () Updates the overall stats runners. std::vector< std::string > Columns () Returns Journal 's CSV header. Public Attributes \u00b6 Name std::vector< Submission > publications_list List of all accepted submissions, i.e., outcomes. std::vector< Submission > rejection_list Rejected Submissions. arma::Row< float > yi arma::Row< float > vi The variance of the accepted submissions. arma::Row< float > wi The weight of the accepted submissions, computed as 1./vi;. std::unique_ptr< ReviewStrategy > review_strategy Journal 's Selection Model/Strategy. Detailed Description \u00b6 class sam :: Journal ; Journal Class. The Journal class mimics the behavior of a Journal . It deals with new publications as they are being submitted for review. It is equipped with a review strategy which is used to make a decision over the destiny of the newly submitted manuscript, ie., being accepted or rejected. Additionally, it handles the meta-analysis calculation and reporting of those at the end of the simulation. Public Functions Documentation \u00b6 function Journal \u00b6 Journal () = default function ~Journal \u00b6 ~ Journal () = default function Journal \u00b6 explicit Journal ( json & journal_config ) Constructs a Journal from a JSON object. Parameters : journal_config The journal configuration This makes sure that everything in the Journal are set up correctly: Instantiates the Review Strategy Prepares the output files, and their column names Prepares the stat runners based on users preference Removing the higher level information because I don't want them to be written to the config file again. function review \u00b6 bool review ( std :: vector < Submission > & s ) Review the Submission . Parameters : subs A list of submissions Return : Returns true if the submission is accepted, otherwise it returns false. Sends the submission to the review strategy, and based on its verdict it either accept() or reject() the submission. function accept \u00b6 void accept ( const std :: vector < Submission > & s ) Accepts the Submission . Parameters : subs A list of submissions Adds the accepted submission to the list of publications, and updates some of the necessary internals of the Journal to be able to keep track of the number of publications, studies, etc. function reject \u00b6 void reject ( const std :: vector < Submission > & s ) Rejects the Submission . Parameters : subs A list of submissions Adds the rejected submissions to the list of rejected submissions, and keeps the internal of the Journal up-to-date. function isStillAccepting \u00b6 inline bool isStillAccepting () const Indicates whether the Journal is still accepting outcomes or not. function nStudies \u00b6 inline size_t nStudies () const Returns the number of studies. function nSubmissions \u00b6 inline size_t nSubmissions () const Returns the number of publications. function nRejected \u00b6 inline size_t nRejected () const Returns the number of rejected publications. function saveMetaAnalysis \u00b6 void saveMetaAnalysis () Saves MetaAnalysis Results. Saves the meta analytics results. function saveSummaries \u00b6 void saveSummaries () Saves Overall Summaries. Saves the publications and meta stats runners. function storeMetaAnalysisResult \u00b6 void storeMetaAnalysisResult ( const MetaAnalysisOutcome & res ) Stores the MetaAnalysisOutcome. Adds the given meta analysis outcome to the list of collected meta-analysis. function savePublicationsPerSimSummaries \u00b6 void savePublicationsPerSimSummaries () Saves the Per Simulation summary of Publications. Saving the runner statistics of each batch of publications in Journal . Resetting the runner statistics function clear \u00b6 void clear () Clear the Journal . Clears the history of publications, rejections, and runner statistics... function reset \u00b6 void reset () Completely resets the Journal . In addition to clearing the Journal , it resets some of the overall stats runners that are not usually being cleared by clear() function prepareForMetaAnalysis \u00b6 void prepareForMetaAnalysis () Prepares the Journal for running meta-analysis. This prepares the Journal for running meta-analysis. I mainly designed this to introduce some caching that I don't have to compute everything every time. So, with this, Journal prepares the vi , yi , and wi once and pass them to the meta analysis methods. function runMetaAnalysis \u00b6 void runMetaAnalysis () Runs the meta-analysis methods. Loops through the meta-analysis methods and run them, and update their stats runners function updateMetaStatsRunners \u00b6 void updateMetaStatsRunners () Updates the overall stats runners. Updates the overall meta stats runners. function Columns \u00b6 static std :: vector < std :: string > Columns () Returns Journal 's CSV header. Public Attributes Documentation \u00b6 variable publications_list \u00b6 std :: vector < Submission > publications_list ; List of all accepted submissions, i.e., outcomes. variable rejection_list \u00b6 std :: vector < Submission > rejection_list ; Rejected Submissions. variable yi \u00b6 arma :: Row < float > yi ; Caching variables The effect sizes of the accepted submissions. variable vi \u00b6 arma :: Row < float > vi ; The variance of the accepted submissions. variable wi \u00b6 arma :: Row < float > wi ; The weight of the accepted submissions, computed as 1./vi;. variable review_strategy \u00b6 std :: unique_ptr < ReviewStrategy > review_strategy ; Journal 's Selection Model/Strategy. Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::Journal"},{"location":"doxygen/Classes/classsam_1_1_journal/#samjournal","text":"Journal Class. More... #include <Journal.h>","title":"sam::Journal"},{"location":"doxygen/Classes/classsam_1_1_journal/#public-functions","text":"Name Journal () =default ~Journal () =default Journal (json & journal_config) Constructs a Journal from a JSON object. bool review (std::vector< Submission > & s) Review the Submission . void accept (const std::vector< Submission > & s) Accepts the Submission . void reject (const std::vector< Submission > & s) Rejects the Submission . bool isStillAccepting () const Indicates whether the Journal is still accepting outcomes or not. size_t nStudies () const Returns the number of studies. size_t nSubmissions () const Returns the number of publications. size_t nRejected () const Returns the number of rejected publications. void saveMetaAnalysis () Saves MetaAnalysis Results. void saveSummaries () Saves Overall Summaries. void storeMetaAnalysisResult (const MetaAnalysisOutcome & res) Stores the MetaAnalysisOutcome. void savePublicationsPerSimSummaries () Saves the Per Simulation summary of Publications. void clear () Clear the Journal . void reset () Completely resets the Journal . void prepareForMetaAnalysis () Prepares the Journal for running meta-analysis. void runMetaAnalysis () Runs the meta-analysis methods. void updateMetaStatsRunners () Updates the overall stats runners. std::vector< std::string > Columns () Returns Journal 's CSV header.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_journal/#public-attributes","text":"Name std::vector< Submission > publications_list List of all accepted submissions, i.e., outcomes. std::vector< Submission > rejection_list Rejected Submissions. arma::Row< float > yi arma::Row< float > vi The variance of the accepted submissions. arma::Row< float > wi The weight of the accepted submissions, computed as 1./vi;. std::unique_ptr< ReviewStrategy > review_strategy Journal 's Selection Model/Strategy.","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_journal/#detailed-description","text":"class sam :: Journal ; Journal Class. The Journal class mimics the behavior of a Journal . It deals with new publications as they are being submitted for review. It is equipped with a review strategy which is used to make a decision over the destiny of the newly submitted manuscript, ie., being accepted or rejected. Additionally, it handles the meta-analysis calculation and reporting of those at the end of the simulation.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_journal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-journal","text":"Journal () = default","title":"function Journal"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-journal_1","text":"~ Journal () = default","title":"function ~Journal"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-journal_2","text":"explicit Journal ( json & journal_config ) Constructs a Journal from a JSON object. Parameters : journal_config The journal configuration This makes sure that everything in the Journal are set up correctly: Instantiates the Review Strategy Prepares the output files, and their column names Prepares the stat runners based on users preference Removing the higher level information because I don't want them to be written to the config file again.","title":"function Journal"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-review","text":"bool review ( std :: vector < Submission > & s ) Review the Submission . Parameters : subs A list of submissions Return : Returns true if the submission is accepted, otherwise it returns false. Sends the submission to the review strategy, and based on its verdict it either accept() or reject() the submission.","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-accept","text":"void accept ( const std :: vector < Submission > & s ) Accepts the Submission . Parameters : subs A list of submissions Adds the accepted submission to the list of publications, and updates some of the necessary internals of the Journal to be able to keep track of the number of publications, studies, etc.","title":"function accept"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-reject","text":"void reject ( const std :: vector < Submission > & s ) Rejects the Submission . Parameters : subs A list of submissions Adds the rejected submissions to the list of rejected submissions, and keeps the internal of the Journal up-to-date.","title":"function reject"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-isstillaccepting","text":"inline bool isStillAccepting () const Indicates whether the Journal is still accepting outcomes or not.","title":"function isStillAccepting"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-nstudies","text":"inline size_t nStudies () const Returns the number of studies.","title":"function nStudies"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-nsubmissions","text":"inline size_t nSubmissions () const Returns the number of publications.","title":"function nSubmissions"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-nrejected","text":"inline size_t nRejected () const Returns the number of rejected publications.","title":"function nRejected"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-savemetaanalysis","text":"void saveMetaAnalysis () Saves MetaAnalysis Results. Saves the meta analytics results.","title":"function saveMetaAnalysis"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-savesummaries","text":"void saveSummaries () Saves Overall Summaries. Saves the publications and meta stats runners.","title":"function saveSummaries"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-storemetaanalysisresult","text":"void storeMetaAnalysisResult ( const MetaAnalysisOutcome & res ) Stores the MetaAnalysisOutcome. Adds the given meta analysis outcome to the list of collected meta-analysis.","title":"function storeMetaAnalysisResult"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-savepublicationspersimsummaries","text":"void savePublicationsPerSimSummaries () Saves the Per Simulation summary of Publications. Saving the runner statistics of each batch of publications in Journal . Resetting the runner statistics","title":"function savePublicationsPerSimSummaries"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-clear","text":"void clear () Clear the Journal . Clears the history of publications, rejections, and runner statistics...","title":"function clear"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-reset","text":"void reset () Completely resets the Journal . In addition to clearing the Journal , it resets some of the overall stats runners that are not usually being cleared by clear()","title":"function reset"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-prepareformetaanalysis","text":"void prepareForMetaAnalysis () Prepares the Journal for running meta-analysis. This prepares the Journal for running meta-analysis. I mainly designed this to introduce some caching that I don't have to compute everything every time. So, with this, Journal prepares the vi , yi , and wi once and pass them to the meta analysis methods.","title":"function prepareForMetaAnalysis"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-runmetaanalysis","text":"void runMetaAnalysis () Runs the meta-analysis methods. Loops through the meta-analysis methods and run them, and update their stats runners","title":"function runMetaAnalysis"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-updatemetastatsrunners","text":"void updateMetaStatsRunners () Updates the overall stats runners. Updates the overall meta stats runners.","title":"function updateMetaStatsRunners"},{"location":"doxygen/Classes/classsam_1_1_journal/#function-columns","text":"static std :: vector < std :: string > Columns () Returns Journal 's CSV header.","title":"function Columns"},{"location":"doxygen/Classes/classsam_1_1_journal/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_journal/#variable-publications_list","text":"std :: vector < Submission > publications_list ; List of all accepted submissions, i.e., outcomes.","title":"variable publications_list"},{"location":"doxygen/Classes/classsam_1_1_journal/#variable-rejection_list","text":"std :: vector < Submission > rejection_list ; Rejected Submissions.","title":"variable rejection_list"},{"location":"doxygen/Classes/classsam_1_1_journal/#variable-yi","text":"arma :: Row < float > yi ; Caching variables The effect sizes of the accepted submissions.","title":"variable yi"},{"location":"doxygen/Classes/classsam_1_1_journal/#variable-vi","text":"arma :: Row < float > vi ; The variance of the accepted submissions.","title":"variable vi"},{"location":"doxygen/Classes/classsam_1_1_journal/#variable-wi","text":"arma :: Row < float > wi ; The weight of the accepted submissions, computed as 1./vi;.","title":"variable wi"},{"location":"doxygen/Classes/classsam_1_1_journal/#variable-review_strategy","text":"std :: unique_ptr < ReviewStrategy > review_strategy ; Journal 's Selection Model/Strategy. Updated on 29 June 2021 at 16:13:46 CEST","title":"variable review_strategy"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/","text":"sam::LatentDataStrategy \u00b6 Module: Data Strategies \u26a0\ufe0f TO BE IMPLEMENTED! More... #include <DataStrategy.h> Inherits from sam::DataStrategy Public Functions \u00b6 Name LatentDataStrategy () =default virtual void genData ( Experiment * experiment) override virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) override Generates n_new_obs new observations for each group. Additional inherited members \u00b6 Public Types inherited from sam::DataStrategy Name enum DataModel Public Functions inherited from sam::DataStrategy Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class. Detailed Description \u00b6 class sam :: LatentDataStrategy ; \u26a0\ufe0f TO BE IMPLEMENTED! Note : LatentDataStrategy will generate individual items, therefore it might be slower than other models. Warning : To be implemented! A Data Strategy for constructing a general Structural Equation Model . Public Functions Documentation \u00b6 function LatentDataStrategy \u00b6 LatentDataStrategy () = default function genData \u00b6 virtual void genData ( Experiment * experiment ) override Reimplements : sam::DataStrategy::genData Construct a structural equation model based on the given parameters specified in the ExperimentSetup . Beside experiment->measurements , LatentDataStrategy populates the experiment->items as well. dvSigma->data = flatten(experiment->setup.getTrueValueOf(\"sigm\")).data(); this->mainRngStream->mvnorm_n(allErrorMeans, allErrorsSigma, allErrors); gsl_vector_set(itemMeans, r, gsl_stats_mean(tmpRow->data, 1, nobs)); function genNewObservationsForAllGroups \u00b6 virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) override Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplements : sam::DataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::LatentDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#samlatentdatastrategy","text":"Module: Data Strategies \u26a0\ufe0f TO BE IMPLEMENTED! More... #include <DataStrategy.h> Inherits from sam::DataStrategy","title":"sam::LatentDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#public-functions","text":"Name LatentDataStrategy () =default virtual void genData ( Experiment * experiment) override virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) override Generates n_new_obs new observations for each group.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#additional-inherited-members","text":"Public Types inherited from sam::DataStrategy Name enum DataModel Public Functions inherited from sam::DataStrategy Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class.","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#detailed-description","text":"class sam :: LatentDataStrategy ; \u26a0\ufe0f TO BE IMPLEMENTED! Note : LatentDataStrategy will generate individual items, therefore it might be slower than other models. Warning : To be implemented! A Data Strategy for constructing a general Structural Equation Model .","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#function-latentdatastrategy","text":"LatentDataStrategy () = default","title":"function LatentDataStrategy"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#function-gendata","text":"virtual void genData ( Experiment * experiment ) override Reimplements : sam::DataStrategy::genData Construct a structural equation model based on the given parameters specified in the ExperimentSetup . Beside experiment->measurements , LatentDataStrategy populates the experiment->items as well. dvSigma->data = flatten(experiment->setup.getTrueValueOf(\"sigm\")).data(); this->mainRngStream->mvnorm_n(allErrorMeans, allErrorsSigma, allErrors); gsl_vector_set(itemMeans, r, gsl_stats_mean(tmpRow->data, 1, nobs));","title":"function genData"},{"location":"doxygen/Classes/classsam_1_1_latent_data_strategy/#function-gennewobservationsforallgroups","text":"virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) override Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplements : sam::DataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"function genNewObservationsForAllGroups"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/","text":"sam::LinearModelStrategy \u00b6 Module: Data Strategies Linear Model Data Strategy. #include <DataStrategy.h> Inherits from sam::DataStrategy Public Classes \u00b6 Name struct Parameters Parameters of LinearModelStrategy . Public Functions \u00b6 Name LinearModelStrategy () =default LinearModelStrategy (const Parameters p) virtual void genData ( Experiment * experiment) override Generates data based on the selected DataModel. virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) override Generates n_new_obs new observations for each group. Additional inherited members \u00b6 Public Types inherited from sam::DataStrategy Name enum DataModel Public Functions inherited from sam::DataStrategy Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class. Public Functions Documentation \u00b6 function LinearModelStrategy \u00b6 LinearModelStrategy () = default function LinearModelStrategy \u00b6 inline explicit LinearModelStrategy ( const Parameters p ) function genData \u00b6 virtual void genData ( Experiment * experiment ) override Generates data based on the selected DataModel. Parameters : experiment A pointer to an Experiment object Reimplements : sam::DataStrategy::genData Populates the experiment->groups_->measurements with data based on the parameters specified in setup . Generates the samples Generate the error terms if specified This is ugly but it should work function genNewObservationsForAllGroups \u00b6 virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) override Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplements : sam::DataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::LinearModelStrategy"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#samlinearmodelstrategy","text":"Module: Data Strategies Linear Model Data Strategy. #include <DataStrategy.h> Inherits from sam::DataStrategy","title":"sam::LinearModelStrategy"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#public-classes","text":"Name struct Parameters Parameters of LinearModelStrategy .","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#public-functions","text":"Name LinearModelStrategy () =default LinearModelStrategy (const Parameters p) virtual void genData ( Experiment * experiment) override Generates data based on the selected DataModel. virtual std::vector< arma::Row< float > > genNewObservationsForAllGroups ( Experiment * experiment, int n_new_obs) override Generates n_new_obs new observations for each group.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#additional-inherited-members","text":"Public Types inherited from sam::DataStrategy Name enum DataModel Public Functions inherited from sam::DataStrategy Name std::unique_ptr< DataStrategy > build (json & data_strategy_config) DataStrategy Factory Method. virtual ~DataStrategy () =0 Pure destructors of the DataStrategy abstract class.","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#function-linearmodelstrategy","text":"LinearModelStrategy () = default","title":"function LinearModelStrategy"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#function-linearmodelstrategy_1","text":"inline explicit LinearModelStrategy ( const Parameters p )","title":"function LinearModelStrategy"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#function-gendata","text":"virtual void genData ( Experiment * experiment ) override Generates data based on the selected DataModel. Parameters : experiment A pointer to an Experiment object Reimplements : sam::DataStrategy::genData Populates the experiment->groups_->measurements with data based on the parameters specified in setup . Generates the samples Generate the error terms if specified This is ugly but it should work","title":"function genData"},{"location":"doxygen/Classes/classsam_1_1_linear_model_strategy/#function-gennewobservationsforallgroups","text":"virtual std :: vector < arma :: Row < float > > genNewObservationsForAllGroups ( Experiment * experiment , int n_new_obs ) override Generates n_new_obs new observations for each group. Parameters : experiment The pointer to the current experiment n_new_obs The number of new observations to be generated Return : An array of new observations Reimplements : sam::DataStrategy::genNewObservationsForAllGroups Updated on 29 June 2021 at 16:13:47 CEST","title":"function genNewObservationsForAllGroups"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/","text":"sam::MeanDifference \u00b6 Module: Effect Strategies Inherits from sam::EffectStrategy Public Functions \u00b6 Name MeanDifference () =default virtual void computeEffects ( Experiment * experiment) override Additional inherited members \u00b6 Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0 Public Functions Documentation \u00b6 function MeanDifference \u00b6 explicit MeanDifference () = default function computeEffects \u00b6 virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::MeanDifference"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/#sammeandifference","text":"Module: Effect Strategies Inherits from sam::EffectStrategy","title":"sam::MeanDifference"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/#public-functions","text":"Name MeanDifference () =default virtual void computeEffects ( Experiment * experiment) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/#additional-inherited-members","text":"Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/#function-meandifference","text":"explicit MeanDifference () = default","title":"function MeanDifference"},{"location":"doxygen/Classes/classsam_1_1_mean_difference/#function-computeeffects","text":"virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Updated on 29 June 2021 at 16:13:47 CEST","title":"function computeEffects"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/","text":"sam::MetaAnalysis \u00b6 Inherited by sam::EggersTestEstimator , sam::FixedEffectEstimator , sam::RandomEffectEstimator , sam::RankCorrelation , sam::TestOfObsOverExptSig , sam::TrimAndFill Public Functions \u00b6 Name virtual ~MetaAnalysis () =0 virtual void estimate ( Journal * journal) =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Public Functions Documentation \u00b6 function ~MetaAnalysis \u00b6 virtual ~ MetaAnalysis () = 0 function estimate \u00b6 virtual void estimate ( Journal * journal ) = 0 Reimplemented by : sam::RandomEffectEstimator::estimate , sam::FixedEffectEstimator::estimate , sam::EggersTestEstimator::estimate , sam::TestOfObsOverExptSig::estimate , sam::TrimAndFill::estimate , sam::RankCorrelation::estimate function build \u00b6 static std :: unique_ptr < MetaAnalysis > build ( std :: string name ) function build \u00b6 static std :: unique_ptr < MetaAnalysis > build ( const json & config ) function Columns \u00b6 static std :: vector < std :: string > Columns ( std :: string name ) Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::MetaAnalysis"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#sammetaanalysis","text":"Inherited by sam::EggersTestEstimator , sam::FixedEffectEstimator , sam::RandomEffectEstimator , sam::RankCorrelation , sam::TestOfObsOverExptSig , sam::TrimAndFill","title":"sam::MetaAnalysis"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#public-functions","text":"Name virtual ~MetaAnalysis () =0 virtual void estimate ( Journal * journal) =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#function-metaanalysis","text":"virtual ~ MetaAnalysis () = 0","title":"function ~MetaAnalysis"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#function-estimate","text":"virtual void estimate ( Journal * journal ) = 0 Reimplemented by : sam::RandomEffectEstimator::estimate , sam::FixedEffectEstimator::estimate , sam::EggersTestEstimator::estimate , sam::TestOfObsOverExptSig::estimate , sam::TrimAndFill::estimate , sam::RankCorrelation::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#function-build","text":"static std :: unique_ptr < MetaAnalysis > build ( std :: string name )","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#function-build_1","text":"static std :: unique_ptr < MetaAnalysis > build ( const json & config )","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_meta_analysis/#function-columns","text":"static std :: vector < std :: string > Columns ( std :: string name ) Updated on 29 June 2021 at 16:13:46 CEST","title":"function Columns"},{"location":"doxygen/Classes/classsam_1_1_no_hack/","text":"sam::NoHack \u00b6 Inherits from sam::HackingStrategy Public Functions \u00b6 Name NoHack () Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure deconstuctor of the Base calss. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) double defensibility () const double prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . std::unique_ptr< HackingStrategy > build (HackingMethod method) Public Attributes inherited from sam::HackingStrategy Name sol::state lua double defensibility_ double prevalence_ HackingStage stage_ HackingTarget target_ Public Functions Documentation \u00b6 function NoHack \u00b6 inline NoHack ()","title":"sam::NoHack"},{"location":"doxygen/Classes/classsam_1_1_no_hack/#samnohack","text":"Inherits from sam::HackingStrategy","title":"sam::NoHack"},{"location":"doxygen/Classes/classsam_1_1_no_hack/#public-functions","text":"Name NoHack ()","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_no_hack/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure deconstuctor of the Base calss. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) double defensibility () const double prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . std::unique_ptr< HackingStrategy > build (HackingMethod method) Public Attributes inherited from sam::HackingStrategy Name sol::state lua double defensibility_ double prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_no_hack/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_no_hack/#function-nohack","text":"inline NoHack ()","title":"function NoHack"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/","text":"sam::OptionalDropping \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name OptionalDropping () =default OptionalDropping (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment . Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: OptionalDropping ; Optional Dropping Hacking Strategy The Optional Dropping algorithm uses the covariant values to split the dataset, and generates new condition groups. Public Functions Documentation \u00b6 function OptionalDropping \u00b6 OptionalDropping () = default function OptionalDropping \u00b6 inline explicit OptionalDropping ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::OptionalDropping"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#samoptionaldropping","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::OptionalDropping"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#public-functions","text":"Name OptionalDropping () =default OptionalDropping (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#detailed-description","text":"class sam :: OptionalDropping ; Optional Dropping Hacking Strategy The Optional Dropping algorithm uses the covariant values to split the dataset, and generates new condition groups.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#function-optionaldropping","text":"OptionalDropping () = default","title":"function OptionalDropping"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#function-optionaldropping_1","text":"inline explicit OptionalDropping ( const Parameters & p )","title":"function OptionalDropping"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_optional_dropping/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/","text":"sam::OptionalStopping \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name OptionalStopping () =default OptionalStopping (const Parameters & p) void addObservations ( Experiment * experiment, const arma::Row< int > & ns) Adds new observations to each group. Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: OptionalStopping ; Declaration of OptionalStopping hacking strategy Public Functions Documentation \u00b6 function OptionalStopping \u00b6 OptionalStopping () = default function OptionalStopping \u00b6 inline explicit OptionalStopping ( const Parameters & p ) function addObservations \u00b6 void addObservations ( Experiment * experiment , const arma :: Row < int > & ns ) Adds new observations to each group. Parameters : experiment The pointer to the Experiment ns Indicates the number of new observations to be added to each group. Adds new observations to every group. Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::OptionalStopping"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#samoptionalstopping","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::OptionalStopping"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#public-functions","text":"Name OptionalStopping () =default OptionalStopping (const Parameters & p) void addObservations ( Experiment * experiment, const arma::Row< int > & ns) Adds new observations to each group.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#detailed-description","text":"class sam :: OptionalStopping ; Declaration of OptionalStopping hacking strategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#function-optionalstopping","text":"OptionalStopping () = default","title":"function OptionalStopping"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#function-optionalstopping_1","text":"inline explicit OptionalStopping ( const Parameters & p )","title":"function OptionalStopping"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#function-addobservations","text":"void addObservations ( Experiment * experiment , const arma :: Row < int > & ns ) Adds new observations to each group. Parameters : experiment The pointer to the Experiment ns Indicates the number of new observations to be added to each group. Adds new observations to every group.","title":"function addObservations"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_optional_stopping/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/","text":"sam::OutliersRemoval \u00b6 Module: Hacking Strategies Declaration of Outlier Removal hacking method based on items' distance from their sample mean. #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name OutliersRemoval () =default OutliersRemoval (const Parameters & p) virtual void perform ( Experiment * experiment) override Implementation of Outliers Removal based on an item's distance from the \\mu. Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Public Functions Documentation \u00b6 function OutliersRemoval \u00b6 OutliersRemoval () = default function OutliersRemoval \u00b6 inline explicit OutliersRemoval ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Implementation of Outliers Removal based on an item's distance from the \\mu. Reimplements : sam::HackingStrategy::perform Removing outliers n at a time, for the total of n_attempts It'll stop either when n_attempts are exhausted, or there is no more observations left to be removed Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::OutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#samoutliersremoval","text":"Module: Hacking Strategies Declaration of Outlier Removal hacking method based on items' distance from their sample mean. #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::OutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#public-functions","text":"Name OutliersRemoval () =default OutliersRemoval (const Parameters & p) virtual void perform ( Experiment * experiment) override Implementation of Outliers Removal based on an item's distance from the \\mu.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#function-outliersremoval","text":"OutliersRemoval () = default","title":"function OutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#function-outliersremoval_1","text":"inline explicit OutliersRemoval ( const Parameters & p )","title":"function OutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Implementation of Outliers Removal based on an item's distance from the \\mu. Reimplements : sam::HackingStrategy::perform Removing outliers n at a time, for the total of n_attempts It'll stop either when n_attempts are exhausted, or there is no more observations left to be removed","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_outliers_removal/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_parameter/","text":"sam::Parameter \u00b6 An abstract representation of a random variable parameter. More... #include <Parameter.h> Inherits from arma::Row< T > Public Functions \u00b6 Name Parameter () Parameter (const arma::Row< T > & X) Parameter (std::initializer_list< T > l) Parameter (const json & j, size_t size) Constructs a parameter based on the given JSON object. operator T () Returns the first element of the array. Parameter < T > & operator() () Randomizes and returns the save Parameter . bool isDist () Returns true if a distribution is assigned to the Parameter . Detailed Description \u00b6 template < typename T > class sam :: Parameter ; An abstract representation of a random variable parameter. Template Parameters : T Type of the parameter Attention : Parameter is inherited from arma::Row . This is quite useful and essential because I can pass it around easily, and use all the overloaded operators of the arma::Row This is designed to account for those setting parameters that can be configured in either of the following ways: An array of size n , with similar values An array of size n , with different values An array of size n , with values drawn from a distribution. This is the case where Parameter can loosely resemble a random variable. Public Functions Documentation \u00b6 function Parameter \u00b6 inline Parameter () function Parameter \u00b6 inline explicit Parameter ( const arma :: Row < T > & X ) function Parameter \u00b6 inline Parameter ( std :: initializer_list < T > l ) function Parameter \u00b6 Parameter ( const json & j , size_t size ) Constructs a parameter based on the given JSON object. Parameters : j The configuration of the parameter size The size of the array Template Parameters : T The type of the Parameter , a.k.a, the type of armadillo vector This constructs and initializes the Parameter object based on the given JSON object. function operator T \u00b6 inline explicit operator T () Returns the first element of the array. Todo : Implement a copy constructor function operator() \u00b6 inline Parameter < T > & operator ()() Randomizes and returns the save Parameter . function isDist \u00b6 inline bool isDist () Returns true if a distribution is assigned to the Parameter . Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::Parameter"},{"location":"doxygen/Classes/classsam_1_1_parameter/#samparameter","text":"An abstract representation of a random variable parameter. More... #include <Parameter.h> Inherits from arma::Row< T >","title":"sam::Parameter"},{"location":"doxygen/Classes/classsam_1_1_parameter/#public-functions","text":"Name Parameter () Parameter (const arma::Row< T > & X) Parameter (std::initializer_list< T > l) Parameter (const json & j, size_t size) Constructs a parameter based on the given JSON object. operator T () Returns the first element of the array. Parameter < T > & operator() () Randomizes and returns the save Parameter . bool isDist () Returns true if a distribution is assigned to the Parameter .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_parameter/#detailed-description","text":"template < typename T > class sam :: Parameter ; An abstract representation of a random variable parameter. Template Parameters : T Type of the parameter Attention : Parameter is inherited from arma::Row . This is quite useful and essential because I can pass it around easily, and use all the overloaded operators of the arma::Row This is designed to account for those setting parameters that can be configured in either of the following ways: An array of size n , with similar values An array of size n , with different values An array of size n , with values drawn from a distribution. This is the case where Parameter can loosely resemble a random variable.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_parameter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-parameter","text":"inline Parameter ()","title":"function Parameter"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-parameter_1","text":"inline explicit Parameter ( const arma :: Row < T > & X )","title":"function Parameter"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-parameter_2","text":"inline Parameter ( std :: initializer_list < T > l )","title":"function Parameter"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-parameter_3","text":"Parameter ( const json & j , size_t size ) Constructs a parameter based on the given JSON object. Parameters : j The configuration of the parameter size The size of the array Template Parameters : T The type of the Parameter , a.k.a, the type of armadillo vector This constructs and initializes the Parameter object based on the given JSON object.","title":"function Parameter"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-operator-t","text":"inline explicit operator T () Returns the first element of the array. Todo : Implement a copy constructor","title":"function operator T"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-operator","text":"inline Parameter < T > & operator ()() Randomizes and returns the save Parameter .","title":"function operator()"},{"location":"doxygen/Classes/classsam_1_1_parameter/#function-isdist","text":"inline bool isDist () Returns true if a distribution is assigned to the Parameter . Updated on 29 June 2021 at 16:13:46 CEST","title":"function isDist"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/","text":"sam::PeekingOutliersRemoval \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name PeekingOutliersRemoval () =default PeekingOutliersRemoval (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment . Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition PolicyChain whether_to_save_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: PeekingOutliersRemoval ; PeekingOutliersRemoval Hacking Strategy Public Functions Documentation \u00b6 function PeekingOutliersRemoval \u00b6 PeekingOutliersRemoval () = default function PeekingOutliersRemoval \u00b6 inline explicit PeekingOutliersRemoval ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Removing outliers n at a time, for the total of n_attempts It'll stop either when n_attempts are exhausted, or there is no more observations left to be removed Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; variable whether_to_save_condition \u00b6 PolicyChain whether_to_save_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::PeekingOutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#sampeekingoutliersremoval","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::PeekingOutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#public-functions","text":"Name PeekingOutliersRemoval () =default PeekingOutliersRemoval (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition PolicyChain whether_to_save_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#detailed-description","text":"class sam :: PeekingOutliersRemoval ; PeekingOutliersRemoval Hacking Strategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#function-peekingoutliersremoval","text":"PeekingOutliersRemoval () = default","title":"function PeekingOutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#function-peekingoutliersremoval_1","text":"inline explicit PeekingOutliersRemoval ( const Parameters & p )","title":"function PeekingOutliersRemoval"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Removing outliers n at a time, for the total of n_attempts It'll stop either when n_attempts are exhausted, or there is no more observations left to be removed","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#variable-stopping_condition","text":"PolicyChain stopping_condition ;","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_peeking_outliers_removal/#variable-whether_to_save_condition","text":"PolicyChain whether_to_save_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable whether_to_save_condition"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/","text":"sam::PersistenceManager \u00b6 More... #include <PersistenceManager.h> Public Classes \u00b6 Name class Reader class Writer Declaration of the Writer class. Public Functions \u00b6 Name ~PersistenceManager () =default Detailed Description \u00b6 class sam :: PersistenceManager ; Persistence Manager class, dealing with CSV Read/Write. This is designed such that I can hopefully replace the CSV with something more efficient later. Public Functions Documentation \u00b6 function ~PersistenceManager \u00b6 ~ PersistenceManager () = default Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::PersistenceManager"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/#sampersistencemanager","text":"More... #include <PersistenceManager.h>","title":"sam::PersistenceManager"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/#public-classes","text":"Name class Reader class Writer Declaration of the Writer class.","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/#public-functions","text":"Name ~PersistenceManager () =default","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/#detailed-description","text":"class sam :: PersistenceManager ; Persistence Manager class, dealing with CSV Read/Write. This is designed such that I can hopefully replace the CSV with something more efficient later.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager/#function-persistencemanager","text":"~ PersistenceManager () = default Updated on 29 June 2021 at 16:13:46 CEST","title":"function ~PersistenceManager"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/","text":"sam::PersistenceManager::Reader \u00b6 Public Functions \u00b6 Name Reader () =default ~Reader () Reader (const std::filesystem::path & filename) void filename (const std::filesystem::path & name) void read_raw_data ( Experiment * expr) Public Functions Documentation \u00b6 function Reader \u00b6 Reader () = default function ~Reader \u00b6 ~ Reader () function Reader \u00b6 Reader ( const std :: filesystem :: path & filename ) function filename \u00b6 inline void filename ( const std :: filesystem :: path & name ) function read_raw_data \u00b6 void read_raw_data ( Experiment * expr ) Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::PersistenceManager::Reader"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#sampersistencemanagerreader","text":"","title":"sam::PersistenceManager::Reader"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#public-functions","text":"Name Reader () =default ~Reader () Reader (const std::filesystem::path & filename) void filename (const std::filesystem::path & name) void read_raw_data ( Experiment * expr)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#function-reader","text":"Reader () = default","title":"function Reader"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#function-reader_1","text":"~ Reader ()","title":"function ~Reader"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#function-reader_2","text":"Reader ( const std :: filesystem :: path & filename )","title":"function Reader"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#function-filename","text":"inline void filename ( const std :: filesystem :: path & name )","title":"function filename"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_reader/#function-read_raw_data","text":"void read_raw_data ( Experiment * expr ) Updated on 29 June 2021 at 16:13:46 CEST","title":"function read_raw_data"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/","text":"sam::PersistenceManager::Writer \u00b6 Declaration of the Writer class. #include <PersistenceManager.h> Public Functions \u00b6 Name Writer () =default ~Writer () Writer (const std::filesystem::path & filename) Writer (const std::filesystem::path & path, const string & prefix, const std::filesystem::path filename) Writer (const std::filesystem::path & filename, const std::vector< std::string > colnames) void write (const std::vector< std::string > & row_entries) void write (const std::map< string, string > & row) void write (const Submission & sub) void write (std::vector< Submission > & subs, int sid =0) void write (std::vector< arma::Row< float >> & data, int sid =0) void write ( Experiment * experiment, string_view mode, int sid) void setColumnNames (const std::vector< std::string > & colnames) Public Functions Documentation \u00b6 function Writer \u00b6 Writer () = default function ~Writer \u00b6 ~ Writer () function Writer \u00b6 Writer ( const std :: filesystem :: path & filename ) function Writer \u00b6 Writer ( const std :: filesystem :: path & path , const string & prefix , const std :: filesystem :: path filename ) function Writer \u00b6 Writer ( const std :: filesystem :: path & filename , const std :: vector < std :: string > colnames ) function write \u00b6 void write ( const std :: vector < std :: string > & row_entries ) function write \u00b6 void write ( const std :: map < string , string > & row ) function write \u00b6 void write ( const Submission & sub ) function write \u00b6 void write ( std :: vector < Submission > & subs , int sid = 0 ) Parameters : subs A reference to Submission container Write a list of submission records to a file, or a database TodoThis looks strange, and it's also very inefficient! Optimize it! It's somewhat better than &&s, but not great yet! function write \u00b6 void write ( std :: vector < arma :: Row < float >> & data , int sid = 0 ) Parameters : data A reference to the Experiment->measurements Write each groups' data to a file, or a database function write \u00b6 void write ( Experiment * experiment , string_view mode , int sid ) Parameters : A constance reference to the Experiment Write part of the Experiment to a file, or a database function setColumnNames \u00b6 void setColumnNames ( const std :: vector < std :: string > & colnames ) Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::PersistenceManager::Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#sampersistencemanagerwriter","text":"Declaration of the Writer class. #include <PersistenceManager.h>","title":"sam::PersistenceManager::Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#public-functions","text":"Name Writer () =default ~Writer () Writer (const std::filesystem::path & filename) Writer (const std::filesystem::path & path, const string & prefix, const std::filesystem::path filename) Writer (const std::filesystem::path & filename, const std::vector< std::string > colnames) void write (const std::vector< std::string > & row_entries) void write (const std::map< string, string > & row) void write (const Submission & sub) void write (std::vector< Submission > & subs, int sid =0) void write (std::vector< arma::Row< float >> & data, int sid =0) void write ( Experiment * experiment, string_view mode, int sid) void setColumnNames (const std::vector< std::string > & colnames)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-writer","text":"Writer () = default","title":"function Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-writer_1","text":"~ Writer ()","title":"function ~Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-writer_2","text":"Writer ( const std :: filesystem :: path & filename )","title":"function Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-writer_3","text":"Writer ( const std :: filesystem :: path & path , const string & prefix , const std :: filesystem :: path filename )","title":"function Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-writer_4","text":"Writer ( const std :: filesystem :: path & filename , const std :: vector < std :: string > colnames )","title":"function Writer"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-write","text":"void write ( const std :: vector < std :: string > & row_entries )","title":"function write"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-write_1","text":"void write ( const std :: map < string , string > & row )","title":"function write"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-write_2","text":"void write ( const Submission & sub )","title":"function write"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-write_3","text":"void write ( std :: vector < Submission > & subs , int sid = 0 ) Parameters : subs A reference to Submission container Write a list of submission records to a file, or a database TodoThis looks strange, and it's also very inefficient! Optimize it! It's somewhat better than &&s, but not great yet!","title":"function write"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-write_4","text":"void write ( std :: vector < arma :: Row < float >> & data , int sid = 0 ) Parameters : data A reference to the Experiment->measurements Write each groups' data to a file, or a database","title":"function write"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-write_5","text":"void write ( Experiment * experiment , string_view mode , int sid ) Parameters : A constance reference to the Experiment Write part of the Experiment to a file, or a database","title":"function write"},{"location":"doxygen/Classes/classsam_1_1_persistence_manager_1_1_writer/#function-setcolumnnames","text":"void setColumnNames ( const std :: vector < std :: string > & colnames ) Updated on 29 June 2021 at 16:13:46 CEST","title":"function setColumnNames"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/","text":"sam::PolicyBasedSelection \u00b6 Module: Review Strategies Policy-based Selection Strategy. More... #include <ReviewStrategy.h> Inherits from ReviewStrategy Public Classes \u00b6 Name struct Parameters Parameters of the Policy-based Selection. Public Functions \u00b6 Name PolicyBasedSelection ( Parameters & p) bool review (const std::vector< Submission > & s) override bool review (const Experiment & expr) override Public Attributes \u00b6 Name Parameters params PolicyChain selection_policy Detailed Description \u00b6 class sam :: PolicyBasedSelection ; Policy-based Selection Strategy. Note : This is a very flexible method, and it can technically be used to setup wide variety of review strategies, including traditional publication biased journal. Policy-based review strategy accepts a submission if any of the submissions pass all the criteria specified by the `selection_policy_defs`. In addition to the output of selection policy, a submission might get rejected based on journal's acceptance rate, and publication bias rate. Public Functions Documentation \u00b6 function PolicyBasedSelection \u00b6 inline explicit PolicyBasedSelection ( Parameters & p ) function review \u00b6 bool review ( const std :: vector < Submission > & s ) override Reviews the list of submissions based on the user-defined policy Check whether at least one of the submissions passes all criteria of the selection_policy, if so, a random number decides whether the publication bias will affect the decision. If not, a random draw from U(0, 1) decides whether the acceptance rate affects the decision, and if not, submissions will be accepted. Checks selection policy returns anything TodoI don't really like the const_cast here, maybe I need to find a way to remove it! function review \u00b6 inline bool review ( const Experiment & expr ) override Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable selection_policy \u00b6 PolicyChain selection_policy ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::PolicyBasedSelection"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#sampolicybasedselection","text":"Module: Review Strategies Policy-based Selection Strategy. More... #include <ReviewStrategy.h> Inherits from ReviewStrategy","title":"sam::PolicyBasedSelection"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#public-classes","text":"Name struct Parameters Parameters of the Policy-based Selection.","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#public-functions","text":"Name PolicyBasedSelection ( Parameters & p) bool review (const std::vector< Submission > & s) override bool review (const Experiment & expr) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#public-attributes","text":"Name Parameters params PolicyChain selection_policy","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#detailed-description","text":"class sam :: PolicyBasedSelection ; Policy-based Selection Strategy. Note : This is a very flexible method, and it can technically be used to setup wide variety of review strategies, including traditional publication biased journal. Policy-based review strategy accepts a submission if any of the submissions pass all the criteria specified by the `selection_policy_defs`. In addition to the output of selection policy, a submission might get rejected based on journal's acceptance rate, and publication bias rate.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#function-policybasedselection","text":"inline explicit PolicyBasedSelection ( Parameters & p )","title":"function PolicyBasedSelection"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#function-review","text":"bool review ( const std :: vector < Submission > & s ) override Reviews the list of submissions based on the user-defined policy Check whether at least one of the submissions passes all criteria of the selection_policy, if so, a random number decides whether the publication bias will affect the decision. If not, a random draw from U(0, 1) decides whether the acceptance rate affects the decision, and if not, submissions will be accepted. Checks selection policy returns anything TodoI don't really like the const_cast here, maybe I need to find a way to remove it!","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#function-review_1","text":"inline bool review ( const Experiment & expr ) override","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_policy_based_selection/#variable-selection_policy","text":"PolicyChain selection_policy ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable selection_policy"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/","text":"sam::QuestionableRounding \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name QuestionableRounding () =default QuestionableRounding (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment . Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: QuestionableRounding ; QuestionableRounding Hacking Strategy Questionable rounding strategy mimics the behavior of a researcher who might hack its way to significance by aggressively rounding the pvalue and ignoring everything else. Public Functions Documentation \u00b6 function QuestionableRounding \u00b6 QuestionableRounding () = default function QuestionableRounding \u00b6 inline explicit QuestionableRounding ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Checking whether the outcome is significant, if not, we check whether it's close enough to be a hacked, if so, we either set the pvalue to alpha or the difference between pvalue and threshold Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::QuestionableRounding"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#samquestionablerounding","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::QuestionableRounding"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#public-functions","text":"Name QuestionableRounding () =default QuestionableRounding (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#detailed-description","text":"class sam :: QuestionableRounding ; QuestionableRounding Hacking Strategy Questionable rounding strategy mimics the behavior of a researcher who might hack its way to significance by aggressively rounding the pvalue and ignoring everything else.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#function-questionablerounding","text":"QuestionableRounding () = default","title":"function QuestionableRounding"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#function-questionablerounding_1","text":"inline explicit QuestionableRounding ( const Parameters & p )","title":"function QuestionableRounding"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform Checking whether the outcome is significant, if not, we check whether it's close enough to be a hacked, if so, we either set the pvalue to alpha or the difference between pvalue and threshold","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_questionable_rounding/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/","text":"sam::RandomEffectEstimator \u00b6 Module: Meta Analysis Methods Random Effect Estimator. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis Public Classes \u00b6 Name struct Parameters Parameters of the RandomEffectEstimator . struct ResultType Public Functions \u00b6 Name RandomEffectEstimator () =default RandomEffectEstimator (const Parameters & p) virtual void estimate ( Journal * journal) float DL (const arma::Row< float > & yi, const arma::Row< float > & vi, const arma::Row< float > & ai) float PM (const arma::Row< float > & yi, const arma::Row< float > & vi, const float tau2) ResultType RandomEffect (const arma::Row< float > & vi, const arma::Row< float > & yi, float tau2) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Public Functions Documentation \u00b6 function RandomEffectEstimator \u00b6 RandomEffectEstimator () = default function RandomEffectEstimator \u00b6 inline RandomEffectEstimator ( const Parameters & p ) function estimate \u00b6 virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate function DL \u00b6 float DL ( const arma :: Row < float > & yi , const arma :: Row < float > & vi , const arma :: Row < float > & ai ) function PM \u00b6 float PM ( const arma :: Row < float > & yi , const arma :: Row < float > & vi , const float tau2 ) function RandomEffect \u00b6 static ResultType RandomEffect ( const arma :: Row < float > & vi , const arma :: Row < float > & yi , float tau2 ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::RandomEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#samrandomeffectestimator","text":"Module: Meta Analysis Methods Random Effect Estimator. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis","title":"sam::RandomEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#public-classes","text":"Name struct Parameters Parameters of the RandomEffectEstimator . struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#public-functions","text":"Name RandomEffectEstimator () =default RandomEffectEstimator (const Parameters & p) virtual void estimate ( Journal * journal) float DL (const arma::Row< float > & yi, const arma::Row< float > & vi, const arma::Row< float > & ai) float PM (const arma::Row< float > & yi, const arma::Row< float > & vi, const float tau2) ResultType RandomEffect (const arma::Row< float > & vi, const arma::Row< float > & yi, float tau2)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#additional-inherited-members","text":"Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#function-randomeffectestimator","text":"RandomEffectEstimator () = default","title":"function RandomEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#function-randomeffectestimator_1","text":"inline RandomEffectEstimator ( const Parameters & p )","title":"function RandomEffectEstimator"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#function-estimate","text":"virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#function-dl","text":"float DL ( const arma :: Row < float > & yi , const arma :: Row < float > & vi , const arma :: Row < float > & ai )","title":"function DL"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#function-pm","text":"float PM ( const arma :: Row < float > & yi , const arma :: Row < float > & vi , const float tau2 )","title":"function PM"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#function-randomeffect","text":"static ResultType RandomEffect ( const arma :: Row < float > & vi , const arma :: Row < float > & yi , float tau2 )","title":"function RandomEffect"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_random_effect_estimator/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_random_selection/","text":"sam::RandomSelection \u00b6 Module: Review Strategies Random Selection Strategy. More... #include <ReviewStrategy.h> Inherits from ReviewStrategy Public Classes \u00b6 Name struct Parameters Parameter of Random Selection review strategy. Public Functions \u00b6 Name RandomSelection (const Parameters & p) bool review (const std::vector< Submission > & s) override bool review (const Experiment & expr) override Public Attributes \u00b6 Name Parameters params Detailed Description \u00b6 class sam :: RandomSelection ; Random Selection Strategy. In this method, Journal does not check any criteria for accepting or rejecting a submission. The `acceptance_rate` will decide the acceptance or rejection of a list of submissions. Public Functions Documentation \u00b6 function RandomSelection \u00b6 inline explicit RandomSelection ( const Parameters & p ) function review \u00b6 bool review ( const std :: vector < Submission > & s ) override Parameters : s corresponding submission Return : a boolean indicating whether the Submission is accepted. Based on a draw from r \\in [0, 1] r \\in [0, 1] , it accepts the submission if r r < acceptance_rate . function review \u00b6 inline bool review ( const Experiment & expr ) override Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::RandomSelection"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#samrandomselection","text":"Module: Review Strategies Random Selection Strategy. More... #include <ReviewStrategy.h> Inherits from ReviewStrategy","title":"sam::RandomSelection"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#public-classes","text":"Name struct Parameters Parameter of Random Selection review strategy.","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#public-functions","text":"Name RandomSelection (const Parameters & p) bool review (const std::vector< Submission > & s) override bool review (const Experiment & expr) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#detailed-description","text":"class sam :: RandomSelection ; Random Selection Strategy. In this method, Journal does not check any criteria for accepting or rejecting a submission. The `acceptance_rate` will decide the acceptance or rejection of a list of submissions.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#function-randomselection","text":"inline explicit RandomSelection ( const Parameters & p )","title":"function RandomSelection"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#function-review","text":"bool review ( const std :: vector < Submission > & s ) override Parameters : s corresponding submission Return : a boolean indicating whether the Submission is accepted. Based on a draw from r \\in [0, 1] r \\in [0, 1] , it accepts the submission if r r < acceptance_rate .","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#function-review_1","text":"inline bool review ( const Experiment & expr ) override","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_random_selection/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/","text":"sam::RankCorrelation \u00b6 Module: Meta Analysis Methods Begg's Rank Correlation Test. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis Public Classes \u00b6 Name struct Parameters Parameters of RankCorrelation . struct ResultType Public Functions \u00b6 Name RankCorrelation () =default RankCorrelation (const Parameters & p) virtual void estimate ( Journal * journal) ResultType RankCor (arma::Row< float > yi, arma::Row< float > vi, const Parameters & params) arma::Row< int > duplicate_count (arma::Row< float > x) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Public Functions Documentation \u00b6 function RankCorrelation \u00b6 RankCorrelation () = default function RankCorrelation \u00b6 inline RankCorrelation ( const Parameters & p ) function estimate \u00b6 virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate function RankCor \u00b6 static ResultType RankCor ( arma :: Row < float > yi , arma :: Row < float > vi , const Parameters & params ) function duplicate_count \u00b6 static arma :: Row < int > duplicate_count ( arma :: Row < float > x ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::RankCorrelation"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#samrankcorrelation","text":"Module: Meta Analysis Methods Begg's Rank Correlation Test. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis","title":"sam::RankCorrelation"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#public-classes","text":"Name struct Parameters Parameters of RankCorrelation . struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#public-functions","text":"Name RankCorrelation () =default RankCorrelation (const Parameters & p) virtual void estimate ( Journal * journal) ResultType RankCor (arma::Row< float > yi, arma::Row< float > vi, const Parameters & params) arma::Row< int > duplicate_count (arma::Row< float > x)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#additional-inherited-members","text":"Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#function-rankcorrelation","text":"RankCorrelation () = default","title":"function RankCorrelation"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#function-rankcorrelation_1","text":"inline RankCorrelation ( const Parameters & p )","title":"function RankCorrelation"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#function-estimate","text":"virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#function-rankcor","text":"static ResultType RankCor ( arma :: Row < float > yi , arma :: Row < float > vi , const Parameters & params )","title":"function RankCor"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#function-duplicate_count","text":"static arma :: Row < int > duplicate_count ( arma :: Row < float > x )","title":"function duplicate_count"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_rank_correlation/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/","text":"sam::ResearchStrategy \u00b6 Abstract class for different research strategies. More... #include <ResearchStrategy.h> Inherited by sam::DefaultResearchStrategy Public Functions \u00b6 Name virtual ~ResearchStrategy () =0 ResearchStrategy () virtual bool willStartHacking (std::optional< SubmissionPool > & subs) Indicates whether the researcher will start going to the hacking procedure. virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) Indicates whether the researcher will continue the hacking procedure. virtual bool willContinueHacking (std::optional< SubmissionPool > & sub, PolicyChain & pchain) bool willBeSubmitting (const std::optional< SubmissionPool > & sub, PolicyChain & pchain) virtual bool willContinueReplicating (SubmissionPool & subs) Decides whether the researcher is going to continue the replication process or not. void reset () Resets the internal state of the research strategy. std::optional< SubmissionPool > stashedSubmissions () Returns a copy of the stashed_submissions . virtual std::optional< SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) =0 Returns an optional result of applying the PolicyChainSet on the given Experiment . virtual std::optional< SubmissionPool > selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) =0 Returns an optional result of applying the PolicyChainSet on the given list of submissions. void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::optional< SubmissionPool > selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the Experiment . std::optional< SubmissionPool > selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the submission pool. std::unique_ptr< ResearchStrategy > build (json & research_strategy_config) ResearchStrategy factory method. Public Attributes \u00b6 Name sol::state lua PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_stashed_selection_policies PolicyChainSet between_reps_policies PolicyChain will_not_start_hacking_decision_policies PolicyChain will_not_continue_replicating_decision_policy PolicyChain stashing_policy Protected Attributes \u00b6 Name std::optional< SubmissionPool > submission_candidates SubmissionPool stashed_submissions Detailed Description \u00b6 class sam :: ResearchStrategy ; Abstract class for different research strategies. Note : This is being implemented as abstract class due to historical reasons. There is only one research strategy at the moment, but I'm considering the possibility of adding more and maybe redesigning this again. Public Functions Documentation \u00b6 function ~ResearchStrategy \u00b6 virtual ~ ResearchStrategy () = 0 Pure destructors of ResearchStrategy . This is necessary for proper deconstruction of derived classes. function ResearchStrategy \u00b6 ResearchStrategy () Besides constructing the base class, it also registers the Submission and DependentVariable in Lua for later use of the derived classes, e.g., DefaultResearchStrategy function willStartHacking \u00b6 inline virtual bool willStartHacking ( std :: optional < SubmissionPool > & subs ) Indicates whether the researcher will start going to the hacking procedure. Parameters : subs The subs Return : Returns true if researcher is going to start the hacking procedure Reimplemented by : sam::DefaultResearchStrategy::willStartHacking The default here is to not go for hacking if we already have one candidate; but this can be overridden in different research strategies function willContinueHacking \u00b6 inline virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) Indicates whether the researcher will continue the hacking procedure. Parameters : experiment A reference to the experiment Reimplemented by : sam::DefaultResearchStrategy::willContinueHacking This will be used by hackTheResearch and uses the decision policy to decide whether the next hacking strategy is going to be executed ! function willContinueHacking \u00b6 inline virtual bool willContinueHacking ( std :: optional < SubmissionPool > & sub , PolicyChain & pchain ) Reimplemented by : sam::DefaultResearchStrategy::willContinueHacking function willBeSubmitting \u00b6 bool willBeSubmitting ( const std :: optional < SubmissionPool > & sub , PolicyChain & pchain ) Parameters : subs A list of Submission(s) pchain A policy chain Return : returns true if submission should be submitted to the Journal . Indicates whether the Researcher is going to submit the given set of submissions or not. Usually submission_decision_policies will be used to evaluate the quality of the submission pool. This checks if at least one of the submissions satisfy all of the given policies. function willContinueReplicating \u00b6 inline virtual bool willContinueReplicating ( SubmissionPool & subs ) Decides whether the researcher is going to continue the replication process or not. Parameters : subs A list of submissions Return : Returns true if the replication procedure should continue Reimplemented by : sam::DefaultResearchStrategy::willContinueReplicating function reset \u00b6 inline void reset () Resets the internal state of the research strategy. function stashedSubmissions \u00b6 inline std :: optional < SubmissionPool > stashedSubmissions () Returns a copy of the stashed_submissions . Return : Returns an optional containing a copy of stashed_submissions Todo : this can be improved function selectOutcomeFromExperiment \u00b6 virtual std :: optional < SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) = 0 Returns an optional result of applying the PolicyChainSet on the given Experiment . Parameters : experiment The experiment pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplemented by : sam::DefaultResearchStrategy::selectOutcomeFromExperiment function selectOutcomeFromPool \u00b6 virtual std :: optional < SubmissionPool > selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) = 0 Returns an optional result of applying the PolicyChainSet on the given list of submissions. Parameters : spool The submission pool pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplemented by : sam::DefaultResearchStrategy::selectOutcomeFromPool function saveOutcomes \u00b6 void saveOutcomes ( Experiment & experiment , PolicyChain & pchain ) Parameters : experiment a reference to the experiment pchain a policy chain, usually #stashing_policy experiment a reference to the experiment pchain a policy chain, usually stored in stashing_policy in the config file Creates and save all possible submissions from an experiment, if they pass the given policy predicate Create and save all possible submissions from an experiment, if the satisfy all of the given policies in the pchain. function selectOutcome \u00b6 std :: optional < SubmissionPool > selectOutcome ( Experiment & experiment , PolicyChainSet & pchain_set ) Returns the result of applying the PolicyChainSet on the Experiment . Parameters : experiment The experiment pchain_set The policy chain set. experiment a reference to an experiment pchain_set a reference to a policy chain set Return : Returns a list of submissions, if any. A list of submissions, if any. Select an unique outcome from an experiment, if at some point, a PolicyChain finds a group of outcomes instead of a unique outcome, the selection will be saved and the will await for processing in a different stages. We check all available PolicyChains in the given chain set, and will stop as soon as any chain returns something ! function selectBetweenSubmissions \u00b6 std :: optional < SubmissionPool > selectBetweenSubmissions ( SubmissionPool & spool , PolicyChainSet & pchain_set ) Returns the result of applying the PolicyChainSet on the submission pool. Parameters : spool The spool pchain_set The policy chain set spool a collection of submissions collected in previous stages, e.g., selectOutcome pchain_set a set of policy chains Return : Returns a list of submissions, if any. A list of submissions, if any. Note : If submission_candidate is empty to this point, and we cannot find anything here, we'll continue with nothing, and the current experiment will most likely be discarded. Select a unique submission from the given pool of submissions. If none of the submissions satisfies all the policies, we just return, and submission_candidate will not be rewritten. If any of the pchains return something, we ignore the rest, and leave! function build \u00b6 static std :: unique_ptr < ResearchStrategy > build ( json & research_strategy_config ) ResearchStrategy factory method. Parameters : research_strategy_config A JSON object containing information about each research strategy. Return : Returns a unique pointer to the newly build ResearchStrategy . Public Attributes Documentation \u00b6 variable lua \u00b6 sol :: state lua ; variable initial_selection_policies \u00b6 PolicyChainSet initial_selection_policies ; Todo : These guys should move to their own class, I don't have to keep everything here! variable submission_decision_policies \u00b6 PolicyChain submission_decision_policies ; variable between_stashed_selection_policies \u00b6 PolicyChainSet between_stashed_selection_policies ; variable between_reps_policies \u00b6 PolicyChainSet between_reps_policies ; variable will_not_start_hacking_decision_policies \u00b6 PolicyChain will_not_start_hacking_decision_policies ; variable will_not_continue_replicating_decision_policy \u00b6 PolicyChain will_not_continue_replicating_decision_policy ; variable stashing_policy \u00b6 PolicyChain stashing_policy ; Protected Attributes Documentation \u00b6 variable submission_candidates \u00b6 std :: optional < SubmissionPool > submission_candidates ; variable stashed_submissions \u00b6 SubmissionPool stashed_submissions ; List of selected submissions collected by the researcher using the stashing_policy Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::ResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#samresearchstrategy","text":"Abstract class for different research strategies. More... #include <ResearchStrategy.h> Inherited by sam::DefaultResearchStrategy","title":"sam::ResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#public-functions","text":"Name virtual ~ResearchStrategy () =0 ResearchStrategy () virtual bool willStartHacking (std::optional< SubmissionPool > & subs) Indicates whether the researcher will start going to the hacking procedure. virtual bool willContinueHacking ( Experiment * experiment, PolicyChain & pchain) Indicates whether the researcher will continue the hacking procedure. virtual bool willContinueHacking (std::optional< SubmissionPool > & sub, PolicyChain & pchain) bool willBeSubmitting (const std::optional< SubmissionPool > & sub, PolicyChain & pchain) virtual bool willContinueReplicating (SubmissionPool & subs) Decides whether the researcher is going to continue the replication process or not. void reset () Resets the internal state of the research strategy. std::optional< SubmissionPool > stashedSubmissions () Returns a copy of the stashed_submissions . virtual std::optional< SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment, PolicyChainSet & pchain_set) =0 Returns an optional result of applying the PolicyChainSet on the given Experiment . virtual std::optional< SubmissionPool > selectOutcomeFromPool (SubmissionPool & spool, PolicyChainSet & pchain_set) =0 Returns an optional result of applying the PolicyChainSet on the given list of submissions. void saveOutcomes ( Experiment & experiment, PolicyChain & pchain) std::optional< SubmissionPool > selectOutcome ( Experiment & experiment, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the Experiment . std::optional< SubmissionPool > selectBetweenSubmissions (SubmissionPool & spool, PolicyChainSet & pchain_set) Returns the result of applying the PolicyChainSet on the submission pool. std::unique_ptr< ResearchStrategy > build (json & research_strategy_config) ResearchStrategy factory method.","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#public-attributes","text":"Name sol::state lua PolicyChainSet initial_selection_policies PolicyChain submission_decision_policies PolicyChainSet between_stashed_selection_policies PolicyChainSet between_reps_policies PolicyChain will_not_start_hacking_decision_policies PolicyChain will_not_continue_replicating_decision_policy PolicyChain stashing_policy","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#protected-attributes","text":"Name std::optional< SubmissionPool > submission_candidates SubmissionPool stashed_submissions","title":"Protected Attributes"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#detailed-description","text":"class sam :: ResearchStrategy ; Abstract class for different research strategies. Note : This is being implemented as abstract class due to historical reasons. There is only one research strategy at the moment, but I'm considering the possibility of adding more and maybe redesigning this again.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-researchstrategy","text":"virtual ~ ResearchStrategy () = 0 Pure destructors of ResearchStrategy . This is necessary for proper deconstruction of derived classes.","title":"function ~ResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-researchstrategy_1","text":"ResearchStrategy () Besides constructing the base class, it also registers the Submission and DependentVariable in Lua for later use of the derived classes, e.g., DefaultResearchStrategy","title":"function ResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-willstarthacking","text":"inline virtual bool willStartHacking ( std :: optional < SubmissionPool > & subs ) Indicates whether the researcher will start going to the hacking procedure. Parameters : subs The subs Return : Returns true if researcher is going to start the hacking procedure Reimplemented by : sam::DefaultResearchStrategy::willStartHacking The default here is to not go for hacking if we already have one candidate; but this can be overridden in different research strategies","title":"function willStartHacking"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-willcontinuehacking","text":"inline virtual bool willContinueHacking ( Experiment * experiment , PolicyChain & pchain ) Indicates whether the researcher will continue the hacking procedure. Parameters : experiment A reference to the experiment Reimplemented by : sam::DefaultResearchStrategy::willContinueHacking This will be used by hackTheResearch and uses the decision policy to decide whether the next hacking strategy is going to be executed !","title":"function willContinueHacking"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-willcontinuehacking_1","text":"inline virtual bool willContinueHacking ( std :: optional < SubmissionPool > & sub , PolicyChain & pchain ) Reimplemented by : sam::DefaultResearchStrategy::willContinueHacking","title":"function willContinueHacking"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-willbesubmitting","text":"bool willBeSubmitting ( const std :: optional < SubmissionPool > & sub , PolicyChain & pchain ) Parameters : subs A list of Submission(s) pchain A policy chain Return : returns true if submission should be submitted to the Journal . Indicates whether the Researcher is going to submit the given set of submissions or not. Usually submission_decision_policies will be used to evaluate the quality of the submission pool. This checks if at least one of the submissions satisfy all of the given policies.","title":"function willBeSubmitting"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-willcontinuereplicating","text":"inline virtual bool willContinueReplicating ( SubmissionPool & subs ) Decides whether the researcher is going to continue the replication process or not. Parameters : subs A list of submissions Return : Returns true if the replication procedure should continue Reimplemented by : sam::DefaultResearchStrategy::willContinueReplicating","title":"function willContinueReplicating"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-reset","text":"inline void reset () Resets the internal state of the research strategy.","title":"function reset"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-stashedsubmissions","text":"inline std :: optional < SubmissionPool > stashedSubmissions () Returns a copy of the stashed_submissions . Return : Returns an optional containing a copy of stashed_submissions Todo : this can be improved","title":"function stashedSubmissions"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-selectoutcomefromexperiment","text":"virtual std :: optional < SubmissionPool > selectOutcomeFromExperiment ( Experiment * experiment , PolicyChainSet & pchain_set ) = 0 Returns an optional result of applying the PolicyChainSet on the given Experiment . Parameters : experiment The experiment pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplemented by : sam::DefaultResearchStrategy::selectOutcomeFromExperiment","title":"function selectOutcomeFromExperiment"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-selectoutcomefrompool","text":"virtual std :: optional < SubmissionPool > selectOutcomeFromPool ( SubmissionPool & spool , PolicyChainSet & pchain_set ) = 0 Returns an optional result of applying the PolicyChainSet on the given list of submissions. Parameters : spool The submission pool pchain_set The policy chain set Return : Returns a list of submissions, if any. Reimplemented by : sam::DefaultResearchStrategy::selectOutcomeFromPool","title":"function selectOutcomeFromPool"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-saveoutcomes","text":"void saveOutcomes ( Experiment & experiment , PolicyChain & pchain ) Parameters : experiment a reference to the experiment pchain a policy chain, usually #stashing_policy experiment a reference to the experiment pchain a policy chain, usually stored in stashing_policy in the config file Creates and save all possible submissions from an experiment, if they pass the given policy predicate Create and save all possible submissions from an experiment, if the satisfy all of the given policies in the pchain.","title":"function saveOutcomes"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-selectoutcome","text":"std :: optional < SubmissionPool > selectOutcome ( Experiment & experiment , PolicyChainSet & pchain_set ) Returns the result of applying the PolicyChainSet on the Experiment . Parameters : experiment The experiment pchain_set The policy chain set. experiment a reference to an experiment pchain_set a reference to a policy chain set Return : Returns a list of submissions, if any. A list of submissions, if any. Select an unique outcome from an experiment, if at some point, a PolicyChain finds a group of outcomes instead of a unique outcome, the selection will be saved and the will await for processing in a different stages. We check all available PolicyChains in the given chain set, and will stop as soon as any chain returns something !","title":"function selectOutcome"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-selectbetweensubmissions","text":"std :: optional < SubmissionPool > selectBetweenSubmissions ( SubmissionPool & spool , PolicyChainSet & pchain_set ) Returns the result of applying the PolicyChainSet on the submission pool. Parameters : spool The spool pchain_set The policy chain set spool a collection of submissions collected in previous stages, e.g., selectOutcome pchain_set a set of policy chains Return : Returns a list of submissions, if any. A list of submissions, if any. Note : If submission_candidate is empty to this point, and we cannot find anything here, we'll continue with nothing, and the current experiment will most likely be discarded. Select a unique submission from the given pool of submissions. If none of the submissions satisfies all the policies, we just return, and submission_candidate will not be rewritten. If any of the pchains return something, we ignore the rest, and leave!","title":"function selectBetweenSubmissions"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#function-build","text":"static std :: unique_ptr < ResearchStrategy > build ( json & research_strategy_config ) ResearchStrategy factory method. Parameters : research_strategy_config A JSON object containing information about each research strategy. Return : Returns a unique pointer to the newly build ResearchStrategy .","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-lua","text":"sol :: state lua ;","title":"variable lua"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-initial_selection_policies","text":"PolicyChainSet initial_selection_policies ; Todo : These guys should move to their own class, I don't have to keep everything here!","title":"variable initial_selection_policies"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-submission_decision_policies","text":"PolicyChain submission_decision_policies ;","title":"variable submission_decision_policies"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-between_stashed_selection_policies","text":"PolicyChainSet between_stashed_selection_policies ;","title":"variable between_stashed_selection_policies"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-between_reps_policies","text":"PolicyChainSet between_reps_policies ;","title":"variable between_reps_policies"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-will_not_start_hacking_decision_policies","text":"PolicyChain will_not_start_hacking_decision_policies ;","title":"variable will_not_start_hacking_decision_policies"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-will_not_continue_replicating_decision_policy","text":"PolicyChain will_not_continue_replicating_decision_policy ;","title":"variable will_not_continue_replicating_decision_policy"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-stashing_policy","text":"PolicyChain stashing_policy ;","title":"variable stashing_policy"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-submission_candidates","text":"std :: optional < SubmissionPool > submission_candidates ;","title":"variable submission_candidates"},{"location":"doxygen/Classes/classsam_1_1_research_strategy/#variable-stashed_submissions","text":"SubmissionPool stashed_submissions ; List of selected submissions collected by the researcher using the stashing_policy Updated on 29 June 2021 at 16:13:46 CEST","title":"variable stashed_submissions"},{"location":"doxygen/Classes/classsam_1_1_researcher/","text":"sam::Researcher \u00b6 This class describes a researcher. More... #include <Researcher.h> Public Functions \u00b6 Name Researcher () =default void preProcessData () Applies the pro-processing methods on the Experiment . bool isHacker () Determines whether the Researcher is a hacker. bool isCommittingToTheHack ( HackingStrategy * hs) Determines whether the Researcher will commit to the given hack. void research () Perform the Research. std::optional< SubmissionPool > hackTheResearch () Applies the HackingWorkflow on the Experiment . void randomizeHackingStrategies () Randomizes the internal state of the Researcher . void submitTheResearch (const std::optional< std::vector< Submission >> & subs) Evaluating the candidates and submitting them to the Journal . void computeStuff () const A helper function for re-computing all statistics at once. void reset () Resets the internal state of the Researcher . ResearcherBuilder create (std::string name) Public Attributes \u00b6 Name std::vector< std::unique_ptr< HackingStrategy > > pre_processing_methods std::unique_ptr< Experiment > experiment Researcher 's Experiment . std::shared_ptr< Journal > journal Researcher 's Journal of choice! std::unique_ptr< ResearchStrategy > research_strategy Researcher 's Research Strategy. HackingWorkflow original_workflow Original set of hacking strategies and their Selection\u2192Decision sequences. HackingWorkflow hacking_workflow Friends \u00b6 Name class ResearcherBuilder Detailed Description \u00b6 class sam :: Researcher ; This class describes a researcher. Researcher is the main player of the game. It has access to almost everything and it works with several other components to conduct and evaluate the research, and prepare it to be submitted to the Journal . Public Functions Documentation \u00b6 function Researcher \u00b6 Researcher () = default This doesn't do anything! But it should! At the moment, I'm relying on the ResearcherBuilder to construct the Researcher but this has to change function preProcessData \u00b6 void preProcessData () Applies the pro-processing methods on the Experiment . Note : This has a very similar implementation to the [hackTheResearch()](/doxygen/Classes/classsam_1_1_researcher/#function-hacktheresearch) but it doesn't perform any of the secondary checks, and it does not incorporates any of the selection \u2192 decision sequences. Iterating over the registered pre_processing_methods , this applies all of the them to the current experiment. Keep in mind that the pre-processing is done before any of the decision/hacking stages, and right after data generation. function isHacker \u00b6 bool isHacker () Determines whether the Researcher is a hacker. Note : Note that the #probability_of_being_a_hacker is called through it's call operator(). This guarantees that its value is being randomized only if it contains a distribution. This technically invokes the #probability_of_being_a_hacker, and returns the outcome. The value then will be cast-ed to a boolean to determine whether the Researcher is going to start the hacking procedure or not, ie., calling or skipping the hackTheResearch() . function isCommittingToTheHack \u00b6 bool isCommittingToTheHack ( HackingStrategy * hs ) Determines whether the Researcher will commit to the given hack. Similar to the isHacker() method, this returns a boolean indicating whether or not the Researcher will commit to the given hacking method. The probability of commitment to a hacking strategy is being calculated from the value of #probability_of_committing_a_hack. function research \u00b6 void research () Perform the Research. This is the main routine of the Researcher . It is responsible for a few things: Randomizing the Experiment , if necessary Initializing the Experiment Performing the research by: Generating the data Pre-processing the Data, if necessary Calculating the statistics Deciding whether to hack or not Perform the hack, if necessary Deciding whether to replicate the research Perform the replication, if necessary Evaluate the list of final submissions Submit the final submissions to the Journal , or discard the Experiment Clean up everything, and start a get ready for a new run The internal of the method is based on sequential application of selection \u2192 decision sequences on the experiment. Throughout the process, the researcher keeps the list of candidate submissions, #candidate_submissions, up-to-date. This starts by the initial selection, and following though with the hacking, and stashing selection. At the end of each replication, if any, researcher collects the last submission candidate and head to perform a new experiment. After performing all the replications (or skipping some), researcher perform a final selection \u2192 decision on the list of #replicated_submissions and select her final submission to be submitted to the Journal . function hackTheResearch \u00b6 std :: optional < SubmissionPool > hackTheResearch () Applies the HackingWorkflow on the Experiment . Return : Returns true if any of the decision steps passes, it returns false indicating that none of the selection \u2192 decisions were successful. This uses HackingWorkflow to sequentially apply sets of hacking \u2192 selection \u2192 decision on the available Experiment . Before applying each hacking strategy, researcher asks isCommittingToTheHack() to decide on whether or not it is going to commit to a hack, if not, the rest of the set will be ignored, and researcher continues with the next set, if available. function randomizeHackingStrategies \u00b6 void randomizeHackingStrategies () Randomizes the internal state of the Researcher . Note : It worth mentioning that, this method doesn't randomize the internal parameters of individual hacking strategies. Hacking strategies parameters can be randomized only if their parameters are set to be a Parameter . Based on the provided settings, this re-selects, re-arranges, and shuffles the list of hacking strategies, and their corresponding parameters. function submitTheResearch \u00b6 void submitTheResearch ( const std :: optional < std :: vector < Submission >> & subs ) Evaluating the candidates and submitting them to the Journal . This checks whether there is any submissions at all, if so, it checks whether submission_decision_policies have any hits, if so, it gives a green light to Researcher to submit the list of submissions; otherwise, it discards the list. function computeStuff \u00b6 inline void computeStuff () const A helper function for re-computing all statistics at once. function reset \u00b6 inline void reset () Resets the internal state of the Researcher . function create \u00b6 static ResearcherBuilder create ( std :: string name ) Parameters : name The researcher name Return : An instance of ResearcherBuilder . Starts the Researcher build process. Use this to build a new instance of the Researcher . Public Attributes Documentation \u00b6 variable pre_processing_methods \u00b6 std :: vector < std :: unique_ptr < HackingStrategy > > pre_processing_methods ; List of hacking strategies that are going to be applied on the experiment during the pre-processing stage variable experiment \u00b6 std :: unique_ptr < Experiment > experiment ; Researcher 's Experiment . variable journal \u00b6 std :: shared_ptr < Journal > journal ; Researcher 's Journal of choice! variable research_strategy \u00b6 std :: unique_ptr < ResearchStrategy > research_strategy ; Researcher 's Research Strategy. variable original_workflow \u00b6 HackingWorkflow original_workflow ; Original set of hacking strategies and their Selection\u2192Decision sequences. variable hacking_workflow \u00b6 HackingWorkflow hacking_workflow ; Researcher 's hacking workflow. This is a subset of the original_workflow , as it is being filtered and rearranged by various factors during the initialization. Friends \u00b6 friend ResearcherBuilder \u00b6 friend class ResearcherBuilder ( ResearcherBuilder ); Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::Researcher"},{"location":"doxygen/Classes/classsam_1_1_researcher/#samresearcher","text":"This class describes a researcher. More... #include <Researcher.h>","title":"sam::Researcher"},{"location":"doxygen/Classes/classsam_1_1_researcher/#public-functions","text":"Name Researcher () =default void preProcessData () Applies the pro-processing methods on the Experiment . bool isHacker () Determines whether the Researcher is a hacker. bool isCommittingToTheHack ( HackingStrategy * hs) Determines whether the Researcher will commit to the given hack. void research () Perform the Research. std::optional< SubmissionPool > hackTheResearch () Applies the HackingWorkflow on the Experiment . void randomizeHackingStrategies () Randomizes the internal state of the Researcher . void submitTheResearch (const std::optional< std::vector< Submission >> & subs) Evaluating the candidates and submitting them to the Journal . void computeStuff () const A helper function for re-computing all statistics at once. void reset () Resets the internal state of the Researcher . ResearcherBuilder create (std::string name)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_researcher/#public-attributes","text":"Name std::vector< std::unique_ptr< HackingStrategy > > pre_processing_methods std::unique_ptr< Experiment > experiment Researcher 's Experiment . std::shared_ptr< Journal > journal Researcher 's Journal of choice! std::unique_ptr< ResearchStrategy > research_strategy Researcher 's Research Strategy. HackingWorkflow original_workflow Original set of hacking strategies and their Selection\u2192Decision sequences. HackingWorkflow hacking_workflow","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_researcher/#friends","text":"Name class ResearcherBuilder","title":"Friends"},{"location":"doxygen/Classes/classsam_1_1_researcher/#detailed-description","text":"class sam :: Researcher ; This class describes a researcher. Researcher is the main player of the game. It has access to almost everything and it works with several other components to conduct and evaluate the research, and prepare it to be submitted to the Journal .","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_researcher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-researcher","text":"Researcher () = default This doesn't do anything! But it should! At the moment, I'm relying on the ResearcherBuilder to construct the Researcher but this has to change","title":"function Researcher"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-preprocessdata","text":"void preProcessData () Applies the pro-processing methods on the Experiment . Note : This has a very similar implementation to the [hackTheResearch()](/doxygen/Classes/classsam_1_1_researcher/#function-hacktheresearch) but it doesn't perform any of the secondary checks, and it does not incorporates any of the selection \u2192 decision sequences. Iterating over the registered pre_processing_methods , this applies all of the them to the current experiment. Keep in mind that the pre-processing is done before any of the decision/hacking stages, and right after data generation.","title":"function preProcessData"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-ishacker","text":"bool isHacker () Determines whether the Researcher is a hacker. Note : Note that the #probability_of_being_a_hacker is called through it's call operator(). This guarantees that its value is being randomized only if it contains a distribution. This technically invokes the #probability_of_being_a_hacker, and returns the outcome. The value then will be cast-ed to a boolean to determine whether the Researcher is going to start the hacking procedure or not, ie., calling or skipping the hackTheResearch() .","title":"function isHacker"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-iscommittingtothehack","text":"bool isCommittingToTheHack ( HackingStrategy * hs ) Determines whether the Researcher will commit to the given hack. Similar to the isHacker() method, this returns a boolean indicating whether or not the Researcher will commit to the given hacking method. The probability of commitment to a hacking strategy is being calculated from the value of #probability_of_committing_a_hack.","title":"function isCommittingToTheHack"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-research","text":"void research () Perform the Research. This is the main routine of the Researcher . It is responsible for a few things: Randomizing the Experiment , if necessary Initializing the Experiment Performing the research by: Generating the data Pre-processing the Data, if necessary Calculating the statistics Deciding whether to hack or not Perform the hack, if necessary Deciding whether to replicate the research Perform the replication, if necessary Evaluate the list of final submissions Submit the final submissions to the Journal , or discard the Experiment Clean up everything, and start a get ready for a new run The internal of the method is based on sequential application of selection \u2192 decision sequences on the experiment. Throughout the process, the researcher keeps the list of candidate submissions, #candidate_submissions, up-to-date. This starts by the initial selection, and following though with the hacking, and stashing selection. At the end of each replication, if any, researcher collects the last submission candidate and head to perform a new experiment. After performing all the replications (or skipping some), researcher perform a final selection \u2192 decision on the list of #replicated_submissions and select her final submission to be submitted to the Journal .","title":"function research"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-hacktheresearch","text":"std :: optional < SubmissionPool > hackTheResearch () Applies the HackingWorkflow on the Experiment . Return : Returns true if any of the decision steps passes, it returns false indicating that none of the selection \u2192 decisions were successful. This uses HackingWorkflow to sequentially apply sets of hacking \u2192 selection \u2192 decision on the available Experiment . Before applying each hacking strategy, researcher asks isCommittingToTheHack() to decide on whether or not it is going to commit to a hack, if not, the rest of the set will be ignored, and researcher continues with the next set, if available.","title":"function hackTheResearch"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-randomizehackingstrategies","text":"void randomizeHackingStrategies () Randomizes the internal state of the Researcher . Note : It worth mentioning that, this method doesn't randomize the internal parameters of individual hacking strategies. Hacking strategies parameters can be randomized only if their parameters are set to be a Parameter . Based on the provided settings, this re-selects, re-arranges, and shuffles the list of hacking strategies, and their corresponding parameters.","title":"function randomizeHackingStrategies"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-submittheresearch","text":"void submitTheResearch ( const std :: optional < std :: vector < Submission >> & subs ) Evaluating the candidates and submitting them to the Journal . This checks whether there is any submissions at all, if so, it checks whether submission_decision_policies have any hits, if so, it gives a green light to Researcher to submit the list of submissions; otherwise, it discards the list.","title":"function submitTheResearch"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-computestuff","text":"inline void computeStuff () const A helper function for re-computing all statistics at once.","title":"function computeStuff"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-reset","text":"inline void reset () Resets the internal state of the Researcher .","title":"function reset"},{"location":"doxygen/Classes/classsam_1_1_researcher/#function-create","text":"static ResearcherBuilder create ( std :: string name ) Parameters : name The researcher name Return : An instance of ResearcherBuilder . Starts the Researcher build process. Use this to build a new instance of the Researcher .","title":"function create"},{"location":"doxygen/Classes/classsam_1_1_researcher/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_researcher/#variable-pre_processing_methods","text":"std :: vector < std :: unique_ptr < HackingStrategy > > pre_processing_methods ; List of hacking strategies that are going to be applied on the experiment during the pre-processing stage","title":"variable pre_processing_methods"},{"location":"doxygen/Classes/classsam_1_1_researcher/#variable-experiment","text":"std :: unique_ptr < Experiment > experiment ; Researcher 's Experiment .","title":"variable experiment"},{"location":"doxygen/Classes/classsam_1_1_researcher/#variable-journal","text":"std :: shared_ptr < Journal > journal ; Researcher 's Journal of choice!","title":"variable journal"},{"location":"doxygen/Classes/classsam_1_1_researcher/#variable-research_strategy","text":"std :: unique_ptr < ResearchStrategy > research_strategy ; Researcher 's Research Strategy.","title":"variable research_strategy"},{"location":"doxygen/Classes/classsam_1_1_researcher/#variable-original_workflow","text":"HackingWorkflow original_workflow ; Original set of hacking strategies and their Selection\u2192Decision sequences.","title":"variable original_workflow"},{"location":"doxygen/Classes/classsam_1_1_researcher/#variable-hacking_workflow","text":"HackingWorkflow hacking_workflow ; Researcher 's hacking workflow. This is a subset of the original_workflow , as it is being filtered and rearranged by various factors during the initialization.","title":"variable hacking_workflow"},{"location":"doxygen/Classes/classsam_1_1_researcher/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/classsam_1_1_researcher/#friend-researcherbuilder","text":"friend class ResearcherBuilder ( ResearcherBuilder ); Updated on 29 June 2021 at 16:13:46 CEST","title":"friend ResearcherBuilder"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/","text":"sam::ResearcherBuilder \u00b6 Module: Abstract Factory Builders More... #include <Researcher.h> Public Functions \u00b6 Name ResearcherBuilder () =default ResearcherBuilder (std::string name) ResearcherBuilder & fromConfigFile (json & config) Building the Researcher using the JSON configuration file. ResearcherBuilder & createResearchStrategy (json & ds) CREATING A NEW OBJECT ///. Researcher build () Detailed Description \u00b6 class sam :: ResearcherBuilder ; Note : At this moment, ResearcherBuilder is a very limited and can only initialize the Researcher from a config file. ResearcherBuilder class for Researcher . This takes care of everything and return a fully initialized Researcher after calling .[build()](/doxygen/Classes/classsam_1_1_researcher_builder/#function-build) method. Public Functions Documentation \u00b6 function ResearcherBuilder \u00b6 ResearcherBuilder () = default function ResearcherBuilder \u00b6 inline explicit ResearcherBuilder ( std :: string name ) function fromConfigFile \u00b6 inline ResearcherBuilder & fromConfigFile ( json & config ) Building the Researcher using the JSON configuration file. Parameters : config A JSON object Return : Return an instance of itself This builds a researcher entirely based on the given config file. This is not the best implementation yet but I think it's more readable and reasonable for some use-cases. function createResearchStrategy \u00b6 inline ResearcherBuilder & createResearchStrategy ( json & ds ) CREATING A NEW OBJECT ///. Create a new ResearchStrategy for the researcher based on the given configuration. function build \u00b6 inline Researcher build () Return : A new Researcher Note : Be aware that this needs to be called after you set all aspects of the Researcher Build and return a new Researcher . Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::ResearcherBuilder"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#samresearcherbuilder","text":"Module: Abstract Factory Builders More... #include <Researcher.h>","title":"sam::ResearcherBuilder"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#public-functions","text":"Name ResearcherBuilder () =default ResearcherBuilder (std::string name) ResearcherBuilder & fromConfigFile (json & config) Building the Researcher using the JSON configuration file. ResearcherBuilder & createResearchStrategy (json & ds) CREATING A NEW OBJECT ///. Researcher build ()","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#detailed-description","text":"class sam :: ResearcherBuilder ; Note : At this moment, ResearcherBuilder is a very limited and can only initialize the Researcher from a config file. ResearcherBuilder class for Researcher . This takes care of everything and return a fully initialized Researcher after calling .[build()](/doxygen/Classes/classsam_1_1_researcher_builder/#function-build) method.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#function-researcherbuilder","text":"ResearcherBuilder () = default","title":"function ResearcherBuilder"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#function-researcherbuilder_1","text":"inline explicit ResearcherBuilder ( std :: string name )","title":"function ResearcherBuilder"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#function-fromconfigfile","text":"inline ResearcherBuilder & fromConfigFile ( json & config ) Building the Researcher using the JSON configuration file. Parameters : config A JSON object Return : Return an instance of itself This builds a researcher entirely based on the given config file. This is not the best implementation yet but I think it's more readable and reasonable for some use-cases.","title":"function fromConfigFile"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#function-createresearchstrategy","text":"inline ResearcherBuilder & createResearchStrategy ( json & ds ) CREATING A NEW OBJECT ///. Create a new ResearchStrategy for the researcher based on the given configuration.","title":"function createResearchStrategy"},{"location":"doxygen/Classes/classsam_1_1_researcher_builder/#function-build","text":"inline Researcher build () Return : A new Researcher Note : Be aware that this needs to be called after you set all aspects of the Researcher Build and return a new Researcher . Updated on 29 June 2021 at 16:13:48 CEST","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/","text":"sam::SignificantSelection \u00b6 Module: Review Strategies Significant-based Selection Strategy. More... #include <ReviewStrategy.h> Inherits from ReviewStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name SignificantSelection (const Parameters & p) bool review (const std::vector< Submission > & s) override bool review (const Experiment & expr) override Public Attributes \u00b6 Name Parameters params Detailed Description \u00b6 class sam :: SignificantSelection ; Significant-based Selection Strategy. Significant-based review strategy accepts a publication if the given *p*-value is significant. Certain degree of *publication bias*, can be specified. In this case, a Submission has a chance of being published even if the statistics is not significant. Moreover, the SignificantSelection can be tailored toward either positive or negative effect. In this case, the Journal will only accept Submissions with larger or smaller effects. Public Functions Documentation \u00b6 function SignificantSelection \u00b6 inline explicit SignificantSelection ( const Parameters & p ) function review \u00b6 bool review ( const std :: vector < Submission > & s ) override Parameters : s A reference to the Submission Return : a boolean indicating whether the Submission is accepted. Check if the p -value of any of the Submissions are less than the specified \\alpha \\alpha . If true, it will accept the submission, if not, a random number decide whether or not the submission is going to be accepted. The drawn random number, r r will be compared to pub_bias_rate of the journal. function review \u00b6 inline bool review ( const Experiment & expr ) override Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::SignificantSelection"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#samsignificantselection","text":"Module: Review Strategies Significant-based Selection Strategy. More... #include <ReviewStrategy.h> Inherits from ReviewStrategy","title":"sam::SignificantSelection"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#public-functions","text":"Name SignificantSelection (const Parameters & p) bool review (const std::vector< Submission > & s) override bool review (const Experiment & expr) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#detailed-description","text":"class sam :: SignificantSelection ; Significant-based Selection Strategy. Significant-based review strategy accepts a publication if the given *p*-value is significant. Certain degree of *publication bias*, can be specified. In this case, a Submission has a chance of being published even if the statistics is not significant. Moreover, the SignificantSelection can be tailored toward either positive or negative effect. In this case, the Journal will only accept Submissions with larger or smaller effects.","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#function-significantselection","text":"inline explicit SignificantSelection ( const Parameters & p )","title":"function SignificantSelection"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#function-review","text":"bool review ( const std :: vector < Submission > & s ) override Parameters : s A reference to the Submission Return : a boolean indicating whether the Submission is accepted. Check if the p -value of any of the Submissions are less than the specified \\alpha \\alpha . If true, it will accept the submission, if not, a random number decide whether or not the submission is going to be accepted. The drawn random number, r r will be compared to pub_bias_rate of the journal.","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#function-review_1","text":"inline bool review ( const Experiment & expr ) override","title":"function review"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_significant_selection/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/","text":"sam::StandardizedMeanDifference \u00b6 Module: Effect Strategies Inherits from sam::EffectStrategy Public Functions \u00b6 Name StandardizedMeanDifference () =default virtual void computeEffects ( Experiment * experiment) override Additional inherited members \u00b6 Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0 Public Functions Documentation \u00b6 function StandardizedMeanDifference \u00b6 explicit StandardizedMeanDifference () = default function computeEffects \u00b6 virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::StandardizedMeanDifference"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/#samstandardizedmeandifference","text":"Module: Effect Strategies Inherits from sam::EffectStrategy","title":"sam::StandardizedMeanDifference"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/#public-functions","text":"Name StandardizedMeanDifference () =default virtual void computeEffects ( Experiment * experiment) override","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/#additional-inherited-members","text":"Public Types inherited from sam::EffectStrategy Name enum EffectEstimator Public Functions inherited from sam::EffectStrategy Name std::unique_ptr< EffectStrategy > build (json & effect_strategy_config) virtual ~EffectStrategy () =0","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/#function-standardizedmeandifference","text":"explicit StandardizedMeanDifference () = default","title":"function StandardizedMeanDifference"},{"location":"doxygen/Classes/classsam_1_1_standardized_mean_difference/#function-computeeffects","text":"virtual void computeEffects ( Experiment * experiment ) override Reimplements : sam::EffectStrategy::computeEffects Updated on 29 June 2021 at 16:13:47 CEST","title":"function computeEffects"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/","text":"sam::StoppingDataCollection \u00b6 Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters Public Functions \u00b6 Name StoppingDataCollection () =default StoppingDataCollection (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment . Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: StoppingDataCollection ; Fabricating Data Hacking Strategy Public Functions Documentation \u00b6 function StoppingDataCollection \u00b6 StoppingDataCollection () = default function StoppingDataCollection \u00b6 inline explicit StoppingDataCollection ( const Parameters & p ) function perform \u00b6 virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform TodoCheck whether this overflow. As I'm using the n_obs_max, there might be cases that I don't really get enough observations to add, or I add less, or more to a group Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::StoppingDataCollection"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#samstoppingdatacollection","text":"Module: Hacking Strategies More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::StoppingDataCollection"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#public-classes","text":"Name struct Parameters","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#public-functions","text":"Name StoppingDataCollection () =default StoppingDataCollection (const Parameters & p) virtual void perform ( Experiment * experiment) override Applies the hacking method on the Experiment .","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#detailed-description","text":"class sam :: StoppingDataCollection ; Fabricating Data Hacking Strategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#function-stoppingdatacollection","text":"StoppingDataCollection () = default","title":"function StoppingDataCollection"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#function-stoppingdatacollection_1","text":"inline explicit StoppingDataCollection ( const Parameters & p )","title":"function StoppingDataCollection"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#function-perform","text":"virtual void perform ( Experiment * experiment ) override Applies the hacking method on the Experiment . Parameters : experiment A pointer to an Experiment . Reimplements : sam::HackingStrategy::perform TodoCheck whether this overflow. As I'm using the n_obs_max, there might be cases that I don't really get enough observations to add, or I add less, or more to a group","title":"function perform"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_stopping_data_collection/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/","text":"sam::SubjectiveOutlierRemoval \u00b6 Module: Hacking Strategies The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy Public Classes \u00b6 Name struct Parameters SubjectiveOutlierRemoval 's parameters. Public Functions \u00b6 Name SubjectiveOutlierRemoval () =default SubjectiveOutlierRemoval (const Parameters & p) Public Attributes \u00b6 Name Parameters params PolicyChain stopping_condition Additional inherited members \u00b6 Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_ Detailed Description \u00b6 class sam :: SubjectiveOutlierRemoval ; The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. See : ResearchStrategy Public Functions Documentation \u00b6 function SubjectiveOutlierRemoval \u00b6 SubjectiveOutlierRemoval () = default function SubjectiveOutlierRemoval \u00b6 inline explicit SubjectiveOutlierRemoval ( const Parameters & p ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; variable stopping_condition \u00b6 PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::SubjectiveOutlierRemoval"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#samsubjectiveoutlierremoval","text":"Module: Hacking Strategies The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. More... #include <HackingStrategy.h> Inherits from sam::HackingStrategy","title":"sam::SubjectiveOutlierRemoval"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#public-classes","text":"Name struct Parameters SubjectiveOutlierRemoval 's parameters.","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#public-functions","text":"Name SubjectiveOutlierRemoval () =default SubjectiveOutlierRemoval (const Parameters & p)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#public-attributes","text":"Name Parameters params PolicyChain stopping_condition","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#additional-inherited-members","text":"Public Functions inherited from sam::HackingStrategy Name virtual ~HackingStrategy () =0 Pure destructor of the Base class. This is important for proper deconstruction of Derived classes. HackingStrategy () void operator() ( Experiment * experiment) float defensibility () const float prevalence () const HackingStage stage () const HackingTarget target () const std::unique_ptr< HackingStrategy > build (json & hacking_strategy_config) Factory method for building a HackingStrategy . Public Attributes inherited from sam::HackingStrategy Name sol::state lua std::optional< float > defensibility_ std::optional< float > prevalence_ HackingStage stage_ HackingTarget target_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#detailed-description","text":"class sam :: SubjectiveOutlierRemoval ; The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. See : ResearchStrategy","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#function-subjectiveoutlierremoval","text":"SubjectiveOutlierRemoval () = default","title":"function SubjectiveOutlierRemoval"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#function-subjectiveoutlierremoval_1","text":"inline explicit SubjectiveOutlierRemoval ( const Parameters & p )","title":"function SubjectiveOutlierRemoval"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#variable-params","text":"Parameters params ;","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_subjective_outlier_removal/#variable-stopping_condition","text":"PolicyChain stopping_condition ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stopping_condition"},{"location":"doxygen/Classes/classsam_1_1_submission/","text":"sam::Submission \u00b6 Public Functions \u00b6 Name bool isSig () const bool isHacked () const bool isCandidate () const std::vector< std::string > Columns () Somewhat of a buffer for storing and returning a csv rows. Submission () =default Submission ( Experiment & e, const int & index) Submission (int sim_id, int expr_id, int rep_id, int pub_id, DependentVariable dv) ~Submission () =default Public Attributes \u00b6 Name int simid Simulation ID. int exprid Experiment ID. int repid Replication ID. int pubid Publication ID. DependentVariable dv_ Public Functions Documentation \u00b6 function isSig \u00b6 inline bool isSig () const function isHacked \u00b6 inline bool isHacked () const function isCandidate \u00b6 inline bool isCandidate () const function Columns \u00b6 static std :: vector < std :: string > Columns () Somewhat of a buffer for storing and returning a csv rows. function Submission \u00b6 Submission () = default function Submission \u00b6 Submission ( Experiment & e , const int & index ) function Submission \u00b6 Submission ( int sim_id , int expr_id , int rep_id , int pub_id , DependentVariable dv ) function ~Submission \u00b6 ~ Submission () = default Public Attributes Documentation \u00b6 variable simid \u00b6 int simid { 0 }; Simulation ID. variable exprid \u00b6 int exprid { 0 }; Experiment ID. variable repid \u00b6 int repid { 0 }; Replication ID. variable pubid \u00b6 int pubid { 0 }; Publication ID. variable dv_ \u00b6 DependentVariable dv_ ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::Submission"},{"location":"doxygen/Classes/classsam_1_1_submission/#samsubmission","text":"","title":"sam::Submission"},{"location":"doxygen/Classes/classsam_1_1_submission/#public-functions","text":"Name bool isSig () const bool isHacked () const bool isCandidate () const std::vector< std::string > Columns () Somewhat of a buffer for storing and returning a csv rows. Submission () =default Submission ( Experiment & e, const int & index) Submission (int sim_id, int expr_id, int rep_id, int pub_id, DependentVariable dv) ~Submission () =default","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_submission/#public-attributes","text":"Name int simid Simulation ID. int exprid Experiment ID. int repid Replication ID. int pubid Publication ID. DependentVariable dv_","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_submission/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-issig","text":"inline bool isSig () const","title":"function isSig"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-ishacked","text":"inline bool isHacked () const","title":"function isHacked"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-iscandidate","text":"inline bool isCandidate () const","title":"function isCandidate"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-columns","text":"static std :: vector < std :: string > Columns () Somewhat of a buffer for storing and returning a csv rows.","title":"function Columns"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-submission","text":"Submission () = default","title":"function Submission"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-submission_1","text":"Submission ( Experiment & e , const int & index )","title":"function Submission"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-submission_2","text":"Submission ( int sim_id , int expr_id , int rep_id , int pub_id , DependentVariable dv )","title":"function Submission"},{"location":"doxygen/Classes/classsam_1_1_submission/#function-submission_3","text":"~ Submission () = default","title":"function ~Submission"},{"location":"doxygen/Classes/classsam_1_1_submission/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_submission/#variable-simid","text":"int simid { 0 }; Simulation ID.","title":"variable simid"},{"location":"doxygen/Classes/classsam_1_1_submission/#variable-exprid","text":"int exprid { 0 }; Experiment ID.","title":"variable exprid"},{"location":"doxygen/Classes/classsam_1_1_submission/#variable-repid","text":"int repid { 0 }; Replication ID.","title":"variable repid"},{"location":"doxygen/Classes/classsam_1_1_submission/#variable-pubid","text":"int pubid { 0 }; Publication ID.","title":"variable pubid"},{"location":"doxygen/Classes/classsam_1_1_submission/#variable-dv_","text":"DependentVariable dv_ ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable dv_"},{"location":"doxygen/Classes/classsam_1_1_t_test/","text":"sam::TTest \u00b6 Module: Test Strategies Declration of t-test. More... #include <TestStrategy.h> Inherits from sam::TestStrategy Public Classes \u00b6 Name struct Parameters struct ResultType Public Functions \u00b6 Name TTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType t_test (const arma::Row< float > & d1, const arma::Row< float > & d2, float alpha, TestStrategy::TestAlternative alternative) ResultType t_test (float Sm1, float Sd1, float Sn1, float Sm2, float Sd2, float Sn2, float alpha, TestStrategy::TestAlternative alternative, bool equal_var) std::pair< float, bool > compute_pvalue (float tstat, float df, float alpha, TestStrategy::TestAlternative alternative) ResultType single_sample_t_test (float M, float Sm, float Sd, unsigned Sn, float alpha, TestStrategy::TestAlternative alternative) ResultType two_samples_t_test_equal_sd (float Sm1, float Sd1, unsigned Sn1, float Sm2, float Sd2, unsigned Sn2, float alpha, TestStrategy::TestAlternative alternative) ResultType two_samples_t_test_unequal_sd (float Sm1, float Sd1, unsigned Sn1, float Sm2, float Sd2, unsigned Sn2, float alpha, TestStrategy::TestAlternative alternative) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_ Detailed Description \u00b6 class sam :: TTest ; Declration of t-test. The run() method will check the significance of the difference between two groups. In the current setup, every experiment->means is considered an effect size between a treatment group and a control group with the mean of zero. Therefore, computing the t-statistics and computing the p-value would be sufficient. This is technically an implementation of one sample t-test . Public Functions Documentation \u00b6 function TTest \u00b6 inline TTest ( const Parameters & p ) function run \u00b6 virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run function run \u00b6 inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run function t_test \u00b6 static ResultType t_test ( const arma :: Row < float > & d1 , const arma :: Row < float > & d2 , float alpha , TestStrategy :: TestAlternative alternative ) function t_test \u00b6 static ResultType t_test ( float Sm1 , float Sd1 , float Sn1 , float Sm2 , float Sd2 , float Sn2 , float alpha , TestStrategy :: TestAlternative alternative , bool equal_var ) function compute_pvalue \u00b6 static std :: pair < float , bool > compute_pvalue ( float tstat , float df , float alpha , TestStrategy :: TestAlternative alternative ) function single_sample_t_test \u00b6 static ResultType single_sample_t_test ( float M , float Sm , float Sd , unsigned Sn , float alpha , TestStrategy :: TestAlternative alternative ) Parameters : M True Mean. Sm Sample Mean. Sd Sample Standard Deviation. Sn Sample Size. alpha Significance Level. Return : TTest::ResultType Note : Obtained from Boost Library Example . A Students t test applied to a single set of data. We are testing the null hypothesis that the true mean of the sample is M, and that any variation is down to chance. We can also test the alternative hypothesis that any difference is not down to chance function two_samples_t_test_equal_sd \u00b6 static ResultType two_samples_t_test_equal_sd ( float Sm1 , float Sd1 , unsigned Sn1 , float Sm2 , float Sd2 , unsigned Sn2 , float alpha , TestStrategy :: TestAlternative alternative ) Parameters : Sm1 Sample Mean 1. Sd1 Sample Standard Deviation 1. Sn1 Sample Size 1. Sm2 Sample Mean 2. Sd2 Sample Standard Deviation 2. Sn2 Sample Size 2. alpha Significance Level. Return : TTest::ResultType Note : Obtained from Boost Library Example . A Students t test applied to two sets of data. We are testing the null hypothesis that the two samples have the same mean and that any difference if due to chance. function two_samples_t_test_unequal_sd \u00b6 static ResultType two_samples_t_test_unequal_sd ( float Sm1 , float Sd1 , unsigned Sn1 , float Sm2 , float Sd2 , unsigned Sn2 , float alpha , TestStrategy :: TestAlternative alternative ) Parameters : Sm1 Sample Mean 1. Sd1 Sample Standard Deviation 1. Sn1 Sample Size 1. Sm2 Sample Mean 2. Sd2 Sample Standard Deviation 2. Sn2 Sample Size 2. alpha Significance Level. Return : TTest::ResultType Note : Obtained from Boost Library Example . A Students t test applied to two sets of data with unequal variance. We are testing the null hypothesis that the two samples have the same mean and that any difference is due to chance. Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::TTest"},{"location":"doxygen/Classes/classsam_1_1_t_test/#samttest","text":"Module: Test Strategies Declration of t-test. More... #include <TestStrategy.h> Inherits from sam::TestStrategy","title":"sam::TTest"},{"location":"doxygen/Classes/classsam_1_1_t_test/#public-classes","text":"Name struct Parameters struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_t_test/#public-functions","text":"Name TTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType t_test (const arma::Row< float > & d1, const arma::Row< float > & d2, float alpha, TestStrategy::TestAlternative alternative) ResultType t_test (float Sm1, float Sd1, float Sn1, float Sm2, float Sd2, float Sn2, float alpha, TestStrategy::TestAlternative alternative, bool equal_var) std::pair< float, bool > compute_pvalue (float tstat, float df, float alpha, TestStrategy::TestAlternative alternative) ResultType single_sample_t_test (float M, float Sm, float Sd, unsigned Sn, float alpha, TestStrategy::TestAlternative alternative) ResultType two_samples_t_test_equal_sd (float Sm1, float Sd1, unsigned Sn1, float Sm2, float Sd2, unsigned Sn2, float alpha, TestStrategy::TestAlternative alternative) ResultType two_samples_t_test_unequal_sd (float Sm1, float Sd1, unsigned Sn1, float Sm2, float Sd2, unsigned Sn2, float alpha, TestStrategy::TestAlternative alternative)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_t_test/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_t_test/#additional-inherited-members","text":"Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_t_test/#detailed-description","text":"class sam :: TTest ; Declration of t-test. The run() method will check the significance of the difference between two groups. In the current setup, every experiment->means is considered an effect size between a treatment group and a control group with the mean of zero. Therefore, computing the t-statistics and computing the p-value would be sufficient. This is technically an implementation of one sample t-test .","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_t_test/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-ttest","text":"inline TTest ( const Parameters & p )","title":"function TTest"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-run","text":"virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-run_1","text":"inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-t_test","text":"static ResultType t_test ( const arma :: Row < float > & d1 , const arma :: Row < float > & d2 , float alpha , TestStrategy :: TestAlternative alternative )","title":"function t_test"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-t_test_1","text":"static ResultType t_test ( float Sm1 , float Sd1 , float Sn1 , float Sm2 , float Sd2 , float Sn2 , float alpha , TestStrategy :: TestAlternative alternative , bool equal_var )","title":"function t_test"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-compute_pvalue","text":"static std :: pair < float , bool > compute_pvalue ( float tstat , float df , float alpha , TestStrategy :: TestAlternative alternative )","title":"function compute_pvalue"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-single_sample_t_test","text":"static ResultType single_sample_t_test ( float M , float Sm , float Sd , unsigned Sn , float alpha , TestStrategy :: TestAlternative alternative ) Parameters : M True Mean. Sm Sample Mean. Sd Sample Standard Deviation. Sn Sample Size. alpha Significance Level. Return : TTest::ResultType Note : Obtained from Boost Library Example . A Students t test applied to a single set of data. We are testing the null hypothesis that the true mean of the sample is M, and that any variation is down to chance. We can also test the alternative hypothesis that any difference is not down to chance","title":"function single_sample_t_test"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-two_samples_t_test_equal_sd","text":"static ResultType two_samples_t_test_equal_sd ( float Sm1 , float Sd1 , unsigned Sn1 , float Sm2 , float Sd2 , unsigned Sn2 , float alpha , TestStrategy :: TestAlternative alternative ) Parameters : Sm1 Sample Mean 1. Sd1 Sample Standard Deviation 1. Sn1 Sample Size 1. Sm2 Sample Mean 2. Sd2 Sample Standard Deviation 2. Sn2 Sample Size 2. alpha Significance Level. Return : TTest::ResultType Note : Obtained from Boost Library Example . A Students t test applied to two sets of data. We are testing the null hypothesis that the two samples have the same mean and that any difference if due to chance.","title":"function two_samples_t_test_equal_sd"},{"location":"doxygen/Classes/classsam_1_1_t_test/#function-two_samples_t_test_unequal_sd","text":"static ResultType two_samples_t_test_unequal_sd ( float Sm1 , float Sd1 , unsigned Sn1 , float Sm2 , float Sd2 , unsigned Sn2 , float alpha , TestStrategy :: TestAlternative alternative ) Parameters : Sm1 Sample Mean 1. Sd1 Sample Standard Deviation 1. Sn1 Sample Size 1. Sm2 Sample Mean 2. Sd2 Sample Standard Deviation 2. Sn2 Sample Size 2. alpha Significance Level. Return : TTest::ResultType Note : Obtained from Boost Library Example . A Students t test applied to two sets of data with unequal variance. We are testing the null hypothesis that the two samples have the same mean and that any difference is due to chance.","title":"function two_samples_t_test_unequal_sd"},{"location":"doxygen/Classes/classsam_1_1_t_test/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_t_test/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/","text":"sam::TestOfObsOverExptSig \u00b6 Module: Meta Analysis Methods Test of Excess of Significant Findings. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis Public Classes \u00b6 Name struct Parameters struct ResultType Public Functions \u00b6 Name TestOfObsOverExptSig () =default TestOfObsOverExptSig (const Parameters & p) virtual void estimate ( Journal * journal) ResultType TES (const arma::Row< float > & sigs, const arma::Row< float > & ni, float beta, float alpha) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Public Functions Documentation \u00b6 function TestOfObsOverExptSig \u00b6 TestOfObsOverExptSig () = default function TestOfObsOverExptSig \u00b6 inline TestOfObsOverExptSig ( const Parameters & p ) function estimate \u00b6 virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate function TES \u00b6 static ResultType TES ( const arma :: Row < float > & sigs , const arma :: Row < float > & ni , float beta , float alpha ) If E is absolute zero, I'm adding some noise that I don't have to deal with the explosion A is most likely different from what R spit out, due to brutal rounding that's happening in R. Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::TestOfObsOverExptSig"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#samtestofobsoverexptsig","text":"Module: Meta Analysis Methods Test of Excess of Significant Findings. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis","title":"sam::TestOfObsOverExptSig"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#public-classes","text":"Name struct Parameters struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#public-functions","text":"Name TestOfObsOverExptSig () =default TestOfObsOverExptSig (const Parameters & p) virtual void estimate ( Journal * journal) ResultType TES (const arma::Row< float > & sigs, const arma::Row< float > & ni, float beta, float alpha)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#additional-inherited-members","text":"Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#function-testofobsoverexptsig","text":"TestOfObsOverExptSig () = default","title":"function TestOfObsOverExptSig"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#function-testofobsoverexptsig_1","text":"inline TestOfObsOverExptSig ( const Parameters & p )","title":"function TestOfObsOverExptSig"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#function-estimate","text":"virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#function-tes","text":"static ResultType TES ( const arma :: Row < float > & sigs , const arma :: Row < float > & ni , float beta , float alpha ) If E is absolute zero, I'm adding some noise that I don't have to deal with the explosion A is most likely different from what R spit out, due to brutal rounding that's happening in R.","title":"function TES"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_test_of_obs_over_expt_sig/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/","text":"sam::TestStrategy \u00b6 Abstract class for defining test strategies. More... #include <TestStrategy.h> Inherited by sam::FTest , sam::TTest , sam::WilcoxonTest , sam::YuenTest Public Types \u00b6 Name enum TestMethod enum TestAlternative Public Functions \u00b6 Name virtual ~TestStrategy () =0 virtual void run ( Experiment * experiment) =0 virtual void run ( DependentVariable & group_1, DependentVariable & group_2) =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes \u00b6 Name float alpha_ Detailed Description \u00b6 class sam :: TestStrategy ; Abstract class for defining test strategies. Statistical test strategies will investigate if there is a meaningful difference between means of two samples. Every test strategy should provide a run() method. The run() method will accept a pointer to the experiment and update necessary variables, e.g., statistics & p-value . Public Types Documentation \u00b6 enum TestMethod \u00b6 Enumerator Value Description TTest TTest . FTest FTest . YuenTest YuenTest . WilcoxonTest WilcoxonTest . Specifying the significant testing method enum TestAlternative \u00b6 Enumerator Value Description Less Greater TwoSided Specify the side of the test Public Functions Documentation \u00b6 function ~TestStrategy \u00b6 virtual ~ TestStrategy () = 0 function run \u00b6 virtual void run ( Experiment * experiment ) = 0 Reimplemented by : sam::TTest::run , sam::FTest::run , sam::YuenTest::run , sam::WilcoxonTest::run function run \u00b6 virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) = 0 Reimplemented by : sam::TTest::run , sam::FTest::run , sam::YuenTest::run , sam::WilcoxonTest::run function alpha \u00b6 inline virtual float alpha () function build \u00b6 static std :: unique_ptr < TestStrategy > build ( json & test_strategy_config ) Public Attributes Documentation \u00b6 variable alpha_ \u00b6 float alpha_ ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::TestStrategy"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#samteststrategy","text":"Abstract class for defining test strategies. More... #include <TestStrategy.h> Inherited by sam::FTest , sam::TTest , sam::WilcoxonTest , sam::YuenTest","title":"sam::TestStrategy"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#public-types","text":"Name enum TestMethod enum TestAlternative","title":"Public Types"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#public-functions","text":"Name virtual ~TestStrategy () =0 virtual void run ( Experiment * experiment) =0 virtual void run ( DependentVariable & group_1, DependentVariable & group_2) =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#public-attributes","text":"Name float alpha_","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#detailed-description","text":"class sam :: TestStrategy ; Abstract class for defining test strategies. Statistical test strategies will investigate if there is a meaningful difference between means of two samples. Every test strategy should provide a run() method. The run() method will accept a pointer to the experiment and update necessary variables, e.g., statistics & p-value .","title":"Detailed Description"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#enum-testmethod","text":"Enumerator Value Description TTest TTest . FTest FTest . YuenTest YuenTest . WilcoxonTest WilcoxonTest . Specifying the significant testing method","title":"enum TestMethod"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#enum-testalternative","text":"Enumerator Value Description Less Greater TwoSided Specify the side of the test","title":"enum TestAlternative"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#function-teststrategy","text":"virtual ~ TestStrategy () = 0","title":"function ~TestStrategy"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#function-run","text":"virtual void run ( Experiment * experiment ) = 0 Reimplemented by : sam::TTest::run , sam::FTest::run , sam::YuenTest::run , sam::WilcoxonTest::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#function-run_1","text":"virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) = 0 Reimplemented by : sam::TTest::run , sam::FTest::run , sam::YuenTest::run , sam::WilcoxonTest::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#function-alpha","text":"inline virtual float alpha ()","title":"function alpha"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#function-build","text":"static std :: unique_ptr < TestStrategy > build ( json & test_strategy_config )","title":"function build"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_test_strategy/#variable-alpha_","text":"float alpha_ ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable alpha_"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/","text":"sam::TrimAndFill \u00b6 Module: Meta Analysis Methods Trim and Fill Publication Bias Test. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis Public Classes \u00b6 Name struct Parameters Parameters of the TrimAndFill . struct ResultType Public Functions \u00b6 Name TrimAndFill () =default TrimAndFill (const Parameters & p) virtual void estimate ( Journal * journal) ResultType TF (arma::Row< float > yi, arma::Row< float > vi, arma::Row< float > ni, const Parameters & params) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name) Public Functions Documentation \u00b6 function TrimAndFill \u00b6 TrimAndFill () = default function TrimAndFill \u00b6 inline TrimAndFill ( const Parameters & p ) function estimate \u00b6 virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate function TF \u00b6 static ResultType TF ( arma :: Row < float > yi , arma :: Row < float > vi , arma :: Row < float > ni , const Parameters & params ) Determining the side flip data if examining right side sort data by increasing yi centered values; Todoties_method=\"first\"); // ranked absolute centered values; signed ranked centered values; estimate the number of missing studies with the L0 estimator estimate the number of missing studies with the Q0 estimator round k0 and make sure that k0 is non-negative ---------------\u2014 Filling and estimating -------------\u2014 if estimated number of missing studies is > 0 flip data back if side is right create filled-in data set apply limits if specified Todo: to be implemented fit model with imputed data Todoneed to be integrated! Adjustment for p_k0 TodoThis imbue can be improved TodoStill need to report the p_k0 Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::TrimAndFill"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#samtrimandfill","text":"Module: Meta Analysis Methods Trim and Fill Publication Bias Test. #include <MetaAnalysis.h> Inherits from sam::MetaAnalysis","title":"sam::TrimAndFill"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#public-classes","text":"Name struct Parameters Parameters of the TrimAndFill . struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#public-functions","text":"Name TrimAndFill () =default TrimAndFill (const Parameters & p) virtual void estimate ( Journal * journal) ResultType TF (arma::Row< float > yi, arma::Row< float > vi, arma::Row< float > ni, const Parameters & params)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#additional-inherited-members","text":"Public Functions inherited from sam::MetaAnalysis Name virtual ~MetaAnalysis () =0 std::unique_ptr< MetaAnalysis > build (std::string name) std::unique_ptr< MetaAnalysis > build (const json & config) std::vector< std::string > Columns (std::string name)","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#function-trimandfill","text":"TrimAndFill () = default","title":"function TrimAndFill"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#function-trimandfill_1","text":"inline TrimAndFill ( const Parameters & p )","title":"function TrimAndFill"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#function-estimate","text":"virtual void estimate ( Journal * journal ) Reimplements : sam::MetaAnalysis::estimate","title":"function estimate"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#function-tf","text":"static ResultType TF ( arma :: Row < float > yi , arma :: Row < float > vi , arma :: Row < float > ni , const Parameters & params ) Determining the side flip data if examining right side sort data by increasing yi centered values; Todoties_method=\"first\"); // ranked absolute centered values; signed ranked centered values; estimate the number of missing studies with the L0 estimator estimate the number of missing studies with the Q0 estimator round k0 and make sure that k0 is non-negative ---------------\u2014 Filling and estimating -------------\u2014 if estimated number of missing studies is > 0 flip data back if side is right create filled-in data set apply limits if specified Todo: to be implemented fit model with imputed data Todoneed to be integrated! Adjustment for p_k0 TodoThis imbue can be improved TodoStill need to report the p_k0","title":"function TF"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_trim_and_fill/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/","text":"sam::WilcoxonTest \u00b6 Module: Test Strategies Inherits from sam::TestStrategy Public Classes \u00b6 Name struct Parameters struct ResultType Public Functions \u00b6 Name WilcoxonTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType wilcoxon_test (const arma::Row< float > & x, const arma::Row< float > & y, float alpha, float use_continuity, const TestStrategy::TestAlternative alternative) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_ Public Functions Documentation \u00b6 function WilcoxonTest \u00b6 inline WilcoxonTest ( const Parameters & p ) function run \u00b6 virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run function run \u00b6 inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run function wilcoxon_test \u00b6 static ResultType wilcoxon_test ( const arma :: Row < float > & x , const arma :: Row < float > & y , float alpha , float use_continuity , const TestStrategy :: TestAlternative alternative ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::WilcoxonTest"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#samwilcoxontest","text":"Module: Test Strategies Inherits from sam::TestStrategy","title":"sam::WilcoxonTest"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#public-classes","text":"Name struct Parameters struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#public-functions","text":"Name WilcoxonTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType wilcoxon_test (const arma::Row< float > & x, const arma::Row< float > & y, float alpha, float use_continuity, const TestStrategy::TestAlternative alternative)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#additional-inherited-members","text":"Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#function-wilcoxontest","text":"inline WilcoxonTest ( const Parameters & p )","title":"function WilcoxonTest"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#function-run","text":"virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#function-run_1","text":"inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#function-wilcoxon_test","text":"static ResultType wilcoxon_test ( const arma :: Row < float > & x , const arma :: Row < float > & y , float alpha , float use_continuity , const TestStrategy :: TestAlternative alternative )","title":"function wilcoxon_test"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_wilcoxon_test/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/","text":"sam::YuenTest \u00b6 Module: Test Strategies Inherits from sam::TestStrategy Public Classes \u00b6 Name struct Parameters struct ResultType Public Functions \u00b6 Name YuenTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType yuen_t_test_one_sample (const arma::Row< float > & x, float alpha, const TestStrategy::TestAlternative alternative, float trim, float mu) ResultType yuen_t_test_paired (const arma::Row< float > & x, const arma::Row< float > & y, float alpha, const TestStrategy::TestAlternative alternative, float trim, float mu) ResultType yuen_t_test_two_samples (const arma::Row< float > & x, const arma::Row< float > & y, float alpha, const TestStrategy::TestAlternative alternative, float trim, float mu) Public Attributes \u00b6 Name Parameters params Additional inherited members \u00b6 Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_ Public Functions Documentation \u00b6 function YuenTest \u00b6 inline YuenTest ( const Parameters & p ) function run \u00b6 virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run function run \u00b6 inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run function yuen_t_test_one_sample \u00b6 static ResultType yuen_t_test_one_sample ( const arma :: Row < float > & x , float alpha , const TestStrategy :: TestAlternative alternative , float trim , float mu ) function yuen_t_test_paired \u00b6 static ResultType yuen_t_test_paired ( const arma :: Row < float > & x , const arma :: Row < float > & y , float alpha , const TestStrategy :: TestAlternative alternative , float trim , float mu ) function yuen_t_test_two_samples \u00b6 static ResultType yuen_t_test_two_samples ( const arma :: Row < float > & x , const arma :: Row < float > & y , float alpha , const TestStrategy :: TestAlternative alternative , float trim , float mu ) Public Attributes Documentation \u00b6 variable params \u00b6 Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::YuenTest"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#samyuentest","text":"Module: Test Strategies Inherits from sam::TestStrategy","title":"sam::YuenTest"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#public-classes","text":"Name struct Parameters struct ResultType","title":"Public Classes"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#public-functions","text":"Name YuenTest (const Parameters & p) virtual void run ( Experiment * experiment) override virtual void run ( DependentVariable & group_1, DependentVariable & group_2) override ResultType yuen_t_test_one_sample (const arma::Row< float > & x, float alpha, const TestStrategy::TestAlternative alternative, float trim, float mu) ResultType yuen_t_test_paired (const arma::Row< float > & x, const arma::Row< float > & y, float alpha, const TestStrategy::TestAlternative alternative, float trim, float mu) ResultType yuen_t_test_two_samples (const arma::Row< float > & x, const arma::Row< float > & y, float alpha, const TestStrategy::TestAlternative alternative, float trim, float mu)","title":"Public Functions"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#public-attributes","text":"Name Parameters params","title":"Public Attributes"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#additional-inherited-members","text":"Public Types inherited from sam::TestStrategy Name enum TestMethod enum TestAlternative Public Functions inherited from sam::TestStrategy Name virtual ~TestStrategy () =0 virtual float alpha () std::unique_ptr< TestStrategy > build (json & test_strategy_config) Public Attributes inherited from sam::TestStrategy Name float alpha_","title":"Additional inherited members"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#function-yuentest","text":"inline YuenTest ( const Parameters & p )","title":"function YuenTest"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#function-run","text":"virtual void run ( Experiment * experiment ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#function-run_1","text":"inline virtual void run ( DependentVariable & group_1 , DependentVariable & group_2 ) override Reimplements : sam::TestStrategy::run","title":"function run"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#function-yuen_t_test_one_sample","text":"static ResultType yuen_t_test_one_sample ( const arma :: Row < float > & x , float alpha , const TestStrategy :: TestAlternative alternative , float trim , float mu )","title":"function yuen_t_test_one_sample"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#function-yuen_t_test_paired","text":"static ResultType yuen_t_test_paired ( const arma :: Row < float > & x , const arma :: Row < float > & y , float alpha , const TestStrategy :: TestAlternative alternative , float trim , float mu )","title":"function yuen_t_test_paired"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#function-yuen_t_test_two_samples","text":"static ResultType yuen_t_test_two_samples ( const arma :: Row < float > & x , const arma :: Row < float > & y , float alpha , const TestStrategy :: TestAlternative alternative , float trim , float mu )","title":"function yuen_t_test_two_samples"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/classsam_1_1_yuen_test/#variable-params","text":"Parameters params ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable params"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/","text":"fmt::formatter< sam::Experiment > \u00b6 Public Functions \u00b6 Name constexpr auto parse (format_parse_context & ctx) template \\<typename FormatContext > auto format (const sam::Experiment & e, FormatContext & ctx) Public Attributes \u00b6 Name char presentation Public Functions Documentation \u00b6 function parse \u00b6 inline constexpr auto parse ( format_parse_context & ctx ) function format \u00b6 template < typename FormatContext > inline auto format ( const sam :: Experiment & e , FormatContext & ctx ) Public Attributes Documentation \u00b6 variable presentation \u00b6 char presentation = 'f' ; Updated on 22 November 2020 at 21:10:19 CET","title":"fmt::formatter< sam::Experiment >"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#fmtformatter-samexperiment","text":"","title":"fmt::formatter&lt; sam::Experiment &gt;"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#public-functions","text":"Name constexpr auto parse (format_parse_context & ctx) template \\<typename FormatContext > auto format (const sam::Experiment & e, FormatContext & ctx)","title":"Public Functions"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#public-attributes","text":"Name char presentation","title":"Public Attributes"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#function-parse","text":"inline constexpr auto parse ( format_parse_context & ctx )","title":"function parse"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#function-format","text":"template < typename FormatContext > inline auto format ( const sam :: Experiment & e , FormatContext & ctx )","title":"function format"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_experiment_01_4/#variable-presentation","text":"char presentation = 'f' ; Updated on 22 November 2020 at 21:10:19 CET","title":"variable presentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/","text":"fmt::formatter< sam::Group > \u00b6 Public Functions \u00b6 Name constexpr auto parse (format_parse_context & ctx) template \\<typename FormatContext > auto format (const sam::Group & g, FormatContext & ctx) Public Attributes \u00b6 Name char presentation Public Functions Documentation \u00b6 function parse \u00b6 inline constexpr auto parse ( format_parse_context & ctx ) function format \u00b6 template < typename FormatContext > inline auto format ( const sam :: Group & g , FormatContext & ctx ) Public Attributes Documentation \u00b6 variable presentation \u00b6 char presentation = 'f' ; Updated on 22 November 2020 at 21:10:19 CET","title":"fmt::formatter< sam::Group >"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#fmtformatter-samgroup","text":"","title":"fmt::formatter&lt; sam::Group &gt;"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#public-functions","text":"Name constexpr auto parse (format_parse_context & ctx) template \\<typename FormatContext > auto format (const sam::Group & g, FormatContext & ctx)","title":"Public Functions"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#public-attributes","text":"Name char presentation","title":"Public Attributes"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#function-parse","text":"inline constexpr auto parse ( format_parse_context & ctx )","title":"function parse"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#function-format","text":"template < typename FormatContext > inline auto format ( const sam :: Group & g , FormatContext & ctx )","title":"function format"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_group_01_4/#variable-presentation","text":"char presentation = 'f' ; Updated on 22 November 2020 at 21:10:19 CET","title":"variable presentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_01_4/","text":"fmt::formatter< sam::Policy > \u00b6 Public Functions \u00b6 Name template \\<typename ParseContext > constexpr auto parse (ParseContext & ctx) template \\<typename FormatContext > auto format (sam::Policy const & policy, FormatContext & ctx) Public Functions Documentation \u00b6 function parse \u00b6 template < typename ParseContext > inline constexpr auto parse ( ParseContext & ctx ) function format \u00b6 template < typename FormatContext > inline auto format ( sam :: Policy const & policy , FormatContext & ctx ) Updated on 22 November 2020 at 21:10:19 CET","title":"fmt::formatter< sam::Policy >"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_01_4/#fmtformatter-sampolicy","text":"","title":"fmt::formatter&lt; sam::Policy &gt;"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_01_4/#public-functions","text":"Name template \\<typename ParseContext > constexpr auto parse (ParseContext & ctx) template \\<typename FormatContext > auto format (sam::Policy const & policy, FormatContext & ctx)","title":"Public Functions"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_01_4/#function-parse","text":"template < typename ParseContext > inline constexpr auto parse ( ParseContext & ctx )","title":"function parse"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_01_4/#function-format","text":"template < typename FormatContext > inline auto format ( sam :: Policy const & policy , FormatContext & ctx ) Updated on 22 November 2020 at 21:10:19 CET","title":"function format"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_chain_01_4/","text":"fmt::formatter< sam::PolicyChain > \u00b6 Public Functions \u00b6 Name template \\<typename ParseContext > constexpr auto parse (ParseContext & ctx) template \\<typename FormatContext > auto format ( sam::PolicyChain const & pchain, FormatContext & ctx) Public Functions Documentation \u00b6 function parse \u00b6 template < typename ParseContext > inline constexpr auto parse ( ParseContext & ctx ) function format \u00b6 template < typename FormatContext > inline auto format ( sam :: PolicyChain const & pchain , FormatContext & ctx ) Updated on 22 November 2020 at 21:10:19 CET","title":"fmt::formatter< sam::PolicyChain >"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_chain_01_4/#fmtformatter-sampolicychain","text":"","title":"fmt::formatter&lt; sam::PolicyChain &gt;"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_chain_01_4/#public-functions","text":"Name template \\<typename ParseContext > constexpr auto parse (ParseContext & ctx) template \\<typename FormatContext > auto format ( sam::PolicyChain const & pchain, FormatContext & ctx)","title":"Public Functions"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_chain_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_chain_01_4/#function-parse","text":"template < typename ParseContext > inline constexpr auto parse ( ParseContext & ctx )","title":"function parse"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_policy_chain_01_4/#function-format","text":"template < typename FormatContext > inline auto format ( sam :: PolicyChain const & pchain , FormatContext & ctx ) Updated on 22 November 2020 at 21:10:19 CET","title":"function format"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/","text":"fmt::formatter< sam::Submission > \u00b6 Public Functions \u00b6 Name constexpr auto parse (format_parse_context & ctx) template \\<typename FormatContext > auto format (const sam::Submission & s, FormatContext & ctx) Public Attributes \u00b6 Name char presentation Public Functions Documentation \u00b6 function parse \u00b6 inline constexpr auto parse ( format_parse_context & ctx ) function format \u00b6 template < typename FormatContext > inline auto format ( const sam :: Submission & s , FormatContext & ctx ) Public Attributes Documentation \u00b6 variable presentation \u00b6 char presentation = 'f' ; Updated on 22 November 2020 at 21:10:19 CET","title":"fmt::formatter< sam::Submission >"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#fmtformatter-samsubmission","text":"","title":"fmt::formatter&lt; sam::Submission &gt;"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#public-functions","text":"Name constexpr auto parse (format_parse_context & ctx) template \\<typename FormatContext > auto format (const sam::Submission & s, FormatContext & ctx)","title":"Public Functions"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#public-attributes","text":"Name char presentation","title":"Public Attributes"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#function-parse","text":"inline constexpr auto parse ( format_parse_context & ctx )","title":"function parse"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#function-format","text":"template < typename FormatContext > inline auto format ( const sam :: Submission & s , FormatContext & ctx )","title":"function format"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structfmt_1_1formatter_3_01sam_1_1_submission_01_4/#variable-presentation","text":"char presentation = 'f' ; Updated on 22 November 2020 at 21:10:19 CET","title":"variable presentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01_multivariate_distribution_01_4/","text":"nlohmann::adl_serializer< MultivariateDistribution > \u00b6 Public Functions \u00b6 Name void to_json (json & j, const MultivariateDistribution & mdistro) void from_json (const json & j, MultivariateDistribution & mdistro) Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const MultivariateDistribution & mdistro ) function from_json \u00b6 static inline void from_json ( const json & j , MultivariateDistribution & mdistro ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< MultivariateDistribution >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01_multivariate_distribution_01_4/#nlohmannadl_serializer-multivariatedistribution","text":"","title":"nlohmann::adl_serializer&lt; MultivariateDistribution &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01_multivariate_distribution_01_4/#public-functions","text":"Name void to_json (json & j, const MultivariateDistribution & mdistro) void from_json (const json & j, MultivariateDistribution & mdistro)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01_multivariate_distribution_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01_multivariate_distribution_01_4/#function-to_json","text":"static inline void to_json ( json & j , const MultivariateDistribution & mdistro )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01_multivariate_distribution_01_4/#function-from_json","text":"static inline void from_json ( const json & j , MultivariateDistribution & mdistro ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/","text":"nlohmann::adl_serializer< arma::Col< T > > \u00b6 More... Public Functions \u00b6 Name void to_json (json & j, const arma::Col< T > & col) void from_json (const json & j, arma::Col< T > & col) Detailed Description \u00b6 template < typename T > struct nlohmann :: adl_serializer < arma :: Col < T > > ; Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const arma :: Col < T > & col ) function from_json \u00b6 static inline void from_json ( const json & j , arma :: Col < T > & col ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< arma::Col< T > >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/#nlohmannadl_serializer-armacol-t","text":"More...","title":"nlohmann::adl_serializer&lt; arma::Col&lt; T &gt; &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/#public-functions","text":"Name void to_json (json & j, const arma::Col< T > & col) void from_json (const json & j, arma::Col< T > & col)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/#detailed-description","text":"template < typename T > struct nlohmann :: adl_serializer < arma :: Col < T > > ;","title":"Detailed Description"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/#function-to_json","text":"static inline void to_json ( json & j , const arma :: Col < T > & col )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_col_3_01_t_01_4_01_4/#function-from_json","text":"static inline void from_json ( const json & j , arma :: Col < T > & col ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/","text":"nlohmann::adl_serializer< arma::Mat< T > > \u00b6 More... Public Functions \u00b6 Name void to_json (json & j, const arma::Mat< T > & mat) void from_json (const json & j, arma::Mat< T > & mat) Detailed Description \u00b6 template < typename T > struct nlohmann :: adl_serializer < arma :: Mat < T > > ; Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const arma :: Mat < T > & mat ) function from_json \u00b6 static inline void from_json ( const json & j , arma :: Mat < T > & mat ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< arma::Mat< T > >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/#nlohmannadl_serializer-armamat-t","text":"More...","title":"nlohmann::adl_serializer&lt; arma::Mat&lt; T &gt; &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/#public-functions","text":"Name void to_json (json & j, const arma::Mat< T > & mat) void from_json (const json & j, arma::Mat< T > & mat)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/#detailed-description","text":"template < typename T > struct nlohmann :: adl_serializer < arma :: Mat < T > > ;","title":"Detailed Description"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/#function-to_json","text":"static inline void to_json ( json & j , const arma :: Mat < T > & mat )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_mat_3_01_t_01_4_01_4/#function-from_json","text":"static inline void from_json ( const json & j , arma :: Mat < T > & mat ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/","text":"nlohmann::adl_serializer< arma::Row< T > > \u00b6 More... Public Functions \u00b6 Name void to_json (json & j, const arma::Row< T > & row) void from_json (const json & j, arma::Row< T > & row) Detailed Description \u00b6 template < typename T > struct nlohmann :: adl_serializer < arma :: Row < T > > ; Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const arma :: Row < T > & row ) function from_json \u00b6 static inline void from_json ( const json & j , arma :: Row < T > & row ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< arma::Row< T > >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/#nlohmannadl_serializer-armarow-t","text":"More...","title":"nlohmann::adl_serializer&lt; arma::Row&lt; T &gt; &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/#public-functions","text":"Name void to_json (json & j, const arma::Row< T > & row) void from_json (const json & j, arma::Row< T > & row)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/#detailed-description","text":"template < typename T > struct nlohmann :: adl_serializer < arma :: Row < T > > ;","title":"Detailed Description"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/#function-to_json","text":"static inline void to_json ( json & j , const arma :: Row < T > & row )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01arma_1_1_row_3_01_t_01_4_01_4/#function-from_json","text":"static inline void from_json ( const json & j , arma :: Row < T > & row ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/","text":"nlohmann::adl_serializer< baaraan::mvnorm_distribution< T > > \u00b6 More... Public Functions \u00b6 Name void to_json (json & j, const baaraan::mvnorm_distribution< T > & mdist) baaraan::mvnorm_distribution< T > from_json (const json & j) Detailed Description \u00b6 template < typename T > struct nlohmann :: adl_serializer < baaraan :: mvnorm_distribution < T > > ; Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const baaraan :: mvnorm_distribution < T > & mdist ) function from_json \u00b6 static inline baaraan :: mvnorm_distribution < T > from_json ( const json & j ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< baaraan::mvnorm_distribution< T > >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/#nlohmannadl_serializer-baaraanmvnorm_distribution-t","text":"More...","title":"nlohmann::adl_serializer&lt; baaraan::mvnorm_distribution&lt; T &gt; &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/#public-functions","text":"Name void to_json (json & j, const baaraan::mvnorm_distribution< T > & mdist) baaraan::mvnorm_distribution< T > from_json (const json & j)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/#detailed-description","text":"template < typename T > struct nlohmann :: adl_serializer < baaraan :: mvnorm_distribution < T > > ;","title":"Detailed Description"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/#function-to_json","text":"static inline void to_json ( json & j , const baaraan :: mvnorm_distribution < T > & mdist )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1mvnorm__distribution_3_01_t_01_4_01_4/#function-from_json","text":"static inline baaraan :: mvnorm_distribution < T > from_json ( const json & j ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/","text":"nlohmann::adl_serializer< baaraan::truncated_mvnorm_distribution< T > > \u00b6 More... Public Functions \u00b6 Name void to_json (json & j, const baaraan::truncated_mvnorm_distribution< T > & mdist) baaraan::truncated_mvnorm_distribution< T > from_json (const json & j) Detailed Description \u00b6 template < typename T > struct nlohmann :: adl_serializer < baaraan :: truncated_mvnorm_distribution < T > > ; Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const baaraan :: truncated_mvnorm_distribution < T > & mdist ) function from_json \u00b6 static inline baaraan :: truncated_mvnorm_distribution < T > from_json ( const json & j ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< baaraan::truncated_mvnorm_distribution< T > >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/#nlohmannadl_serializer-baaraantruncated_mvnorm_distribution-t","text":"More...","title":"nlohmann::adl_serializer&lt; baaraan::truncated_mvnorm_distribution&lt; T &gt; &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/#public-functions","text":"Name void to_json (json & j, const baaraan::truncated_mvnorm_distribution< T > & mdist) baaraan::truncated_mvnorm_distribution< T > from_json (const json & j)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/#detailed-description","text":"template < typename T > struct nlohmann :: adl_serializer < baaraan :: truncated_mvnorm_distribution < T > > ;","title":"Detailed Description"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/#function-to_json","text":"static inline void to_json ( json & j , const baaraan :: truncated_mvnorm_distribution < T > & mdist )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01baaraan_1_1truncated__mvnorm__distribution_3_01_t_01_4_01_4/#function-from_json","text":"static inline baaraan :: truncated_mvnorm_distribution < T > from_json ( const json & j ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/","text":"nlohmann::adl_serializer< sam::Parameter< T > > \u00b6 More... Public Functions \u00b6 Name void to_json (json & j, const sam::Parameter < T > & p) void from_json (const json & j, sam::Parameter < T > & p) Detailed Description \u00b6 template < typename T > struct nlohmann :: adl_serializer < sam :: Parameter < T > > ; Public Functions Documentation \u00b6 function to_json \u00b6 static inline void to_json ( json & j , const sam :: Parameter < T > & p ) function from_json \u00b6 static inline void from_json ( const json & j , sam :: Parameter < T > & p ) Updated on 22 November 2020 at 21:10:19 CET","title":"nlohmann::adl_serializer< sam::Parameter< T > >"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/#nlohmannadl_serializer-samparameter-t","text":"More...","title":"nlohmann::adl_serializer&lt; sam::Parameter&lt; T &gt; &gt;"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/#public-functions","text":"Name void to_json (json & j, const sam::Parameter < T > & p) void from_json (const json & j, sam::Parameter < T > & p)","title":"Public Functions"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/#detailed-description","text":"template < typename T > struct nlohmann :: adl_serializer < sam :: Parameter < T > > ;","title":"Detailed Description"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/#function-to_json","text":"static inline void to_json ( json & j , const sam :: Parameter < T > & p )","title":"function to_json"},{"location":"doxygen/Classes/structnlohmann_1_1adl__serializer_3_01sam_1_1_parameter_3_01_t_01_4_01_4/#function-from_json","text":"static inline void from_json ( const json & j , sam :: Parameter < T > & p ) Updated on 22 November 2020 at 21:10:19 CET","title":"function from_json"},{"location":"doxygen/Classes/structsam_1_1_condition_dropping_1_1_parameters/","text":"sam::ConditionDropping::Parameters \u00b6 Public Attributes \u00b6 Name HackingMethod name Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: ConditionDropping ; Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::ConditionDropping::Parameters"},{"location":"doxygen/Classes/structsam_1_1_condition_dropping_1_1_parameters/#samconditiondroppingparameters","text":"","title":"sam::ConditionDropping::Parameters"},{"location":"doxygen/Classes/structsam_1_1_condition_dropping_1_1_parameters/#public-attributes","text":"Name HackingMethod name","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_condition_dropping_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_condition_dropping_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: ConditionDropping ; Updated on 29 June 2021 at 16:13:46 CEST","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/","text":"sam::DefaultDecisionMaker::Parameters \u00b6 Public Attributes \u00b6 Name DecisionMethod name std::vector< std::vector< std::string > > initial_selection_policies_defs std::vector< std::string > submission_decision_policies_defs std::vector< std::vector< std::string > > between_hacks_selection_policies_defs std::vector< std::vector< std::string > > between_replications_selection_policies_defs std::vector< std::string > will_start_hacking_decision_policies_def std::vector< std::string > will_continue_replicating_decision_policy_def std::vector< std::string > stashing_policy_def Public Attributes Documentation \u00b6 variable name \u00b6 DecisionMethod name = DecisionMethod :: DefaultDecisionMaker ; variable initial_selection_policies_defs \u00b6 std :: vector < std :: vector < std :: string > > initial_selection_policies_defs ; variable submission_decision_policies_defs \u00b6 std :: vector < std :: string > submission_decision_policies_defs ; variable between_hacks_selection_policies_defs \u00b6 std :: vector < std :: vector < std :: string > > between_hacks_selection_policies_defs ; variable between_replications_selection_policies_defs \u00b6 std :: vector < std :: vector < std :: string > > between_replications_selection_policies_defs ; variable will_start_hacking_decision_policies_def \u00b6 std :: vector < std :: string > will_start_hacking_decision_policies_def ; variable will_continue_replicating_decision_policy_def \u00b6 std :: vector < std :: string > will_continue_replicating_decision_policy_def ; variable stashing_policy_def \u00b6 std :: vector < std :: string > stashing_policy_def ;","title":"sam::DefaultDecisionMaker::Parameters"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#samdefaultdecisionmakerparameters","text":"","title":"sam::DefaultDecisionMaker::Parameters"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#public-attributes","text":"Name DecisionMethod name std::vector< std::vector< std::string > > initial_selection_policies_defs std::vector< std::string > submission_decision_policies_defs std::vector< std::vector< std::string > > between_hacks_selection_policies_defs std::vector< std::vector< std::string > > between_replications_selection_policies_defs std::vector< std::string > will_start_hacking_decision_policies_def std::vector< std::string > will_continue_replicating_decision_policy_def std::vector< std::string > stashing_policy_def","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-name","text":"DecisionMethod name = DecisionMethod :: DefaultDecisionMaker ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-initial_selection_policies_defs","text":"std :: vector < std :: vector < std :: string > > initial_selection_policies_defs ;","title":"variable initial_selection_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-submission_decision_policies_defs","text":"std :: vector < std :: string > submission_decision_policies_defs ;","title":"variable submission_decision_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-between_hacks_selection_policies_defs","text":"std :: vector < std :: vector < std :: string > > between_hacks_selection_policies_defs ;","title":"variable between_hacks_selection_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-between_replications_selection_policies_defs","text":"std :: vector < std :: vector < std :: string > > between_replications_selection_policies_defs ;","title":"variable between_replications_selection_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-will_start_hacking_decision_policies_def","text":"std :: vector < std :: string > will_start_hacking_decision_policies_def ;","title":"variable will_start_hacking_decision_policies_def"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-will_continue_replicating_decision_policy_def","text":"std :: vector < std :: string > will_continue_replicating_decision_policy_def ;","title":"variable will_continue_replicating_decision_policy_def"},{"location":"doxygen/Classes/structsam_1_1_default_decision_maker_1_1_parameters/#variable-stashing_policy_def","text":"std :: vector < std :: string > stashing_policy_def ;","title":"variable stashing_policy_def"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/","text":"sam::DefaultResearchStrategy::Parameters \u00b6 Module: Parameters of the Research Strategies The parameters of the strategy. #include <ResearchStrategy.h> Public Attributes \u00b6 Name DecisionMethod name std::vector< std::vector< std::string > > initial_selection_policies_defs Initial Selection Policy . std::vector< std::string > will_not_start_hacking_decision_policies_def Will Start Hacking Decision Policy . std::vector< std::vector< std::string > > between_stashed_selection_policies_defs Between Stashed Selection Policy . std::vector< std::string > will_not_continue_replicating_decision_policy_def Will Continue Replicating Decision Policy . std::vector< std::vector< std::string > > between_replications_selection_policies_defs Between Replication Selection Policy . std::vector< std::string > stashing_policy_def Stashing Selection Policy . std::vector< std::string > submission_decision_policies_defs Submissions Decision Policy . Public Attributes Documentation \u00b6 variable name \u00b6 DecisionMethod name = DecisionMethod :: DefaultResearchStrategy ; variable initial_selection_policies_defs \u00b6 std :: vector < std :: vector < std :: string > > initial_selection_policies_defs ; Initial Selection Policy . variable will_not_start_hacking_decision_policies_def \u00b6 std :: vector < std :: string > will_not_start_hacking_decision_policies_def ; Will Start Hacking Decision Policy . variable between_stashed_selection_policies_defs \u00b6 std :: vector < std :: vector < std :: string > > between_stashed_selection_policies_defs ; Between Stashed Selection Policy . variable will_not_continue_replicating_decision_policy_def \u00b6 std :: vector < std :: string > will_not_continue_replicating_decision_policy_def ; Will Continue Replicating Decision Policy . variable between_replications_selection_policies_defs \u00b6 std :: vector < std :: vector < std :: string > > between_replications_selection_policies_defs ; Between Replication Selection Policy . variable stashing_policy_def \u00b6 std :: vector < std :: string > stashing_policy_def ; Stashing Selection Policy . variable submission_decision_policies_defs \u00b6 std :: vector < std :: string > submission_decision_policies_defs ; Submissions Decision Policy . Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::DefaultResearchStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#samdefaultresearchstrategyparameters","text":"Module: Parameters of the Research Strategies The parameters of the strategy. #include <ResearchStrategy.h>","title":"sam::DefaultResearchStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#public-attributes","text":"Name DecisionMethod name std::vector< std::vector< std::string > > initial_selection_policies_defs Initial Selection Policy . std::vector< std::string > will_not_start_hacking_decision_policies_def Will Start Hacking Decision Policy . std::vector< std::vector< std::string > > between_stashed_selection_policies_defs Between Stashed Selection Policy . std::vector< std::string > will_not_continue_replicating_decision_policy_def Will Continue Replicating Decision Policy . std::vector< std::vector< std::string > > between_replications_selection_policies_defs Between Replication Selection Policy . std::vector< std::string > stashing_policy_def Stashing Selection Policy . std::vector< std::string > submission_decision_policies_defs Submissions Decision Policy .","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-name","text":"DecisionMethod name = DecisionMethod :: DefaultResearchStrategy ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-initial_selection_policies_defs","text":"std :: vector < std :: vector < std :: string > > initial_selection_policies_defs ; Initial Selection Policy .","title":"variable initial_selection_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-will_not_start_hacking_decision_policies_def","text":"std :: vector < std :: string > will_not_start_hacking_decision_policies_def ; Will Start Hacking Decision Policy .","title":"variable will_not_start_hacking_decision_policies_def"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-between_stashed_selection_policies_defs","text":"std :: vector < std :: vector < std :: string > > between_stashed_selection_policies_defs ; Between Stashed Selection Policy .","title":"variable between_stashed_selection_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-will_not_continue_replicating_decision_policy_def","text":"std :: vector < std :: string > will_not_continue_replicating_decision_policy_def ; Will Continue Replicating Decision Policy .","title":"variable will_not_continue_replicating_decision_policy_def"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-between_replications_selection_policies_defs","text":"std :: vector < std :: vector < std :: string > > between_replications_selection_policies_defs ; Between Replication Selection Policy .","title":"variable between_replications_selection_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-stashing_policy_def","text":"std :: vector < std :: string > stashing_policy_def ; Stashing Selection Policy .","title":"variable stashing_policy_def"},{"location":"doxygen/Classes/structsam_1_1_default_research_strategy_1_1_parameters/#variable-submission_decision_policies_defs","text":"std :: vector < std :: string > submission_decision_policies_defs ; Submissions Decision Policy . Updated on 29 June 2021 at 16:13:48 CEST","title":"variable submission_decision_policies_defs"},{"location":"doxygen/Classes/structsam_1_1_effect_strategy_1_1_effect_strategy_parameters/","text":"sam::EffectStrategy::EffectStrategyParameters \u00b6 Public Attributes \u00b6 Name EffectEstimator name Public Attributes Documentation \u00b6 variable name \u00b6 EffectEstimator name ;","title":"sam::EffectStrategy::EffectStrategyParameters"},{"location":"doxygen/Classes/structsam_1_1_effect_strategy_1_1_effect_strategy_parameters/#sameffectstrategyeffectstrategyparameters","text":"","title":"sam::EffectStrategy::EffectStrategyParameters"},{"location":"doxygen/Classes/structsam_1_1_effect_strategy_1_1_effect_strategy_parameters/#public-attributes","text":"Name EffectEstimator name","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_effect_strategy_1_1_effect_strategy_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_effect_strategy_1_1_effect_strategy_parameters/#variable-name","text":"EffectEstimator name ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/","text":"sam::EggersTestEstimator::Parameters \u00b6 Module: Parameters of Meta Anlaysis Methods Parameters of the EggersTestEstimator . More... #include <MetaAnalysis.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( EggersTestEstimator::Parameters , name , alpha ) Public Attributes \u00b6 Name std::string name float alpha The \u0251 of the test. Detailed Description \u00b6 struct sam :: EggersTestEstimator :: Parameters ; Parameters of the EggersTestEstimator . While Egger's test is often performed with \u0251 = 0.1, it's possible to change the \u0251 using the alpha parameter. Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( EggersTestEstimator :: Parameters , name , alpha ) Public Attributes Documentation \u00b6 variable name \u00b6 std :: string name { \"EggersTestEstimator\" }; variable alpha \u00b6 float alpha { 0.10 }; The \u0251 of the test. Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::EggersTestEstimator::Parameters"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#sameggerstestestimatorparameters","text":"Module: Parameters of Meta Anlaysis Methods Parameters of the EggersTestEstimator . More... #include <MetaAnalysis.h>","title":"sam::EggersTestEstimator::Parameters"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( EggersTestEstimator::Parameters , name , alpha )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#public-attributes","text":"Name std::string name float alpha The \u0251 of the test.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#detailed-description","text":"struct sam :: EggersTestEstimator :: Parameters ; Parameters of the EggersTestEstimator . While Egger's test is often performed with \u0251 = 0.1, it's possible to change the \u0251 using the alpha parameter.","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( EggersTestEstimator :: Parameters , name , alpha )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#variable-name","text":"std :: string name { \"EggersTestEstimator\" };","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_parameters/#variable-alpha","text":"float alpha { 0.10 }; The \u0251 of the test. Updated on 29 June 2021 at 16:13:48 CEST","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/","text":"sam::EggersTestEstimator::ResultType \u00b6 More... #include <MetaAnalysis.h> Public Functions \u00b6 Name std::vector< std::string > Columns () Public Attributes \u00b6 Name float slope The slope of the fitted line. float se The standard error of the slope. float tstat The t-statistic of the test. float pval The p-value of the test. bool sig The significance of the test. float df The degree-of-freedom of the test. Detailed Description \u00b6 struct sam :: EggersTestEstimator :: ResultType ; Egger's Test Output Public Functions Documentation \u00b6 function Columns \u00b6 static inline std :: vector < std :: string > Columns () Public Attributes Documentation \u00b6 variable slope \u00b6 float slope ; The slope of the fitted line. variable se \u00b6 float se ; The standard error of the slope. variable tstat \u00b6 float tstat ; The t-statistic of the test. variable pval \u00b6 float pval ; The p-value of the test. variable sig \u00b6 bool sig ; The significance of the test. variable df \u00b6 float df ; The degree-of-freedom of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::EggersTestEstimator::ResultType"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#sameggerstestestimatorresulttype","text":"More... #include <MetaAnalysis.h>","title":"sam::EggersTestEstimator::ResultType"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#public-functions","text":"Name std::vector< std::string > Columns ()","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#public-attributes","text":"Name float slope The slope of the fitted line. float se The standard error of the slope. float tstat The t-statistic of the test. float pval The p-value of the test. bool sig The significance of the test. float df The degree-of-freedom of the test.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#detailed-description","text":"struct sam :: EggersTestEstimator :: ResultType ; Egger's Test Output","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#function-columns","text":"static inline std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#variable-slope","text":"float slope ; The slope of the fitted line.","title":"variable slope"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#variable-se","text":"float se ; The standard error of the slope.","title":"variable se"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#variable-tstat","text":"float tstat ; The t-statistic of the test.","title":"variable tstat"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#variable-pval","text":"float pval ; The p-value of the test.","title":"variable pval"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#variable-sig","text":"bool sig ; The significance of the test.","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_eggers_test_estimator_1_1_result_type/#variable-df","text":"float df ; The degree-of-freedom of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable df"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/","text":"sam::FTest::Parameters \u00b6 Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( FTest::Parameters , name , alpha ) Public Attributes \u00b6 Name TestMethod name float alpha Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( FTest :: Parameters , name , alpha ) Public Attributes Documentation \u00b6 variable name \u00b6 TestMethod name = [ TestMethod :: FTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - ftest ); variable alpha \u00b6 float alpha ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::FTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#samftestparameters","text":"","title":"sam::FTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( FTest::Parameters , name , alpha )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#public-attributes","text":"Name TestMethod name float alpha","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( FTest :: Parameters , name , alpha )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#variable-name","text":"TestMethod name = [ TestMethod :: FTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - ftest );","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_parameters/#variable-alpha","text":"float alpha ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/","text":"sam::FTest::ResultType \u00b6 Public Attributes \u00b6 Name float fstat unsigned df1 unsigned df2 float pvalue bool sig Friends \u00b6 Name std::ostream & operator<< (std::ostream & os, const ResultType & type) Public Attributes Documentation \u00b6 variable fstat \u00b6 float fstat ; variable df1 \u00b6 unsigned df1 ; variable df2 \u00b6 unsigned df2 ; variable pvalue \u00b6 float pvalue ; variable sig \u00b6 bool sig ; Friends \u00b6 friend operator<< \u00b6 friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::FTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#samftestresulttype","text":"","title":"sam::FTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#public-attributes","text":"Name float fstat unsigned df1 unsigned df2 float pvalue bool sig","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const ResultType & type)","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#variable-fstat","text":"float fstat ;","title":"variable fstat"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#variable-df1","text":"unsigned df1 ;","title":"variable df1"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#variable-df2","text":"unsigned df2 ;","title":"variable df2"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#variable-pvalue","text":"float pvalue ;","title":"variable pvalue"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#variable-sig","text":"bool sig ;","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_f_test_1_1_result_type/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"friend operator&lt;&lt;"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/","text":"sam::FabricatingData::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name std::string approach HackingTarget target int n_attempts Number of trials. int num Number of observations to be perturbed. std::optional< UnivariateDistribution > dist std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: FabricatingData :: Parameters ; Fabricating Data Parameters Example usage: { \"name\" : \"FabricatingData\" , } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: FabricatingData ; variable approach \u00b6 std :: string approach { \"generating\" }; Falsification approach. We've discussed two possible way of doing this generating, perturbing a value duplicating, swapping values between groups variable target \u00b6 HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both variable n_attempts \u00b6 int n_attempts { 1 }; Number of trials. Todo : To be implemented Indicates a set of rule that is going to be used to select the target group variable num \u00b6 int num ; Number of observations to be perturbed. variable dist \u00b6 std :: optional < UnivariateDistribution > dist ; Todo : Check if this is even necessary, I think in most cases, we can probably just use the data_strategy and get over it Distribution of fabricated data variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::FabricatingData::Parameters"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#samfabricatingdataparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::FabricatingData::Parameters"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#public-attributes","text":"Name HackingMethod name std::string approach HackingTarget target int n_attempts Number of trials. int num Number of observations to be perturbed. std::optional< UnivariateDistribution > dist std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#detailed-description","text":"struct sam :: FabricatingData :: Parameters ; Fabricating Data Parameters Example usage: { \"name\" : \"FabricatingData\" , } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: FabricatingData ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-approach","text":"std :: string approach { \"generating\" }; Falsification approach. We've discussed two possible way of doing this generating, perturbing a value duplicating, swapping values between groups","title":"variable approach"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-n_attempts","text":"int n_attempts { 1 }; Number of trials. Todo : To be implemented Indicates a set of rule that is going to be used to select the target group","title":"variable n_attempts"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-num","text":"int num ; Number of observations to be perturbed.","title":"variable num"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-dist","text":"std :: optional < UnivariateDistribution > dist ; Todo : Check if this is even necessary, I think in most cases, we can probably just use the data_strategy and get over it Distribution of fabricated data","title":"variable dist"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_fabricating_data_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/","text":"sam::FalsifyingData::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name std::string approach std::string switching_direction std::string selection_method HackingTarget target int n_attempts Number of trials. size_t num Number of observations to be perturbed. std::optional< UnivariateDistribution > noise_dist Distribution of noise. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: FalsifyingData :: Parameters ; Falsifying Data Parameters Example usage: { \"name\" : \"FalsifyingData\" , } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: FalsifyingData ; variable approach \u00b6 std :: string approach { \"perturbation\" }; Falsification approach. We've discussed two possible way of doing this perturbation, perturbing a value group swapping, swapping values between groups group switching, moving values between groups variable switching_direction \u00b6 std :: string switching_direction { \"control-to-treatment\" }; Switching direction control-to-treatment treatment-to-control variable selection_method \u00b6 std :: string selection_method { \"random\" }; Swapping Method random smart variable target \u00b6 HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both variable n_attempts \u00b6 int n_attempts { 1 }; Number of trials. Todo : To be implemented Indicates a set of rule that is going to be used to select the target group variable num \u00b6 size_t num ; Number of observations to be perturbed. variable noise_dist \u00b6 std :: optional < UnivariateDistribution > noise_dist = [ makeUnivariateDistribution ]( / doxygen / Files / _distributions_8h / # function - makeunivariatedistribution )({ { \"dist\" , \"normal_distribution\" }, { \"mean\" , 0 }, { \"stddev\" , 1 } }); Distribution of noise. variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::FalsifyingData::Parameters"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#samfalsifyingdataparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::FalsifyingData::Parameters"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#public-attributes","text":"Name HackingMethod name std::string approach std::string switching_direction std::string selection_method HackingTarget target int n_attempts Number of trials. size_t num Number of observations to be perturbed. std::optional< UnivariateDistribution > noise_dist Distribution of noise. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#detailed-description","text":"struct sam :: FalsifyingData :: Parameters ; Falsifying Data Parameters Example usage: { \"name\" : \"FalsifyingData\" , } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: FalsifyingData ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-approach","text":"std :: string approach { \"perturbation\" }; Falsification approach. We've discussed two possible way of doing this perturbation, perturbing a value group swapping, swapping values between groups group switching, moving values between groups","title":"variable approach"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-switching_direction","text":"std :: string switching_direction { \"control-to-treatment\" }; Switching direction control-to-treatment treatment-to-control","title":"variable switching_direction"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-selection_method","text":"std :: string selection_method { \"random\" }; Swapping Method random smart","title":"variable selection_method"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-n_attempts","text":"int n_attempts { 1 }; Number of trials. Todo : To be implemented Indicates a set of rule that is going to be used to select the target group","title":"variable n_attempts"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-num","text":"size_t num ; Number of observations to be perturbed.","title":"variable num"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-noise_dist","text":"std :: optional < UnivariateDistribution > noise_dist = [ makeUnivariateDistribution ]( / doxygen / Files / _distributions_8h / # function - makeunivariatedistribution )({ { \"dist\" , \"normal_distribution\" }, { \"mean\" , 0 }, { \"stddev\" , 1 } }); Distribution of noise.","title":"variable noise_dist"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_falsifying_data_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/","text":"sam::FixedEffectEstimator::ResultType \u00b6 Public Functions \u00b6 Name ResultType () =default ResultType (const RandomEffectEstimator::ResultType & res) std::vector< std::string > Columns () Public Attributes \u00b6 Name float est float se float ci_lb float ci_ub float zval float pval float q_stat float q_pval float tau2 Friends \u00b6 Name ostream & operator<< (ostream & os, const ResultType & type) Public Functions Documentation \u00b6 function ResultType \u00b6 ResultType () = default function ResultType \u00b6 inline ResultType ( const RandomEffectEstimator :: ResultType & res ) function Columns \u00b6 static inline std :: vector < std :: string > Columns () Public Attributes Documentation \u00b6 variable est \u00b6 float est ; variable se \u00b6 float se ; variable ci_lb \u00b6 float ci_lb ; variable ci_ub \u00b6 float ci_ub ; variable zval \u00b6 float zval ; variable pval \u00b6 float pval ; variable q_stat \u00b6 float q_stat ; variable q_pval \u00b6 float q_pval ; variable tau2 \u00b6 float tau2 ; Friends \u00b6 friend operator<< \u00b6 friend ostream & operator << ( ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::FixedEffectEstimator::ResultType"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#samfixedeffectestimatorresulttype","text":"","title":"sam::FixedEffectEstimator::ResultType"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#public-functions","text":"Name ResultType () =default ResultType (const RandomEffectEstimator::ResultType & res) std::vector< std::string > Columns ()","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#public-attributes","text":"Name float est float se float ci_lb float ci_ub float zval float pval float q_stat float q_pval float tau2","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#friends","text":"Name ostream & operator<< (ostream & os, const ResultType & type)","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#function-resulttype","text":"ResultType () = default","title":"function ResultType"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#function-resulttype_1","text":"inline ResultType ( const RandomEffectEstimator :: ResultType & res )","title":"function ResultType"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#function-columns","text":"static inline std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-est","text":"float est ;","title":"variable est"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-se","text":"float se ;","title":"variable se"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-ci_lb","text":"float ci_lb ;","title":"variable ci_lb"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-ci_ub","text":"float ci_ub ;","title":"variable ci_ub"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-zval","text":"float zval ;","title":"variable zval"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-pval","text":"float pval ;","title":"variable pval"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-q_stat","text":"float q_stat ;","title":"variable q_stat"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-q_pval","text":"float q_pval ;","title":"variable q_pval"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#variable-tau2","text":"float tau2 ;","title":"variable tau2"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_fixed_effect_estimator_1_1_result_type/#friend-operator","text":"friend ostream & operator << ( ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:47 CEST","title":"friend operator&lt;&lt;"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/","text":"sam::FrankenbachStrategy::Parameters \u00b6 Public Attributes \u00b6 Name std::string method float base_hp float lo_se float hi_se float min_se float max_se Public Attributes Documentation \u00b6 variable method \u00b6 std :: string method { \"FrankenbachStrategy\" }; variable base_hp \u00b6 float base_hp { 0 }; variable lo_se \u00b6 float lo_se { 0.4 }; variable hi_se \u00b6 float hi_se { 0.6 }; variable min_se \u00b6 float min_se { 0.1 }; variable max_se \u00b6 float max_se { 0.6 }; Updated on 29 June 2021 at 16:13:46 CEST","title":"sam::FrankenbachStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#samfrankenbachstrategyparameters","text":"","title":"sam::FrankenbachStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#public-attributes","text":"Name std::string method float base_hp float lo_se float hi_se float min_se float max_se","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#variable-method","text":"std :: string method { \"FrankenbachStrategy\" };","title":"variable method"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#variable-base_hp","text":"float base_hp { 0 };","title":"variable base_hp"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#variable-lo_se","text":"float lo_se { 0.4 };","title":"variable lo_se"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#variable-hi_se","text":"float hi_se { 0.6 };","title":"variable hi_se"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#variable-min_se","text":"float min_se { 0.1 };","title":"variable min_se"},{"location":"doxygen/Classes/structsam_1_1_frankenbach_strategy_1_1_parameters/#variable-max_se","text":"float max_se { 0.6 }; Updated on 29 June 2021 at 16:13:46 CEST","title":"variable max_se"},{"location":"doxygen/Classes/structsam_1_1_free_selection_1_1_parameters/","text":"sam::FreeSelection::Parameters \u00b6 Module: Parameters of Review Strategies Parameters of free selection. More... #include <ReviewStrategy.h> Detailed Description \u00b6 struct sam :: FreeSelection :: Parameters ; Parameters of free selection. Free selection doesn't have any parameters, but this is here for consistency. Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::FreeSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_free_selection_1_1_parameters/#samfreeselectionparameters","text":"Module: Parameters of Review Strategies Parameters of free selection. More... #include <ReviewStrategy.h>","title":"sam::FreeSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_free_selection_1_1_parameters/#detailed-description","text":"struct sam :: FreeSelection :: Parameters ; Parameters of free selection. Free selection doesn't have any parameters, but this is here for consistency. Updated on 29 June 2021 at 16:13:48 CEST","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/","text":"sam::GRMDataStrategy::Parameters \u00b6 Public Functions \u00b6 Name Parameters () =default Public Attributes \u00b6 Name DataModel name int n_items Number of items. int n_categories Number of categories. std::string response_function Indicates the Response Function. std::optional< MultivariateDistribution > m_diff_dist std::optional< MultivariateDistribution > m_abil_dist std::optional< std::vector< UnivariateDistribution > > diff_dists std::optional< std::vector< UnivariateDistribution > > abil_dists Public Functions Documentation \u00b6 function Parameters \u00b6 Parameters () = default Public Attributes Documentation \u00b6 variable name \u00b6 DataModel name { DataModel :: GradedResponseModel }; variable n_items \u00b6 int n_items ; Number of items. variable n_categories \u00b6 int n_categories ; Number of categories. variable response_function \u00b6 std :: string response_function { \"Rasch\" }; Indicates the Response Function. variable m_diff_dist \u00b6 std :: optional < MultivariateDistribution > m_diff_dist ; variable m_abil_dist \u00b6 std :: optional < MultivariateDistribution > m_abil_dist ; variable diff_dists \u00b6 std :: optional < std :: vector < UnivariateDistribution > > diff_dists ; variable abil_dists \u00b6 std :: optional < std :: vector < UnivariateDistribution > > abil_dists ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::GRMDataStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#samgrmdatastrategyparameters","text":"","title":"sam::GRMDataStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#public-functions","text":"Name Parameters () =default","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#public-attributes","text":"Name DataModel name int n_items Number of items. int n_categories Number of categories. std::string response_function Indicates the Response Function. std::optional< MultivariateDistribution > m_diff_dist std::optional< MultivariateDistribution > m_abil_dist std::optional< std::vector< UnivariateDistribution > > diff_dists std::optional< std::vector< UnivariateDistribution > > abil_dists","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#function-parameters","text":"Parameters () = default","title":"function Parameters"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-name","text":"DataModel name { DataModel :: GradedResponseModel };","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-n_items","text":"int n_items ; Number of items.","title":"variable n_items"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-n_categories","text":"int n_categories ; Number of categories.","title":"variable n_categories"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-response_function","text":"std :: string response_function { \"Rasch\" }; Indicates the Response Function.","title":"variable response_function"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-m_diff_dist","text":"std :: optional < MultivariateDistribution > m_diff_dist ;","title":"variable m_diff_dist"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-m_abil_dist","text":"std :: optional < MultivariateDistribution > m_abil_dist ;","title":"variable m_abil_dist"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-diff_dists","text":"std :: optional < std :: vector < UnivariateDistribution > > diff_dists ;","title":"variable diff_dists"},{"location":"doxygen/Classes/structsam_1_1_g_r_m_data_strategy_1_1_parameters/#variable-abil_dists","text":"std :: optional < std :: vector < UnivariateDistribution > > abil_dists ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable abil_dists"},{"location":"doxygen/Classes/structsam_1_1_group_pooling_1_1_parameters/","text":"sam::GroupPooling::Parameters \u00b6 Public Attributes \u00b6 Name HackingMethod name Placeholder for hacking strategy name. std::vector< std::vector< int > > pooled_conditions List of paired indices indicating which groups should be pooled together. Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: GroupPooling ; Placeholder for hacking strategy name. variable pooled_conditions \u00b6 std :: vector < std :: vector < int > > pooled_conditions ; List of paired indices indicating which groups should be pooled together. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::GroupPooling::Parameters"},{"location":"doxygen/Classes/structsam_1_1_group_pooling_1_1_parameters/#samgrouppoolingparameters","text":"","title":"sam::GroupPooling::Parameters"},{"location":"doxygen/Classes/structsam_1_1_group_pooling_1_1_parameters/#public-attributes","text":"Name HackingMethod name Placeholder for hacking strategy name. std::vector< std::vector< int > > pooled_conditions List of paired indices indicating which groups should be pooled together.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_group_pooling_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_group_pooling_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: GroupPooling ; Placeholder for hacking strategy name.","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_group_pooling_1_1_parameters/#variable-pooled_conditions","text":"std :: vector < std :: vector < int > > pooled_conditions ; List of paired indices indicating which groups should be pooled together. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable pooled_conditions"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/","text":"sam::Journal::Parameters \u00b6 Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( Journal::Parameters , name , max_pubs ) Public Attributes \u00b6 Name std::string name int max_pubs Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( Journal :: Parameters , name , max_pubs ) Public Attributes Documentation \u00b6 variable name \u00b6 std :: string name ; variable max_pubs \u00b6 int max_pubs ;","title":"sam::Journal::Parameters"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#samjournalparameters","text":"","title":"sam::Journal::Parameters"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( Journal::Parameters , name , max_pubs )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#public-attributes","text":"Name std::string name int max_pubs","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( Journal :: Parameters , name , max_pubs )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#variable-name","text":"std :: string name ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_journal_1_1_parameters/#variable-max_pubs","text":"int max_pubs ;","title":"variable max_pubs"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/","text":"sam::LinearModelStrategy::Parameters \u00b6 Parameters of LinearModelStrategy . #include <DataStrategy.h> Public Functions \u00b6 Name Parameters () =default Public Attributes \u00b6 Name std::optional< std::vector< UnivariateDistribution > > meas_dists std::optional< MultivariateDistribution > m_meas_dist std::optional< std::vector< UnivariateDistribution > > erro_dists std::optional< MultivariateDistribution > m_erro_dist DataModel name Public Functions Documentation \u00b6 function Parameters \u00b6 Parameters () = default Public Attributes Documentation \u00b6 variable meas_dists \u00b6 std :: optional < std :: vector < UnivariateDistribution > > meas_dists ; Distributions of main effects variable m_meas_dist \u00b6 std :: optional < MultivariateDistribution > m_meas_dist ; variable erro_dists \u00b6 std :: optional < std :: vector < UnivariateDistribution > > erro_dists ; Distributions of error. variable m_erro_dist \u00b6 std :: optional < MultivariateDistribution > m_erro_dist ; variable name \u00b6 DataModel name { DataModel :: LinearModel }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::LinearModelStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#samlinearmodelstrategyparameters","text":"Parameters of LinearModelStrategy . #include <DataStrategy.h>","title":"sam::LinearModelStrategy::Parameters"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#public-functions","text":"Name Parameters () =default","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#public-attributes","text":"Name std::optional< std::vector< UnivariateDistribution > > meas_dists std::optional< MultivariateDistribution > m_meas_dist std::optional< std::vector< UnivariateDistribution > > erro_dists std::optional< MultivariateDistribution > m_erro_dist DataModel name","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#function-parameters","text":"Parameters () = default","title":"function Parameters"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#variable-meas_dists","text":"std :: optional < std :: vector < UnivariateDistribution > > meas_dists ; Distributions of main effects","title":"variable meas_dists"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#variable-m_meas_dist","text":"std :: optional < MultivariateDistribution > m_meas_dist ;","title":"variable m_meas_dist"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#variable-erro_dists","text":"std :: optional < std :: vector < UnivariateDistribution > > erro_dists ; Distributions of error.","title":"variable erro_dists"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#variable-m_erro_dist","text":"std :: optional < MultivariateDistribution > m_erro_dist ;","title":"variable m_erro_dist"},{"location":"doxygen/Classes/structsam_1_1_linear_model_strategy_1_1_parameters/#variable-name","text":"DataModel name { DataModel :: LinearModel }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/","text":"sam::OptionalDropping::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name HackingTarget target std::vector< std::vector< int > > pooled List of condition groups to be used for the dropping procedure. std::vector< std::vector< int > > split_by std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: OptionalDropping :: Parameters ; Optional Dropping Collection Parameters Indicates the indicies of groups that you like to be used for splitting in pooled variable, e.g. [[1]], the first treatment group; and then use the split_by parameters to define the [index, value] of the covariants. Example usage: { \"name\" : \"OptionalDropping\" , \"pooled\" : [[ 1 ]], \"split_by\" : [[ 0 , 1 ]], \"stopping_condition\" : [ \"sig\" ] } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: OptionalDropping ; variable target \u00b6 HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both Todoto be implemented variable pooled \u00b6 std :: vector < std :: vector < int > > pooled ; List of condition groups to be used for the dropping procedure. variable split_by \u00b6 std :: vector < std :: vector < int > > split_by ; Lists of covariants index, and their value pairs, e.g., [[0, 0], [0, 1]], that is going to be used by the algorithm to split the dependent variables. In this case, the data will be splitted by the first covariants (level == 0), and then by the second covariants (level == 1). variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs { \"sig\" }; Stopping condition PolicyChain definitions. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::OptionalDropping::Parameters"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#samoptionaldroppingparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::OptionalDropping::Parameters"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#public-attributes","text":"Name HackingMethod name HackingTarget target std::vector< std::vector< int > > pooled List of condition groups to be used for the dropping procedure. std::vector< std::vector< int > > split_by std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#detailed-description","text":"struct sam :: OptionalDropping :: Parameters ; Optional Dropping Collection Parameters Indicates the indicies of groups that you like to be used for splitting in pooled variable, e.g. [[1]], the first treatment group; and then use the split_by parameters to define the [index, value] of the covariants. Example usage: { \"name\" : \"OptionalDropping\" , \"pooled\" : [[ 1 ]], \"split_by\" : [[ 0 , 1 ]], \"stopping_condition\" : [ \"sig\" ] } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: OptionalDropping ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both Todoto be implemented","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-pooled","text":"std :: vector < std :: vector < int > > pooled ; List of condition groups to be used for the dropping procedure.","title":"variable pooled"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-split_by","text":"std :: vector < std :: vector < int > > split_by ; Lists of covariants index, and their value pairs, e.g., [[0, 0], [0, 1]], that is going to be used by the algorithm to split the dependent variables. In this case, the data will be splitted by the first covariants (level == 0), and then by the second covariants (level == 1).","title":"variable split_by"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs { \"sig\" }; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_optional_dropping_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/","text":"sam::OptionalStopping::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name Placeholder for hacking strategy name. Parameter < int > num Number of new observations to be added to each group. HackingTarget target Indicates which groups are going to be targets. Parameter < float > ratio If not 0., ratio * n_obs will be added to the experiment. Parameter < int > n_attempts Number of times that Researcher add num observations to each group. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage The default execution stage of the strategy. Detailed Description \u00b6 struct sam :: OptionalStopping :: Parameters ; Parameter of optional stopping strategy Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: OptionalStopping ; Placeholder for hacking strategy name. variable num \u00b6 Parameter < int > num ; Number of new observations to be added to each group. See : sam::Parameter variable target \u00b6 HackingTarget target { HackingTarget :: Both }; Indicates which groups are going to be targets. variable ratio \u00b6 Parameter < float > ratio ; If not 0., ratio * n_obs will be added to the experiment. variable n_attempts \u00b6 Parameter < int > n_attempts { 1 }; Number of times that Researcher add num observations to each group. variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; The default execution stage of the strategy. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::OptionalStopping::Parameters"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#samoptionalstoppingparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::OptionalStopping::Parameters"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#public-attributes","text":"Name HackingMethod name Placeholder for hacking strategy name. Parameter < int > num Number of new observations to be added to each group. HackingTarget target Indicates which groups are going to be targets. Parameter < float > ratio If not 0., ratio * n_obs will be added to the experiment. Parameter < int > n_attempts Number of times that Researcher add num observations to each group. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage The default execution stage of the strategy.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#detailed-description","text":"struct sam :: OptionalStopping :: Parameters ; Parameter of optional stopping strategy","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: OptionalStopping ; Placeholder for hacking strategy name.","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-num","text":"Parameter < int > num ; Number of new observations to be added to each group. See : sam::Parameter","title":"variable num"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; Indicates which groups are going to be targets.","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-ratio","text":"Parameter < float > ratio ; If not 0., ratio * n_obs will be added to the experiment.","title":"variable ratio"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-n_attempts","text":"Parameter < int > n_attempts { 1 }; Number of times that Researcher add num observations to each group.","title":"variable n_attempts"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_optional_stopping_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; The default execution stage of the strategy. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/","text":"sam::OutliersRemoval::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name HackingTarget target TO BE IMPLEMENTED! std::string order int num Indicates the number of outliers to be removed in each iteration. int n_attempts int min_observations Indicates the minimum number of observations allowed during the process. std::vector< float > multipliers A list of standard deviation multipliers for identifying outliers. int side std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: OutliersRemoval :: Parameters ; Parameters of Outliers Removal Strategy { \"name\" : \"OutliersRemoval\" , \"level\" : \"dv\" , \"min_observations\" : 10 , \"multipliers\" : [ 0.5 ], \"n_attempts\" : 1000 , \"num\" : 1000 , \"order\" : \"random\" } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: OutliersRemoval ; variable target \u00b6 HackingTarget target { HackingTarget :: Both }; TO BE IMPLEMENTED! variable order \u00b6 std :: string order { \"max first\" }; Indicates the order where outliers are going to be removed from the experiment. max first , removes the biggest outlier first random , removes the first outlier first, this is as a random outlier is being removed variable num \u00b6 int num ; Indicates the number of outliers to be removed in each iteration. variable n_attempts \u00b6 int n_attempts { 1 }; Indicates the total number of attempts, i.e., iterations , to remove outliers variable min_observations \u00b6 int min_observations ; Indicates the minimum number of observations allowed during the process. variable multipliers \u00b6 std :: vector < float > multipliers ; A list of standard deviation multipliers for identifying outliers. variable side \u00b6 int side { 0 }; Indicates the side where the outliers should be removed from, side == 0 \u2192 |Z| < k side == 1 \u2192 Z > k side == -1 \u2192 Z < k variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::OutliersRemoval::Parameters"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#samoutliersremovalparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::OutliersRemoval::Parameters"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#public-attributes","text":"Name HackingMethod name HackingTarget target TO BE IMPLEMENTED! std::string order int num Indicates the number of outliers to be removed in each iteration. int n_attempts int min_observations Indicates the minimum number of observations allowed during the process. std::vector< float > multipliers A list of standard deviation multipliers for identifying outliers. int side std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#detailed-description","text":"struct sam :: OutliersRemoval :: Parameters ; Parameters of Outliers Removal Strategy { \"name\" : \"OutliersRemoval\" , \"level\" : \"dv\" , \"min_observations\" : 10 , \"multipliers\" : [ 0.5 ], \"n_attempts\" : 1000 , \"num\" : 1000 , \"order\" : \"random\" } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: OutliersRemoval ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; TO BE IMPLEMENTED!","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-order","text":"std :: string order { \"max first\" }; Indicates the order where outliers are going to be removed from the experiment. max first , removes the biggest outlier first random , removes the first outlier first, this is as a random outlier is being removed","title":"variable order"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-num","text":"int num ; Indicates the number of outliers to be removed in each iteration.","title":"variable num"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-n_attempts","text":"int n_attempts { 1 }; Indicates the total number of attempts, i.e., iterations , to remove outliers","title":"variable n_attempts"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-min_observations","text":"int min_observations ; Indicates the minimum number of observations allowed during the process.","title":"variable min_observations"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-multipliers","text":"std :: vector < float > multipliers ; A list of standard deviation multipliers for identifying outliers.","title":"variable multipliers"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-side","text":"int side { 0 }; Indicates the side where the outliers should be removed from, side == 0 \u2192 |Z| < k side == 1 \u2192 Z > k side == -1 \u2192 Z < k","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_outliers_removal_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/","text":"sam::PeekingOutliersRemoval::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name HackingTarget target TO BE IMPLEMENTED! std::string order int num Indicates the number of outliers to be removed in each iteration. int n_attempts int min_observations Indicates the minimum number of observations allowed during the process. std::vector< float > multipliers A list of standard deviation multipliers for identifying outliers. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::vector< std::string > whether_to_save_cond_defs Removing if. std::optional< float > prevalence The prevalence factor of the strategy. std::optional< float > defensibility The defensibility factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: PeekingOutliersRemoval :: Parameters ; Peaking Outliers Removal Parameters Example usage: { \"name\" : \"PeekingOutliersRemoval\" , \"level\" : \"dv\" , \"min_observations\" : 10 , \"multipliers\" : [ 0.5 ], \"n_attempts\" : 1000 , \"num\" : 1000 , \"order\" : \"random\" } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: PeekingOutliersRemoval ; variable target \u00b6 HackingTarget target { HackingTarget :: Both }; TO BE IMPLEMENTED! variable order \u00b6 std :: string order { \"max first\" }; Indicates the order where outliers are going to be removed from the experiment. max first , removes the biggest outlier first random , removes the first outlier first, this is as a random outlier is being removed variable num \u00b6 int num ; Indicates the number of outliers to be removed in each iteration. variable n_attempts \u00b6 int n_attempts { 1 }; Indicates the total number of attempts, i.e., iterations , to remove outliers variable min_observations \u00b6 int min_observations ; Indicates the minimum number of observations allowed during the process. variable multipliers \u00b6 std :: vector < float > multipliers ; A list of standard deviation multipliers for identifying outliers. variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions. variable whether_to_save_cond_defs \u00b6 std :: vector < std :: string > whether_to_save_cond_defs ; Removing if. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::PeekingOutliersRemoval::Parameters"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#sampeekingoutliersremovalparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::PeekingOutliersRemoval::Parameters"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#public-attributes","text":"Name HackingMethod name HackingTarget target TO BE IMPLEMENTED! std::string order int num Indicates the number of outliers to be removed in each iteration. int n_attempts int min_observations Indicates the minimum number of observations allowed during the process. std::vector< float > multipliers A list of standard deviation multipliers for identifying outliers. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::vector< std::string > whether_to_save_cond_defs Removing if. std::optional< float > prevalence The prevalence factor of the strategy. std::optional< float > defensibility The defensibility factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#detailed-description","text":"struct sam :: PeekingOutliersRemoval :: Parameters ; Peaking Outliers Removal Parameters Example usage: { \"name\" : \"PeekingOutliersRemoval\" , \"level\" : \"dv\" , \"min_observations\" : 10 , \"multipliers\" : [ 0.5 ], \"n_attempts\" : 1000 , \"num\" : 1000 , \"order\" : \"random\" } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: PeekingOutliersRemoval ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; TO BE IMPLEMENTED!","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-order","text":"std :: string order { \"max first\" }; Indicates the order where outliers are going to be removed from the experiment. max first , removes the biggest outlier first random , removes the first outlier first, this is as a random outlier is being removed","title":"variable order"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-num","text":"int num ; Indicates the number of outliers to be removed in each iteration.","title":"variable num"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-n_attempts","text":"int n_attempts { 1 }; Indicates the total number of attempts, i.e., iterations , to remove outliers","title":"variable n_attempts"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-min_observations","text":"int min_observations ; Indicates the minimum number of observations allowed during the process.","title":"variable min_observations"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-multipliers","text":"std :: vector < float > multipliers ; A list of standard deviation multipliers for identifying outliers.","title":"variable multipliers"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs ; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-whether_to_save_cond_defs","text":"std :: vector < std :: string > whether_to_save_cond_defs ; Removing if.","title":"variable whether_to_save_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_peeking_outliers_removal_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_policy/","text":"sam::Policy \u00b6 Module: Policy-related Modules Implementation of the Policy class. More... #include <Policy.h> Public Functions \u00b6 Name Policy () =default Policy (const std::string & p_def, sol::state & lua) Creates a policy, and registers it to the available lua state. template <typename ForwardIt > std::optional< std::pair< ForwardIt, ForwardIt > > operator() (ForwardIt begin, ForwardIt end) Filters the range based on the given policy. bool operator() (const Submission & sub) const Returns the result of applying the policy on a submission. bool operator() (const DependentVariable & dv) const Returns the result of applying the policy on a dependent variable. bool operator() ( DependentVariable & dv) const Public Attributes \u00b6 Name PolicyType type PolicyDefinition def sol::function func Detailed Description \u00b6 struct sam :: Policy ; Implementation of the Policy class. A policy is a logical rule that it's being applied on an experiment, submission, or a set of submissions. A policy can be used to perform two type of operation on either of the mentioned data structures, selection or decision. To check whether a submission, a dependent variable satisfies a given Policy , you must use the appropriate call operator in the form of bool operator() . To filter a list of submissions or dependent variables of the experiment based on the given Policy , you must use the iterator-based operator. Public Functions Documentation \u00b6 function Policy \u00b6 Policy () = default function Policy \u00b6 Policy ( const std :: string & p_def , sol :: state & lua ) Creates a policy, and registers it to the available lua state. Parameters : p_def The definition lua The lua state Attention : Since everything is happening via text processing, Policy is quite sensitive to the function definition and it rejects anythings with slightest of mistake in its definition. This mostly performs some string search, and decided what type of function has been given as the input. Then, it uses a lua function template to construct the appropriate function definition. Finally, it registers the function to the given lua state. function operator() \u00b6 template < typename ForwardIt > std :: optional < std :: pair < ForwardIt , ForwardIt > > operator ()( ForwardIt begin , ForwardIt end ) Filters the range based on the given policy. Parameters : begin The begin end The end Template Parameters : ForwardIt This usually accepts Submission 's ForwardIt Return : Return a tuple containing three variables. Attention : You can only use this on DependentVariable and Submission objects, since these are the two classes that are registered as lua usertype. This applies the current policy on a range of values, and returns a subset of the range if it finds anything. If not, it will return an empty optional. Shuffling the array and setting the end pointer to the first time, this basically mimic the process of selecting a random element from the list. function operator() \u00b6 inline bool operator ()( const Submission & sub ) const Returns the result of applying the policy on a submission. function operator() \u00b6 inline bool operator ()( const DependentVariable & dv ) const Returns the result of applying the policy on a dependent variable. function operator() \u00b6 inline bool operator ()( DependentVariable & dv ) const Public Attributes Documentation \u00b6 variable type \u00b6 PolicyType type ; variable def \u00b6 PolicyDefinition def ; variable func \u00b6 sol :: function func ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::Policy"},{"location":"doxygen/Classes/structsam_1_1_policy/#sampolicy","text":"Module: Policy-related Modules Implementation of the Policy class. More... #include <Policy.h>","title":"sam::Policy"},{"location":"doxygen/Classes/structsam_1_1_policy/#public-functions","text":"Name Policy () =default Policy (const std::string & p_def, sol::state & lua) Creates a policy, and registers it to the available lua state. template <typename ForwardIt > std::optional< std::pair< ForwardIt, ForwardIt > > operator() (ForwardIt begin, ForwardIt end) Filters the range based on the given policy. bool operator() (const Submission & sub) const Returns the result of applying the policy on a submission. bool operator() (const DependentVariable & dv) const Returns the result of applying the policy on a dependent variable. bool operator() ( DependentVariable & dv) const","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_policy/#public-attributes","text":"Name PolicyType type PolicyDefinition def sol::function func","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_policy/#detailed-description","text":"struct sam :: Policy ; Implementation of the Policy class. A policy is a logical rule that it's being applied on an experiment, submission, or a set of submissions. A policy can be used to perform two type of operation on either of the mentioned data structures, selection or decision. To check whether a submission, a dependent variable satisfies a given Policy , you must use the appropriate call operator in the form of bool operator() . To filter a list of submissions or dependent variables of the experiment based on the given Policy , you must use the iterator-based operator.","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_policy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy/#function-policy","text":"Policy () = default","title":"function Policy"},{"location":"doxygen/Classes/structsam_1_1_policy/#function-policy_1","text":"Policy ( const std :: string & p_def , sol :: state & lua ) Creates a policy, and registers it to the available lua state. Parameters : p_def The definition lua The lua state Attention : Since everything is happening via text processing, Policy is quite sensitive to the function definition and it rejects anythings with slightest of mistake in its definition. This mostly performs some string search, and decided what type of function has been given as the input. Then, it uses a lua function template to construct the appropriate function definition. Finally, it registers the function to the given lua state.","title":"function Policy"},{"location":"doxygen/Classes/structsam_1_1_policy/#function-operator","text":"template < typename ForwardIt > std :: optional < std :: pair < ForwardIt , ForwardIt > > operator ()( ForwardIt begin , ForwardIt end ) Filters the range based on the given policy. Parameters : begin The begin end The end Template Parameters : ForwardIt This usually accepts Submission 's ForwardIt Return : Return a tuple containing three variables. Attention : You can only use this on DependentVariable and Submission objects, since these are the two classes that are registered as lua usertype. This applies the current policy on a range of values, and returns a subset of the range if it finds anything. If not, it will return an empty optional. Shuffling the array and setting the end pointer to the first time, this basically mimic the process of selecting a random element from the list.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy/#function-operator_1","text":"inline bool operator ()( const Submission & sub ) const Returns the result of applying the policy on a submission.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy/#function-operator_2","text":"inline bool operator ()( const DependentVariable & dv ) const Returns the result of applying the policy on a dependent variable.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy/#function-operator_3","text":"inline bool operator ()( DependentVariable & dv ) const","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy/#variable-type","text":"PolicyType type ;","title":"variable type"},{"location":"doxygen/Classes/structsam_1_1_policy/#variable-def","text":"PolicyDefinition def ;","title":"variable def"},{"location":"doxygen/Classes/structsam_1_1_policy/#variable-func","text":"sol :: function func ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable func"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/","text":"sam::PolicyBasedSelection::Parameters \u00b6 Module: Parameters of Review Strategies Parameters of the Policy-based Selection. #include <ReviewStrategy.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( PolicyBasedSelection::Parameters , name , pub_bias_rate , acceptance_rate , selection_policy_defs ) Public Attributes \u00b6 Name SelectionMethod name float pub_bias_rate Publication Bias Rate. float acceptance_rate Acceptance Rate. std::vector< std::string > selection_policy_defs Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( PolicyBasedSelection :: Parameters , name , pub_bias_rate , acceptance_rate , selection_policy_defs ) Public Attributes Documentation \u00b6 variable name \u00b6 SelectionMethod name = SelectionMethod :: PolicyBasedSelection ; variable pub_bias_rate \u00b6 float pub_bias_rate {}; Publication Bias Rate. variable acceptance_rate \u00b6 float acceptance_rate {}; Acceptance Rate. variable selection_policy_defs \u00b6 std :: vector < std :: string > selection_policy_defs {}; Definition of the selection policy used by Journal to evaluate a given submission Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::PolicyBasedSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#sampolicybasedselectionparameters","text":"Module: Parameters of Review Strategies Parameters of the Policy-based Selection. #include <ReviewStrategy.h>","title":"sam::PolicyBasedSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( PolicyBasedSelection::Parameters , name , pub_bias_rate , acceptance_rate , selection_policy_defs )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#public-attributes","text":"Name SelectionMethod name float pub_bias_rate Publication Bias Rate. float acceptance_rate Acceptance Rate. std::vector< std::string > selection_policy_defs","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( PolicyBasedSelection :: Parameters , name , pub_bias_rate , acceptance_rate , selection_policy_defs )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#variable-name","text":"SelectionMethod name = SelectionMethod :: PolicyBasedSelection ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#variable-pub_bias_rate","text":"float pub_bias_rate {}; Publication Bias Rate.","title":"variable pub_bias_rate"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#variable-acceptance_rate","text":"float acceptance_rate {}; Acceptance Rate.","title":"variable acceptance_rate"},{"location":"doxygen/Classes/structsam_1_1_policy_based_selection_1_1_parameters/#variable-selection_policy_defs","text":"std :: vector < std :: string > selection_policy_defs {}; Definition of the selection policy used by Journal to evaluate a given submission Updated on 29 June 2021 at 16:13:48 CEST","title":"variable selection_policy_defs"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/","text":"sam::PolicyChain \u00b6 Module: Policy-related Modules Implementation of the PolicyChain class. More... #include <Policy.h> Public Functions \u00b6 Name Policy & operator[] (std::size_t idx) const Policy & operator[] (std::size_t idx) const auto begin () auto cbegin () const auto end () auto cend () const bool empty () const PolicyChain () =default PolicyChain (const PolicyChainDefinition & pchain_defs, PolicyChainType type, sol::state & lua) PolicyChain constructor. bool operator() (const Submission & sub) Checks whether the given Submission satisfies all all policies. bool operator() (const DependentVariable & dv) Checks whether the given DependentVariable satisfies all the policies. bool operator() ( DependentVariable & dv) bool operator() ( Experiment * experiment) Determines whether the experiment satisfies any of the given policies. std::optional< std::vector< Submission > > operator() ( Experiment & experiment) Returns a list of submission satisfying the policy chain. std::optional< std::vector< Submission > > operator() (std::vector< Submission > & spool) Returns a list of submissions satisfying the policy chain. Public Attributes \u00b6 Name PolicyChainType type_ PolicyChainDefinition defs std::vector< Policy > pchain Detailed Description \u00b6 struct sam :: PolicyChain ; Implementation of the PolicyChain class. PolicyChains are a list of Policies that will be executed chronologically. They are often being used to check whether an Experiment or a Submission can satisfy all the given policies. PolicyChains can be defined in two different ways. They are either a selection or decision chains. The ::Selection chains are used to filter an experiment or a list of submissions based on the given policies. The ::Decision chains are used to check whether any of the submissions or dependent variables are satisfying all the available policies in the given chain. Public Functions Documentation \u00b6 function operator[] \u00b6 inline Policy & operator []( std :: size_t idx ) function operator[] \u00b6 inline const Policy & operator []( std :: size_t idx ) const function begin \u00b6 inline auto begin () function cbegin \u00b6 inline auto cbegin () const function end \u00b6 inline auto end () function cend \u00b6 inline auto cend () const function empty \u00b6 inline bool empty () const function PolicyChain \u00b6 PolicyChain () = default function PolicyChain \u00b6 PolicyChain ( const PolicyChainDefinition & pchain_defs , PolicyChainType type , sol :: state & lua ) PolicyChain constructor. It constructs a PolicyChain object, and it also takes care of a few other things like making sure that no comparison operator comes after any of the function calls. It also sets the type of the PolicyChain , as described in PolicyChainType. function operator() \u00b6 bool operator ()( const Submission & sub ) Checks whether the given Submission satisfies all all policies. Parameters : sub The submission Return : The result of applying all policies on the given submission function operator() \u00b6 bool operator ()( const DependentVariable & dv ) Checks whether the given DependentVariable satisfies all the policies. Parameters : dv The dependent variable Return : The result of applying all policies on the given dv function operator() \u00b6 bool operator ()( DependentVariable & dv ) function operator() \u00b6 bool operator ()( Experiment * experiment ) Determines whether the experiment satisfies any of the given policies. Return : Returns true if at least one DV satisfies all the policies, otherwise false . Todo : Refactor this such that it accepts a reference This checks whether any of the DependentVariable(s) are satisfying all the policies of the chain. function operator() \u00b6 std :: optional < std :: vector < Submission > > operator ()( Experiment & experiment ) Returns a list of submission satisfying the policy chain. Parameters : expr The experiment Return : An optional list of submissions Note : Only dependent variables of the treatment group will be considered. This applies the policy chain on the Experiment and returns a list of submissions (constructed from dependent variables of the experiment) that are satisfying all the available policies. function operator() \u00b6 std :: optional < std :: vector < Submission > > operator ()( std :: vector < Submission > & spool ) Returns a list of submissions satisfying the policy chain. Parameters : spool The list of submissions Return : A subset of spool , if any This applies all the available policies of the chain on the given pool of submissions and if there were any hit, it returns those. If not, it will report an empty list. Public Attributes Documentation \u00b6 variable type_ \u00b6 PolicyChainType type_ ; variable defs \u00b6 PolicyChainDefinition defs ; variable pchain \u00b6 std :: vector < Policy > pchain ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::PolicyChain"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#sampolicychain","text":"Module: Policy-related Modules Implementation of the PolicyChain class. More... #include <Policy.h>","title":"sam::PolicyChain"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#public-functions","text":"Name Policy & operator[] (std::size_t idx) const Policy & operator[] (std::size_t idx) const auto begin () auto cbegin () const auto end () auto cend () const bool empty () const PolicyChain () =default PolicyChain (const PolicyChainDefinition & pchain_defs, PolicyChainType type, sol::state & lua) PolicyChain constructor. bool operator() (const Submission & sub) Checks whether the given Submission satisfies all all policies. bool operator() (const DependentVariable & dv) Checks whether the given DependentVariable satisfies all the policies. bool operator() ( DependentVariable & dv) bool operator() ( Experiment * experiment) Determines whether the experiment satisfies any of the given policies. std::optional< std::vector< Submission > > operator() ( Experiment & experiment) Returns a list of submission satisfying the policy chain. std::optional< std::vector< Submission > > operator() (std::vector< Submission > & spool) Returns a list of submissions satisfying the policy chain.","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#public-attributes","text":"Name PolicyChainType type_ PolicyChainDefinition defs std::vector< Policy > pchain","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#detailed-description","text":"struct sam :: PolicyChain ; Implementation of the PolicyChain class. PolicyChains are a list of Policies that will be executed chronologically. They are often being used to check whether an Experiment or a Submission can satisfy all the given policies. PolicyChains can be defined in two different ways. They are either a selection or decision chains. The ::Selection chains are used to filter an experiment or a list of submissions based on the given policies. The ::Decision chains are used to check whether any of the submissions or dependent variables are satisfying all the available policies in the given chain.","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator","text":"inline Policy & operator []( std :: size_t idx )","title":"function operator[]"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_1","text":"inline const Policy & operator []( std :: size_t idx ) const","title":"function operator[]"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-begin","text":"inline auto begin ()","title":"function begin"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-cbegin","text":"inline auto cbegin () const","title":"function cbegin"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-end","text":"inline auto end ()","title":"function end"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-cend","text":"inline auto cend () const","title":"function cend"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-empty","text":"inline bool empty () const","title":"function empty"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-policychain","text":"PolicyChain () = default","title":"function PolicyChain"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-policychain_1","text":"PolicyChain ( const PolicyChainDefinition & pchain_defs , PolicyChainType type , sol :: state & lua ) PolicyChain constructor. It constructs a PolicyChain object, and it also takes care of a few other things like making sure that no comparison operator comes after any of the function calls. It also sets the type of the PolicyChain , as described in PolicyChainType.","title":"function PolicyChain"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_2","text":"bool operator ()( const Submission & sub ) Checks whether the given Submission satisfies all all policies. Parameters : sub The submission Return : The result of applying all policies on the given submission","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_3","text":"bool operator ()( const DependentVariable & dv ) Checks whether the given DependentVariable satisfies all the policies. Parameters : dv The dependent variable Return : The result of applying all policies on the given dv","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_4","text":"bool operator ()( DependentVariable & dv )","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_5","text":"bool operator ()( Experiment * experiment ) Determines whether the experiment satisfies any of the given policies. Return : Returns true if at least one DV satisfies all the policies, otherwise false . Todo : Refactor this such that it accepts a reference This checks whether any of the DependentVariable(s) are satisfying all the policies of the chain.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_6","text":"std :: optional < std :: vector < Submission > > operator ()( Experiment & experiment ) Returns a list of submission satisfying the policy chain. Parameters : expr The experiment Return : An optional list of submissions Note : Only dependent variables of the treatment group will be considered. This applies the policy chain on the Experiment and returns a list of submissions (constructed from dependent variables of the experiment) that are satisfying all the available policies.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#function-operator_7","text":"std :: optional < std :: vector < Submission > > operator ()( std :: vector < Submission > & spool ) Returns a list of submissions satisfying the policy chain. Parameters : spool The list of submissions Return : A subset of spool , if any This applies all the available policies of the chain on the given pool of submissions and if there were any hit, it returns those. If not, it will report an empty list.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#variable-type_","text":"PolicyChainType type_ ;","title":"variable type_"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#variable-defs","text":"PolicyChainDefinition defs ;","title":"variable defs"},{"location":"doxygen/Classes/structsam_1_1_policy_chain/#variable-pchain","text":"std :: vector < Policy > pchain ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable pchain"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/","text":"sam::PolicyChainSet \u00b6 Module: Policy-related Modules More... #include <Policy.h> Public Functions \u00b6 Name PolicyChain & operator[] (std::size_t idx) const PolicyChain & operator[] (std::size_t idx) const auto begin () auto cbegin () const auto end () auto cend () const size_t size () const bool empty () const PolicyChainSet () =default PolicyChainSet (const PolicyChainSetDefinition & psets_defs, sol::state & lua) PolicyChainSet constructor. std::optional< std::vector< Submission > > operator() ( Experiment & expr) Returns a list of submissions from DVs of an experiment. std::optional< std::vector< Submission > > operator() (std::vector< Submission > & spool) Returns a list of submissions from a list of submissions. Public Attributes \u00b6 Name std::vector< PolicyChain > pchains Detailed Description \u00b6 struct sam :: PolicyChainSet ; PolicyChainSet is a collection of PolicyChains They are mainly being used and interpreted like a list of preferences, and will be executed chronologically. Most function will go through the list one by one, and will quit as soon as one of the PolicyChains find at least on outcome from a given list of options, e.g., SubmissionPool or Experiment . Public Functions Documentation \u00b6 function operator[] \u00b6 inline PolicyChain & operator []( std :: size_t idx ) function operator[] \u00b6 inline const PolicyChain & operator []( std :: size_t idx ) const function begin \u00b6 inline auto begin () function cbegin \u00b6 inline auto cbegin () const function end \u00b6 inline auto end () function cend \u00b6 inline auto cend () const function size \u00b6 inline size_t size () const function empty \u00b6 inline bool empty () const function PolicyChainSet \u00b6 PolicyChainSet () = default function PolicyChainSet \u00b6 PolicyChainSet ( const PolicyChainSetDefinition & psets_defs , sol :: state & lua ) PolicyChainSet constructor. function operator() \u00b6 std :: optional < std :: vector < Submission > > operator ()( Experiment & expr ) Returns a list of submissions from DVs of an experiment. Parameters : expr The experiment Return : An optional list of submissions It chronologically applies all the available policy chains on the experiment and returns a list of submissions that are satisfies the first PolicyChain in the list. If none of the chains were able to select any submissions, an empty std::optional will be returned. function operator() \u00b6 std :: optional < std :: vector < Submission > > operator ()( std :: vector < Submission > & spool ) Returns a list of submissions from a list of submissions. Parameters : spool The pool of submissions Return : An optional list of submissions It chronologically applies all the available policy chains on the submission pool and returns a list of submissions that are satisfies the first PolicyChain in the list. If none of the chains were able to select any submissions, an empty std::optional will be returned. Public Attributes Documentation \u00b6 variable pchains \u00b6 std :: vector < PolicyChain > pchains ; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::PolicyChainSet"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#sampolicychainset","text":"Module: Policy-related Modules More... #include <Policy.h>","title":"sam::PolicyChainSet"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#public-functions","text":"Name PolicyChain & operator[] (std::size_t idx) const PolicyChain & operator[] (std::size_t idx) const auto begin () auto cbegin () const auto end () auto cend () const size_t size () const bool empty () const PolicyChainSet () =default PolicyChainSet (const PolicyChainSetDefinition & psets_defs, sol::state & lua) PolicyChainSet constructor. std::optional< std::vector< Submission > > operator() ( Experiment & expr) Returns a list of submissions from DVs of an experiment. std::optional< std::vector< Submission > > operator() (std::vector< Submission > & spool) Returns a list of submissions from a list of submissions.","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#public-attributes","text":"Name std::vector< PolicyChain > pchains","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#detailed-description","text":"struct sam :: PolicyChainSet ; PolicyChainSet is a collection of PolicyChains They are mainly being used and interpreted like a list of preferences, and will be executed chronologically. Most function will go through the list one by one, and will quit as soon as one of the PolicyChains find at least on outcome from a given list of options, e.g., SubmissionPool or Experiment .","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-operator","text":"inline PolicyChain & operator []( std :: size_t idx )","title":"function operator[]"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-operator_1","text":"inline const PolicyChain & operator []( std :: size_t idx ) const","title":"function operator[]"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-begin","text":"inline auto begin ()","title":"function begin"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-cbegin","text":"inline auto cbegin () const","title":"function cbegin"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-end","text":"inline auto end ()","title":"function end"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-cend","text":"inline auto cend () const","title":"function cend"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-size","text":"inline size_t size () const","title":"function size"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-empty","text":"inline bool empty () const","title":"function empty"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-policychainset","text":"PolicyChainSet () = default","title":"function PolicyChainSet"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-policychainset_1","text":"PolicyChainSet ( const PolicyChainSetDefinition & psets_defs , sol :: state & lua ) PolicyChainSet constructor.","title":"function PolicyChainSet"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-operator_2","text":"std :: optional < std :: vector < Submission > > operator ()( Experiment & expr ) Returns a list of submissions from DVs of an experiment. Parameters : expr The experiment Return : An optional list of submissions It chronologically applies all the available policy chains on the experiment and returns a list of submissions that are satisfies the first PolicyChain in the list. If none of the chains were able to select any submissions, an empty std::optional will be returned.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#function-operator_3","text":"std :: optional < std :: vector < Submission > > operator ()( std :: vector < Submission > & spool ) Returns a list of submissions from a list of submissions. Parameters : spool The pool of submissions Return : An optional list of submissions It chronologically applies all the available policy chains on the submission pool and returns a list of submissions that are satisfies the first PolicyChain in the list. If none of the chains were able to select any submissions, an empty std::optional will be returned.","title":"function operator()"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_policy_chain_set/#variable-pchains","text":"std :: vector < PolicyChain > pchains ; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable pchains"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/","text":"sam::QuestionableRounding::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name HackingTarget target float threshold std::string rounding_method std::optional< float > prevalence The prevalence factor of the strategy. std::optional< float > defensibility The defensibility factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: QuestionableRounding :: Parameters ; Questionable Rounding Parameters Example usage: { \"name\" : \"QuestionableRounding\" , \"rounding_method\" : \"alpha\" , \"threshold\" : 0.01 , \"prevalence\" : 0.1 , \"defensibility\" : 0.9 , \"stage\" : \"Reporting\" } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: QuestionableRounding ; variable target \u00b6 HackingTarget target { HackingTarget :: Treatment }; variable threshold \u00b6 float threshold ; Indicates the distance between the pvalue and alpha by which the researcher considers to round the pvalue to significance variable rounding_method \u00b6 std :: string rounding_method = \"diff\" ; Rounding Method diff: Setting the rounded p-value to the difference between pvalue and threshold alpha: Setting the rounded p-value to the value of alpha TodoI cna possibly add more methods here, e.g., variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: Reporting }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::QuestionableRounding::Parameters"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#samquestionableroundingparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::QuestionableRounding::Parameters"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#public-attributes","text":"Name HackingMethod name HackingTarget target float threshold std::string rounding_method std::optional< float > prevalence The prevalence factor of the strategy. std::optional< float > defensibility The defensibility factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#detailed-description","text":"struct sam :: QuestionableRounding :: Parameters ; Questionable Rounding Parameters Example usage: { \"name\" : \"QuestionableRounding\" , \"rounding_method\" : \"alpha\" , \"threshold\" : 0.01 , \"prevalence\" : 0.1 , \"defensibility\" : 0.9 , \"stage\" : \"Reporting\" } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: QuestionableRounding ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Treatment };","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-threshold","text":"float threshold ; Indicates the distance between the pvalue and alpha by which the researcher considers to round the pvalue to significance","title":"variable threshold"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-rounding_method","text":"std :: string rounding_method = \"diff\" ; Rounding Method diff: Setting the rounded p-value to the difference between pvalue and threshold alpha: Setting the rounded p-value to the value of alpha TodoI cna possibly add more methods here, e.g.,","title":"variable rounding_method"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_questionable_rounding_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: Reporting }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/","text":"sam::RandomEffectEstimator::Parameters \u00b6 Module: Parameters of Meta Anlaysis Methods Parameters of the RandomEffectEstimator . #include <MetaAnalysis.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomEffectEstimator::Parameters , name , estimator ) Public Attributes \u00b6 Name std::string name std::string estimator The random effect estimator. Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomEffectEstimator :: Parameters , name , estimator ) Public Attributes Documentation \u00b6 variable name \u00b6 std :: string name { \"RandomEffectEstimator\" }; variable estimator \u00b6 std :: string estimator { \"DL\" }; The random effect estimator. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::RandomEffectEstimator::Parameters"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#samrandomeffectestimatorparameters","text":"Module: Parameters of Meta Anlaysis Methods Parameters of the RandomEffectEstimator . #include <MetaAnalysis.h>","title":"sam::RandomEffectEstimator::Parameters"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomEffectEstimator::Parameters , name , estimator )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#public-attributes","text":"Name std::string name std::string estimator The random effect estimator.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomEffectEstimator :: Parameters , name , estimator )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#variable-name","text":"std :: string name { \"RandomEffectEstimator\" };","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_parameters/#variable-estimator","text":"std :: string estimator { \"DL\" }; The random effect estimator. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable estimator"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/","text":"sam::RandomEffectEstimator::ResultType \u00b6 Public Functions \u00b6 Name ResultType () =default std::vector< std::string > Columns () Public Attributes \u00b6 Name float est float se float ci_lb float ci_ub float zval float pval float q_stat float q_pval float tau2 Friends \u00b6 Name ostream & operator<< (ostream & os, const ResultType & type) Public Functions Documentation \u00b6 function ResultType \u00b6 ResultType () = default function Columns \u00b6 static inline std :: vector < std :: string > Columns () Public Attributes Documentation \u00b6 variable est \u00b6 float est ; variable se \u00b6 float se ; variable ci_lb \u00b6 float ci_lb ; variable ci_ub \u00b6 float ci_ub ; variable zval \u00b6 float zval ; variable pval \u00b6 float pval ; variable q_stat \u00b6 float q_stat ; variable q_pval \u00b6 float q_pval ; variable tau2 \u00b6 float tau2 ; Friends \u00b6 friend operator<< \u00b6 friend ostream & operator << ( ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::RandomEffectEstimator::ResultType"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#samrandomeffectestimatorresulttype","text":"","title":"sam::RandomEffectEstimator::ResultType"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#public-functions","text":"Name ResultType () =default std::vector< std::string > Columns ()","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#public-attributes","text":"Name float est float se float ci_lb float ci_ub float zval float pval float q_stat float q_pval float tau2","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#friends","text":"Name ostream & operator<< (ostream & os, const ResultType & type)","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#function-resulttype","text":"ResultType () = default","title":"function ResultType"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#function-columns","text":"static inline std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-est","text":"float est ;","title":"variable est"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-se","text":"float se ;","title":"variable se"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-ci_lb","text":"float ci_lb ;","title":"variable ci_lb"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-ci_ub","text":"float ci_ub ;","title":"variable ci_ub"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-zval","text":"float zval ;","title":"variable zval"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-pval","text":"float pval ;","title":"variable pval"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-q_stat","text":"float q_stat ;","title":"variable q_stat"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-q_pval","text":"float q_pval ;","title":"variable q_pval"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#variable-tau2","text":"float tau2 ;","title":"variable tau2"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_random_effect_estimator_1_1_result_type/#friend-operator","text":"friend ostream & operator << ( ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:47 CEST","title":"friend operator&lt;&lt;"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/","text":"sam::RandomSelection::Parameters \u00b6 Module: Parameters of Review Strategies Parameter of Random Selection review strategy. #include <ReviewStrategy.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomSelection::Parameters , name , acceptance_rate ) Public Attributes \u00b6 Name SelectionMethod name float acceptance_rate Indicates the acceptance rate of the Journal . Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomSelection :: Parameters , name , acceptance_rate ) Public Attributes Documentation \u00b6 variable name \u00b6 SelectionMethod name = SelectionMethod :: RandomSelection ; variable acceptance_rate \u00b6 float acceptance_rate {}; Indicates the acceptance rate of the Journal . Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::RandomSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#samrandomselectionparameters","text":"Module: Parameters of Review Strategies Parameter of Random Selection review strategy. #include <ReviewStrategy.h>","title":"sam::RandomSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomSelection::Parameters , name , acceptance_rate )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#public-attributes","text":"Name SelectionMethod name float acceptance_rate Indicates the acceptance rate of the Journal .","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RandomSelection :: Parameters , name , acceptance_rate )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#variable-name","text":"SelectionMethod name = SelectionMethod :: RandomSelection ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_random_selection_1_1_parameters/#variable-acceptance_rate","text":"float acceptance_rate {}; Indicates the acceptance rate of the Journal . Updated on 29 June 2021 at 16:13:48 CEST","title":"variable acceptance_rate"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/","text":"sam::RankCorrelation::Parameters \u00b6 Module: Parameters of Meta Anlaysis Methods Parameters of RankCorrelation . #include <MetaAnalysis.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RankCorrelation::Parameters , name , alternative , alpha ) Public Attributes \u00b6 Name std::string name TestStrategy::TestAlternative alternative float alpha The \u0251 of the test. Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RankCorrelation :: Parameters , name , alternative , alpha ) Public Attributes Documentation \u00b6 variable name \u00b6 std :: string name { \"RankCorrelation\" }; variable alternative \u00b6 TestStrategy :: TestAlternative alternative = TestStrategy :: TestAlternative :: TwoSided ; variable alpha \u00b6 float alpha { 0.10 }; The \u0251 of the test. Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::RankCorrelation::Parameters"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#samrankcorrelationparameters","text":"Module: Parameters of Meta Anlaysis Methods Parameters of RankCorrelation . #include <MetaAnalysis.h>","title":"sam::RankCorrelation::Parameters"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RankCorrelation::Parameters , name , alternative , alpha )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#public-attributes","text":"Name std::string name TestStrategy::TestAlternative alternative float alpha The \u0251 of the test.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( RankCorrelation :: Parameters , name , alternative , alpha )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#variable-name","text":"std :: string name { \"RankCorrelation\" };","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#variable-alternative","text":"TestStrategy :: TestAlternative alternative = TestStrategy :: TestAlternative :: TwoSided ;","title":"variable alternative"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_parameters/#variable-alpha","text":"float alpha { 0.10 }; The \u0251 of the test. Updated on 29 June 2021 at 16:13:48 CEST","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/","text":"sam::RankCorrelation::ResultType \u00b6 Public Functions \u00b6 Name std::vector< std::string > Columns () Public Attributes \u00b6 Name float est Kendall's tau estimate. float pval The p-value of the test. bool sig The significance of the test. Public Functions Documentation \u00b6 function Columns \u00b6 static inline std :: vector < std :: string > Columns () Public Attributes Documentation \u00b6 variable est \u00b6 float est ; Kendall's tau estimate. variable pval \u00b6 float pval ; The p-value of the test. variable sig \u00b6 bool sig ; The significance of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::RankCorrelation::ResultType"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#samrankcorrelationresulttype","text":"","title":"sam::RankCorrelation::ResultType"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#public-functions","text":"Name std::vector< std::string > Columns ()","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#public-attributes","text":"Name float est Kendall's tau estimate. float pval The p-value of the test. bool sig The significance of the test.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#function-columns","text":"static inline std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#variable-est","text":"float est ; Kendall's tau estimate.","title":"variable est"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#variable-pval","text":"float pval ; The p-value of the test.","title":"variable pval"},{"location":"doxygen/Classes/structsam_1_1_rank_correlation_1_1_result_type/#variable-sig","text":"bool sig ; The significance of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/","text":"sam::SignificantSelection::Parameters \u00b6 Module: Parameters of Review Strategies More... #include <ReviewStrategy.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( SignificantSelection::Parameters , name , alpha , pub_bias_rate , side ) Public Attributes \u00b6 Name SelectionMethod name Selection strategy name. float alpha float pub_bias_rate Publication bias rate. int side Detailed Description \u00b6 struct sam :: SignificantSelection :: Parameters ; A type keeping the parameters of the Significant Selection strategy. Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( SignificantSelection :: Parameters , name , alpha , pub_bias_rate , side ) Public Attributes Documentation \u00b6 variable name \u00b6 SelectionMethod name = SelectionMethod :: SignificantSelection ; Selection strategy name. variable alpha \u00b6 float alpha {}; The \\alpha at which the review strategy decides the significance of a publication variable pub_bias_rate \u00b6 float pub_bias_rate {}; Publication bias rate. variable side \u00b6 int side { 1 }; Indicates the selection strategy 's preference toward positive, 1 , or negative, -1 effect. If 0 , Journal doesn't have any preferences. Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::SignificantSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#samsignificantselectionparameters","text":"Module: Parameters of Review Strategies More... #include <ReviewStrategy.h>","title":"sam::SignificantSelection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( SignificantSelection::Parameters , name , alpha , pub_bias_rate , side )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#public-attributes","text":"Name SelectionMethod name Selection strategy name. float alpha float pub_bias_rate Publication bias rate. int side","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#detailed-description","text":"struct sam :: SignificantSelection :: Parameters ; A type keeping the parameters of the Significant Selection strategy.","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( SignificantSelection :: Parameters , name , alpha , pub_bias_rate , side )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#variable-name","text":"SelectionMethod name = SelectionMethod :: SignificantSelection ; Selection strategy name.","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#variable-alpha","text":"float alpha {}; The \\alpha at which the review strategy decides the significance of a publication","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#variable-pub_bias_rate","text":"float pub_bias_rate {}; Publication bias rate.","title":"variable pub_bias_rate"},{"location":"doxygen/Classes/structsam_1_1_significant_selection_1_1_parameters/#variable-side","text":"int side { 1 }; Indicates the selection strategy 's preference toward positive, 1 , or negative, -1 effect. If 0 , Journal doesn't have any preferences. Updated on 29 June 2021 at 16:13:48 CEST","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/","text":"sam::StoppingDataCollection::Parameters \u00b6 Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name HackingTarget target int batch_size Number of observations to be perturbed. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage The default execution stage of the strategy. Detailed Description \u00b6 struct sam :: StoppingDataCollection :: Parameters ; Stopping Data Collection Parameters Example usage: { \"name\" : \"StoppingDataCollection\" , \"batch_size\" : 5 , \"stopping_condition\" : [ \"sig\" ] } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: StoppingDataCollection ; variable target \u00b6 HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both Todoto be implemented variable batch_size \u00b6 int batch_size ; Number of observations to be perturbed. Todo : To be implemented Indicates a set of rule that is going to be used to select the target group variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs { \"sig\" }; Stopping condition PolicyChain definitions. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: DataCollection }; The default execution stage of the strategy. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::StoppingDataCollection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#samstoppingdatacollectionparameters","text":"Module: Parameters of Hacking Strategies More... #include <HackingStrategy.h>","title":"sam::StoppingDataCollection::Parameters"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#public-attributes","text":"Name HackingMethod name HackingTarget target int batch_size Number of observations to be perturbed. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > defensibility The defensibility factor of the strategy. std::optional< float > prevalence The prevalence factor of the strategy. HackingStage stage The default execution stage of the strategy.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#detailed-description","text":"struct sam :: StoppingDataCollection :: Parameters ; Stopping Data Collection Parameters Example usage: { \"name\" : \"StoppingDataCollection\" , \"batch_size\" : 5 , \"stopping_condition\" : [ \"sig\" ] } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: StoppingDataCollection ;","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; Indicates which outcome variables are going to be targeted, control treatment both Todoto be implemented","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-batch_size","text":"int batch_size ; Number of observations to be perturbed. Todo : To be implemented Indicates a set of rule that is going to be used to select the target group","title":"variable batch_size"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs { \"sig\" }; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_stopping_data_collection_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: DataCollection }; The default execution stage of the strategy. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/","text":"sam::SubjectiveOutlierRemoval::Parameters \u00b6 Module: Parameters of Hacking Strategies SubjectiveOutlierRemoval 's parameters. More... #include <HackingStrategy.h> Public Attributes \u00b6 Name HackingMethod name A placeholder for the name. HackingTarget target std::vector< int > range A vector of {min, max} , defining the range of K . float step_size Indicates the step size of walking through K's. int min_observations Indicates minimum number of observations. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > prevalence The prevalence factor of the strategy. std::optional< float > defensibility The defensibility factor of the strategy. HackingStage stage Detailed Description \u00b6 struct sam :: SubjectiveOutlierRemoval :: Parameters ; SubjectiveOutlierRemoval 's parameters. These are parameters specific to this hacking strategy. You can set them either pragmatically when you are constructing a new SubjectiveOutlierRemoval , e.g., [SubjectiveOutlierRemoval](/doxygen/Classes/classsam_1_1_subjective_outlier_removal/) sor{<name>, {min, max}, ssize}; . Or, when you are using SAMrun to run your simulation. In this case, your JSON variable must comply with the name and type of parameters here. For example, the following JSON defines the default subjective outliers removal. { \"name\" : \"SubjectiveOutlierRemoval\" , \"range\" : [ 2 , 4 ], \"step_size\" : 0.1 , \"min_observations\" : 5 } Filename: .json Public Attributes Documentation \u00b6 variable name \u00b6 HackingMethod name = HackingMethod :: SubjectiveOutlierRemoval ; A placeholder for the name. variable target \u00b6 HackingTarget target { HackingTarget :: Both }; Todo : TO BE IMPLEMENTED variable range \u00b6 std :: vector < int > range ; A vector of {min, max} , defining the range of K . variable step_size \u00b6 float step_size ; Indicates the step size of walking through K's. variable min_observations \u00b6 int min_observations ; Indicates minimum number of observations. variable stopping_cond_defs \u00b6 std :: vector < std :: string > stopping_cond_defs {{ \"sig\" }}; Stopping condition PolicyChain definitions. variable prevalence \u00b6 std :: optional < float > prevalence ; The prevalence factor of the strategy. variable defensibility \u00b6 std :: optional < float > defensibility ; The defensibility factor of the strategy. variable stage \u00b6 HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::SubjectiveOutlierRemoval::Parameters"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#samsubjectiveoutlierremovalparameters","text":"Module: Parameters of Hacking Strategies SubjectiveOutlierRemoval 's parameters. More... #include <HackingStrategy.h>","title":"sam::SubjectiveOutlierRemoval::Parameters"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#public-attributes","text":"Name HackingMethod name A placeholder for the name. HackingTarget target std::vector< int > range A vector of {min, max} , defining the range of K . float step_size Indicates the step size of walking through K's. int min_observations Indicates minimum number of observations. std::vector< std::string > stopping_cond_defs Stopping condition PolicyChain definitions. std::optional< float > prevalence The prevalence factor of the strategy. std::optional< float > defensibility The defensibility factor of the strategy. HackingStage stage","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#detailed-description","text":"struct sam :: SubjectiveOutlierRemoval :: Parameters ; SubjectiveOutlierRemoval 's parameters. These are parameters specific to this hacking strategy. You can set them either pragmatically when you are constructing a new SubjectiveOutlierRemoval , e.g., [SubjectiveOutlierRemoval](/doxygen/Classes/classsam_1_1_subjective_outlier_removal/) sor{<name>, {min, max}, ssize}; . Or, when you are using SAMrun to run your simulation. In this case, your JSON variable must comply with the name and type of parameters here. For example, the following JSON defines the default subjective outliers removal. { \"name\" : \"SubjectiveOutlierRemoval\" , \"range\" : [ 2 , 4 ], \"step_size\" : 0.1 , \"min_observations\" : 5 } Filename: .json","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-name","text":"HackingMethod name = HackingMethod :: SubjectiveOutlierRemoval ; A placeholder for the name.","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-target","text":"HackingTarget target { HackingTarget :: Both }; Todo : TO BE IMPLEMENTED","title":"variable target"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-range","text":"std :: vector < int > range ; A vector of {min, max} , defining the range of K .","title":"variable range"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-step_size","text":"float step_size ; Indicates the step size of walking through K's.","title":"variable step_size"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-min_observations","text":"int min_observations ; Indicates minimum number of observations.","title":"variable min_observations"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-stopping_cond_defs","text":"std :: vector < std :: string > stopping_cond_defs {{ \"sig\" }}; Stopping condition PolicyChain definitions.","title":"variable stopping_cond_defs"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-prevalence","text":"std :: optional < float > prevalence ; The prevalence factor of the strategy.","title":"variable prevalence"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-defensibility","text":"std :: optional < float > defensibility ; The defensibility factor of the strategy.","title":"variable defensibility"},{"location":"doxygen/Classes/structsam_1_1_subjective_outlier_removal_1_1_parameters/#variable-stage","text":"HackingStage stage { HackingStage :: PostProcessing }; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable stage"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/","text":"sam::TTest::Parameters \u00b6 Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TTest::Parameters , name , alternative , alpha , var_equal ) Public Attributes \u00b6 Name TestMethod name TestAlternative alternative float alpha bool var_equal Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TTest :: Parameters , name , alternative , alpha , var_equal ) Public Attributes Documentation \u00b6 variable name \u00b6 TestMethod name = [ TestMethod :: TTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - ttest ); variable alternative \u00b6 TestAlternative alternative = TestAlternative :: TwoSided ; variable alpha \u00b6 float alpha ; variable var_equal \u00b6 bool var_equal { true }; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::TTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#samttestparameters","text":"","title":"sam::TTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TTest::Parameters , name , alternative , alpha , var_equal )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#public-attributes","text":"Name TestMethod name TestAlternative alternative float alpha bool var_equal","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TTest :: Parameters , name , alternative , alpha , var_equal )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#variable-name","text":"TestMethod name = [ TestMethod :: TTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - ttest );","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#variable-alternative","text":"TestAlternative alternative = TestAlternative :: TwoSided ;","title":"variable alternative"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#variable-alpha","text":"float alpha ;","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_parameters/#variable-var_equal","text":"bool var_equal { true }; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable var_equal"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/","text":"sam::TTest::ResultType \u00b6 Public Attributes \u00b6 Name float tstat float df float pvalue int side bool sig Friends \u00b6 Name std::ostream & operator<< (std::ostream & os, const ResultType & type) Public Attributes Documentation \u00b6 variable tstat \u00b6 float tstat ; variable df \u00b6 float df ; variable pvalue \u00b6 float pvalue ; variable side \u00b6 int side ; variable sig \u00b6 bool sig ; Friends \u00b6 friend operator<< \u00b6 friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::TTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#samttestresulttype","text":"","title":"sam::TTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#public-attributes","text":"Name float tstat float df float pvalue int side bool sig","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const ResultType & type)","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#variable-tstat","text":"float tstat ;","title":"variable tstat"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#variable-df","text":"float df ;","title":"variable df"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#variable-pvalue","text":"float pvalue ;","title":"variable pvalue"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#variable-side","text":"int side ;","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#variable-sig","text":"bool sig ;","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_t_test_1_1_result_type/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"friend operator&lt;&lt;"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/","text":"sam::TestOfObsOverExptSig::Parameters \u00b6 Module: Parameters of Meta Anlaysis Methods More... #include <MetaAnalysis.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TestOfObsOverExptSig::Parameters , name , alpha ) Public Attributes \u00b6 Name std::string name float alpha Detailed Description \u00b6 struct sam :: TestOfObsOverExptSig :: Parameters ; Parameters of TestOfObsOverExptSig Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TestOfObsOverExptSig :: Parameters , name , alpha ) Public Attributes Documentation \u00b6 variable name \u00b6 std :: string name { \"TestOfObsOverExptSig\" }; variable alpha \u00b6 float alpha { 0.10 }; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::TestOfObsOverExptSig::Parameters"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#samtestofobsoverexptsigparameters","text":"Module: Parameters of Meta Anlaysis Methods More... #include <MetaAnalysis.h>","title":"sam::TestOfObsOverExptSig::Parameters"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TestOfObsOverExptSig::Parameters , name , alpha )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#public-attributes","text":"Name std::string name float alpha","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#detailed-description","text":"struct sam :: TestOfObsOverExptSig :: Parameters ; Parameters of TestOfObsOverExptSig","title":"Detailed Description"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TestOfObsOverExptSig :: Parameters , name , alpha )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#variable-name","text":"std :: string name { \"TestOfObsOverExptSig\" };","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_parameters/#variable-alpha","text":"float alpha { 0.10 }; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/","text":"sam::TestOfObsOverExptSig::ResultType \u00b6 Public Functions \u00b6 Name std::vector< std::string > Columns () Public Attributes \u00b6 Name float E Sum of the expected probabilities. float A The chi-square statistic of the test. float pval The p-value of the test. bool sig The significance of the test. Public Functions Documentation \u00b6 function Columns \u00b6 static inline std :: vector < std :: string > Columns () Public Attributes Documentation \u00b6 variable E \u00b6 float E ; Sum of the expected probabilities. variable A \u00b6 float A ; The chi-square statistic of the test. variable pval \u00b6 float pval ; The p-value of the test. variable sig \u00b6 bool sig ; The significance of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::TestOfObsOverExptSig::ResultType"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#samtestofobsoverexptsigresulttype","text":"","title":"sam::TestOfObsOverExptSig::ResultType"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#public-functions","text":"Name std::vector< std::string > Columns ()","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#public-attributes","text":"Name float E Sum of the expected probabilities. float A The chi-square statistic of the test. float pval The p-value of the test. bool sig The significance of the test.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#function-columns","text":"static inline std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#variable-e","text":"float E ; Sum of the expected probabilities.","title":"variable E"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#variable-a","text":"float A ; The chi-square statistic of the test.","title":"variable A"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#variable-pval","text":"float pval ; The p-value of the test.","title":"variable pval"},{"location":"doxygen/Classes/structsam_1_1_test_of_obs_over_expt_sig_1_1_result_type/#variable-sig","text":"bool sig ; The significance of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/","text":"sam::TrimAndFill::Parameters \u00b6 Parameters of the TrimAndFill . #include <MetaAnalysis.h> Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TrimAndFill::Parameters , name , side , estimator , alpha ) Public Attributes \u00b6 Name std::string name std::string side Indicates the side of the funnel plot where missing values should be imputed. std::string estimator The symmetry estimator. float alpha The \u0251 of the test. Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TrimAndFill :: Parameters , name , side , estimator , alpha ) Public Attributes Documentation \u00b6 variable name \u00b6 std :: string name { \"TrimAndFill\" }; variable side \u00b6 std :: string side { \"auto\" }; Indicates the side of the funnel plot where missing values should be imputed. variable estimator \u00b6 std :: string estimator { \"R0\" }; The symmetry estimator. variable alpha \u00b6 float alpha { 0.10 }; The \u0251 of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::TrimAndFill::Parameters"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#samtrimandfillparameters","text":"Parameters of the TrimAndFill . #include <MetaAnalysis.h>","title":"sam::TrimAndFill::Parameters"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TrimAndFill::Parameters , name , side , estimator , alpha )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#public-attributes","text":"Name std::string name std::string side Indicates the side of the funnel plot where missing values should be imputed. std::string estimator The symmetry estimator. float alpha The \u0251 of the test.","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( TrimAndFill :: Parameters , name , side , estimator , alpha )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#variable-name","text":"std :: string name { \"TrimAndFill\" };","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#variable-side","text":"std :: string side { \"auto\" }; Indicates the side of the funnel plot where missing values should be imputed.","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#variable-estimator","text":"std :: string estimator { \"R0\" }; The symmetry estimator.","title":"variable estimator"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_parameters/#variable-alpha","text":"float alpha { 0.10 }; The \u0251 of the test. Updated on 29 June 2021 at 16:13:47 CEST","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/","text":"sam::TrimAndFill::ResultType \u00b6 Public Functions \u00b6 Name std::vector< std::string > Columns () Public Attributes \u00b6 Name float k0 float se_k0 float k_all std::string side float imputed_est float imputed_pval Public Functions Documentation \u00b6 function Columns \u00b6 static inline std :: vector < std :: string > Columns () Public Attributes Documentation \u00b6 variable k0 \u00b6 float k0 ; variable se_k0 \u00b6 float se_k0 ; variable k_all \u00b6 float k_all ; variable side \u00b6 std :: string side ; variable imputed_est \u00b6 float imputed_est ; variable imputed_pval \u00b6 float imputed_pval ; Updated on 29 June 2021 at 16:13:47 CEST","title":"sam::TrimAndFill::ResultType"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#samtrimandfillresulttype","text":"","title":"sam::TrimAndFill::ResultType"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#public-functions","text":"Name std::vector< std::string > Columns ()","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#public-attributes","text":"Name float k0 float se_k0 float k_all std::string side float imputed_est float imputed_pval","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#function-columns","text":"static inline std :: vector < std :: string > Columns ()","title":"function Columns"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#variable-k0","text":"float k0 ;","title":"variable k0"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#variable-se_k0","text":"float se_k0 ;","title":"variable se_k0"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#variable-k_all","text":"float k_all ;","title":"variable k_all"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#variable-side","text":"std :: string side ;","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#variable-imputed_est","text":"float imputed_est ;","title":"variable imputed_est"},{"location":"doxygen/Classes/structsam_1_1_trim_and_fill_1_1_result_type/#variable-imputed_pval","text":"float imputed_pval ; Updated on 29 June 2021 at 16:13:47 CEST","title":"variable imputed_pval"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/","text":"sam::WilcoxonTest::Parameters \u00b6 Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( WilcoxonTest::Parameters , name , alternative , alpha , use_continuity ) Public Attributes \u00b6 Name TestMethod name TestAlternative alternative float alpha bool use_continuity Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( WilcoxonTest :: Parameters , name , alternative , alpha , use_continuity ) Public Attributes Documentation \u00b6 variable name \u00b6 TestMethod name = [ TestMethod :: WilcoxonTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - wilcoxontest ); variable alternative \u00b6 TestAlternative alternative = TestAlternative :: TwoSided ; variable alpha \u00b6 float alpha = 0.95 ; variable use_continuity \u00b6 bool use_continuity { true }; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::WilcoxonTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#samwilcoxontestparameters","text":"","title":"sam::WilcoxonTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( WilcoxonTest::Parameters , name , alternative , alpha , use_continuity )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#public-attributes","text":"Name TestMethod name TestAlternative alternative float alpha bool use_continuity","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( WilcoxonTest :: Parameters , name , alternative , alpha , use_continuity )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#variable-name","text":"TestMethod name = [ TestMethod :: WilcoxonTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - wilcoxontest );","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#variable-alternative","text":"TestAlternative alternative = TestAlternative :: TwoSided ;","title":"variable alternative"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#variable-alpha","text":"float alpha = 0.95 ;","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_parameters/#variable-use_continuity","text":"bool use_continuity { true }; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable use_continuity"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/","text":"sam::WilcoxonTest::ResultType \u00b6 Public Attributes \u00b6 Name float zstat float wstat float pvalue int side bool sig Friends \u00b6 Name std::ostream & operator<< (std::ostream & os, const ResultType & type) Public Attributes Documentation \u00b6 variable zstat \u00b6 float zstat ; variable wstat \u00b6 float wstat ; variable pvalue \u00b6 float pvalue ; variable side \u00b6 int side ; variable sig \u00b6 bool sig ; Friends \u00b6 friend operator<< \u00b6 friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::WilcoxonTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#samwilcoxontestresulttype","text":"","title":"sam::WilcoxonTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#public-attributes","text":"Name float zstat float wstat float pvalue int side bool sig","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const ResultType & type)","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#variable-zstat","text":"float zstat ;","title":"variable zstat"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#variable-wstat","text":"float wstat ;","title":"variable wstat"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#variable-pvalue","text":"float pvalue ;","title":"variable pvalue"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#variable-side","text":"int side ;","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#variable-sig","text":"bool sig ;","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_wilcoxon_test_1_1_result_type/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"friend operator&lt;&lt;"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/","text":"sam::YuenTest::Parameters \u00b6 Public Functions \u00b6 Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( YuenTest::Parameters , name , alternative , alpha , trim , paired ) Public Attributes \u00b6 Name TestMethod name TestAlternative alternative float alpha float trim bool paired Public Functions Documentation \u00b6 function NLOHMANN_DEFINE_TYPE_INTRUSIVE \u00b6 NLOHMANN_DEFINE_TYPE_INTRUSIVE ( YuenTest :: Parameters , name , alternative , alpha , trim , paired ) Public Attributes Documentation \u00b6 variable name \u00b6 TestMethod name = [ TestMethod :: YuenTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - yuentest ); variable alternative \u00b6 TestAlternative alternative = TestAlternative :: TwoSided ; variable alpha \u00b6 float alpha { 0.05 }; variable trim \u00b6 float trim { 0.20 }; variable paired \u00b6 bool paired { false }; Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::YuenTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#samyuentestparameters","text":"","title":"sam::YuenTest::Parameters"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#public-functions","text":"Name NLOHMANN_DEFINE_TYPE_INTRUSIVE ( YuenTest::Parameters , name , alternative , alpha , trim , paired )","title":"Public Functions"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#public-attributes","text":"Name TestMethod name TestAlternative alternative float alpha float trim bool paired","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#function-nlohmann_define_type_intrusive","text":"NLOHMANN_DEFINE_TYPE_INTRUSIVE ( YuenTest :: Parameters , name , alternative , alpha , trim , paired )","title":"function NLOHMANN_DEFINE_TYPE_INTRUSIVE"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#variable-name","text":"TestMethod name = [ TestMethod :: YuenTest ]( / doxygen / Classes / classsam_1_1_test_strategy / # enumvalue - yuentest );","title":"variable name"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#variable-alternative","text":"TestAlternative alternative = TestAlternative :: TwoSided ;","title":"variable alternative"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#variable-alpha","text":"float alpha { 0.05 };","title":"variable alpha"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#variable-trim","text":"float trim { 0.20 };","title":"variable trim"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_parameters/#variable-paired","text":"bool paired { false }; Updated on 29 June 2021 at 16:13:48 CEST","title":"variable paired"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/","text":"sam::YuenTest::ResultType \u00b6 Public Attributes \u00b6 Name float tstat float df float pvalue int side bool sig Friends \u00b6 Name std::ostream & operator<< (std::ostream & os, const ResultType & type) Public Attributes Documentation \u00b6 variable tstat \u00b6 float tstat ; variable df \u00b6 float df ; variable pvalue \u00b6 float pvalue ; variable side \u00b6 int side ; variable sig \u00b6 bool sig ; Friends \u00b6 friend operator<< \u00b6 friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"sam::YuenTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#samyuentestresulttype","text":"","title":"sam::YuenTest::ResultType"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#public-attributes","text":"Name float tstat float df float pvalue int side bool sig","title":"Public Attributes"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#friends","text":"Name std::ostream & operator<< (std::ostream & os, const ResultType & type)","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#variable-tstat","text":"float tstat ;","title":"variable tstat"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#variable-df","text":"float df ;","title":"variable df"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#variable-pvalue","text":"float pvalue ;","title":"variable pvalue"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#variable-side","text":"int side ;","title":"variable side"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#variable-sig","text":"bool sig ;","title":"variable sig"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#friends_1","text":"","title":"Friends"},{"location":"doxygen/Classes/structsam_1_1_yuen_test_1_1_result_type/#friend-operator","text":"friend std :: ostream & operator << ( std :: ostream & os , const ResultType & type ); Updated on 29 June 2021 at 16:13:48 CEST","title":"friend operator&lt;&lt;"},{"location":"doxygen/Modules/","text":"Modules \u00b6 group Abstract Factory Builders List of Abstract Factory Builder classes. group Data Strategies List of available Data Strategies. group Machinery of Building a Distribution Object group Effect Strategies List of available effect strategies. group Experiment Modules Experiment-related Modules. group Hacking Strategies List of available hacking strategies. group Parameters of Hacking Strategies Description of hacking strategies parameters. group Meta Analysis Methods List of available Meta Analysis. group Parameters of Meta Anlaysis Methods List of available Parameters. group Policy-related Modules List of available policy-related modules. group Research Strategies List of available Research Strategies. group Parameters of the Research Strategies group Review Strategies group Parameters of Review Strategies group Test Strategies List of available Test Strategies. Updated on 29 June 2021 at 16:13:48 CEST","title":"Modules"},{"location":"doxygen/Modules/#modules","text":"group Abstract Factory Builders List of Abstract Factory Builder classes. group Data Strategies List of available Data Strategies. group Machinery of Building a Distribution Object group Effect Strategies List of available effect strategies. group Experiment Modules Experiment-related Modules. group Hacking Strategies List of available hacking strategies. group Parameters of Hacking Strategies Description of hacking strategies parameters. group Meta Analysis Methods List of available Meta Analysis. group Parameters of Meta Anlaysis Methods List of available Parameters. group Policy-related Modules List of available policy-related modules. group Research Strategies List of available Research Strategies. group Parameters of the Research Strategies group Review Strategies group Parameters of Review Strategies group Test Strategies List of available Test Strategies. Updated on 29 June 2021 at 16:13:48 CEST","title":"Modules"},{"location":"doxygen/Modules/group___abstract_builders/","text":"Abstract Factory Builders \u00b6 List of Abstract Factory Builder classes. More... Classes \u00b6 Name class sam::ExperimentSetupBuilder class sam::ResearcherBuilder Detailed Description \u00b6 List of Abstract Factory Builder classes. Description to come! Updated on 29 June 2021 at 16:13:48 CEST","title":"Abstract Factory Builders"},{"location":"doxygen/Modules/group___abstract_builders/#abstract-factory-builders","text":"List of Abstract Factory Builder classes. More...","title":"Abstract Factory Builders"},{"location":"doxygen/Modules/group___abstract_builders/#classes","text":"Name class sam::ExperimentSetupBuilder class sam::ResearcherBuilder","title":"Classes"},{"location":"doxygen/Modules/group___abstract_builders/#detailed-description","text":"List of Abstract Factory Builder classes. Description to come! Updated on 29 June 2021 at 16:13:48 CEST","title":"Detailed Description"},{"location":"doxygen/Modules/group___data_startegies/","text":"Data Strategies \u00b6 List of available Data Strategies. More... Detailed Description \u00b6 List of available Data Strategies. Description to come! Updated on 7 December 2020 at 11:46:01 CET","title":"Data Strategies"},{"location":"doxygen/Modules/group___data_startegies/#data-strategies","text":"List of available Data Strategies. More...","title":"Data Strategies"},{"location":"doxygen/Modules/group___data_startegies/#detailed-description","text":"List of available Data Strategies. Description to come! Updated on 7 December 2020 at 11:46:01 CET","title":"Detailed Description"},{"location":"doxygen/Modules/group___data_strategies/","text":"Data Strategies \u00b6 List of available Data Strategies. More... Classes \u00b6 Name class sam::DataStrategy Abstract class for Data Strategies. class sam::LinearModelStrategy Linear Model Data Strategy. class sam::LatentDataStrategy \u26a0\ufe0f TO BE IMPLEMENTED! class sam::GRMDataStrategy Simulate data based on General Graded Response Model. Detailed Description \u00b6 List of available Data Strategies. Description to come! Updated on 29 June 2021 at 16:13:47 CEST","title":"Data Strategies"},{"location":"doxygen/Modules/group___data_strategies/#data-strategies","text":"List of available Data Strategies. More...","title":"Data Strategies"},{"location":"doxygen/Modules/group___data_strategies/#classes","text":"Name class sam::DataStrategy Abstract class for Data Strategies. class sam::LinearModelStrategy Linear Model Data Strategy. class sam::LatentDataStrategy \u26a0\ufe0f TO BE IMPLEMENTED! class sam::GRMDataStrategy Simulate data based on General Graded Response Model.","title":"Classes"},{"location":"doxygen/Modules/group___data_strategies/#detailed-description","text":"List of available Data Strategies. Description to come! Updated on 29 June 2021 at 16:13:47 CEST","title":"Detailed Description"},{"location":"doxygen/Modules/group___decision_strategies/","text":"Decision Strategies \u00b6 List of available Decision Strategies. More... Classes \u00b6 Name class sam::DefaultDecisionMaker Detailed Description \u00b6 List of available Decision Strategies. Description to come!","title":"Decision Strategies"},{"location":"doxygen/Modules/group___decision_strategies/#decision-strategies","text":"List of available Decision Strategies. More...","title":"Decision Strategies"},{"location":"doxygen/Modules/group___decision_strategies/#classes","text":"Name class sam::DefaultDecisionMaker","title":"Classes"},{"location":"doxygen/Modules/group___decision_strategies/#detailed-description","text":"List of available Decision Strategies. Description to come!","title":"Detailed Description"},{"location":"doxygen/Modules/group___distribution_builders/","text":"Machinery of Building a Distribution Object \u00b6 Updated on 29 June 2021 at 16:13:47 CEST","title":"Machinery of Building a Distribution Object"},{"location":"doxygen/Modules/group___distribution_builders/#machinery-of-building-a-distribution-object","text":"Updated on 29 June 2021 at 16:13:47 CEST","title":"Machinery of Building a Distribution Object"},{"location":"doxygen/Modules/group___effect_strategies/","text":"Effect Strategies \u00b6 List of available effect strategies. ## Classes Name class sam::MeanDifference class sam::StandardizedMeanDifference class sam::CohensD class sam::HedgesG Updated on 29 June 2021 at 16:13:47 CEST","title":"Effect Strategies"},{"location":"doxygen/Modules/group___effect_strategies/#effect-strategies","text":"List of available effect strategies. ## Classes Name class sam::MeanDifference class sam::StandardizedMeanDifference class sam::CohensD class sam::HedgesG Updated on 29 June 2021 at 16:13:47 CEST","title":"Effect Strategies"},{"location":"doxygen/Modules/group___experiment/","text":"Experiment Modules \u00b6 Experiment-related Modules. ## Classes Name class sam::Experiment Experiment encapsulates data and methods needed by the Researcher to conduct its research. class sam::ExperimentSetup Declaration of ExperimentSetup class. Updated on 29 June 2021 at 16:13:47 CEST","title":"Experiment Modules"},{"location":"doxygen/Modules/group___experiment/#experiment-modules","text":"Experiment-related Modules. ## Classes Name class sam::Experiment Experiment encapsulates data and methods needed by the Researcher to conduct its research. class sam::ExperimentSetup Declaration of ExperimentSetup class. Updated on 29 June 2021 at 16:13:47 CEST","title":"Experiment Modules"},{"location":"doxygen/Modules/group___hacking_strategies/","text":"Hacking Strategies \u00b6 List of available hacking strategies. ## Classes Name class sam::HackingStrategy Abstract Class of Hacking Strategies. class sam::OptionalStopping class sam::OutliersRemoval Declaration of Outlier Removal hacking method based on items' distance from their sample mean. class sam::SubjectiveOutlierRemoval The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. class sam::GroupPooling class sam::QuestionableRounding class sam::PeekingOutliersRemoval class sam::FalsifyingData class sam::FabricatingData class sam::StoppingDataCollection class sam::OptionalDropping Updated on 29 June 2021 at 16:13:47 CEST","title":"Hacking Strategies"},{"location":"doxygen/Modules/group___hacking_strategies/#hacking-strategies","text":"List of available hacking strategies. ## Classes Name class sam::HackingStrategy Abstract Class of Hacking Strategies. class sam::OptionalStopping class sam::OutliersRemoval Declaration of Outlier Removal hacking method based on items' distance from their sample mean. class sam::SubjectiveOutlierRemoval The subjective outlier removal refers to a type of outliers removal where the researcher continuously lowers the threshold of identifying an outlier, k , until it finds a significant (or satisfactory) result. class sam::GroupPooling class sam::QuestionableRounding class sam::PeekingOutliersRemoval class sam::FalsifyingData class sam::FabricatingData class sam::StoppingDataCollection class sam::OptionalDropping Updated on 29 June 2021 at 16:13:47 CEST","title":"Hacking Strategies"},{"location":"doxygen/Modules/group___hacking_strategies_parameters/","text":"Parameters of Hacking Strategies \u00b6 Description of hacking strategies parameters. ## Classes Name struct sam::OptionalStopping::Parameters struct sam::OutliersRemoval::Parameters struct sam::SubjectiveOutlierRemoval::Parameters SubjectiveOutlierRemoval 's parameters. struct sam::QuestionableRounding::Parameters struct sam::PeekingOutliersRemoval::Parameters struct sam::FalsifyingData::Parameters struct sam::FabricatingData::Parameters struct sam::StoppingDataCollection::Parameters struct sam::OptionalDropping::Parameters Updated on 29 June 2021 at 16:13:47 CEST","title":"Parameters of Hacking Strategies"},{"location":"doxygen/Modules/group___hacking_strategies_parameters/#parameters-of-hacking-strategies","text":"Description of hacking strategies parameters. ## Classes Name struct sam::OptionalStopping::Parameters struct sam::OutliersRemoval::Parameters struct sam::SubjectiveOutlierRemoval::Parameters SubjectiveOutlierRemoval 's parameters. struct sam::QuestionableRounding::Parameters struct sam::PeekingOutliersRemoval::Parameters struct sam::FalsifyingData::Parameters struct sam::FabricatingData::Parameters struct sam::StoppingDataCollection::Parameters struct sam::OptionalDropping::Parameters Updated on 29 June 2021 at 16:13:47 CEST","title":"Parameters of Hacking Strategies"},{"location":"doxygen/Modules/group___meta_analysis/","text":"Meta Analysis Methods \u00b6 List of available Meta Analysis. More... Classes \u00b6 Name class sam::RandomEffectEstimator Random Effect Estimator. class sam::FixedEffectEstimator Fixed Effect Estimator. class sam::EggersTestEstimator Egger's Test of Funnel Plot Symmetry. class sam::TestOfObsOverExptSig Test of Excess of Significant Findings. class sam::TrimAndFill Trim and Fill Publication Bias Test. class sam::RankCorrelation Begg's Rank Correlation Test. Detailed Description \u00b6 List of available Meta Analysis. Description to come! Updated on 29 June 2021 at 16:13:47 CEST","title":"Meta Analysis Methods"},{"location":"doxygen/Modules/group___meta_analysis/#meta-analysis-methods","text":"List of available Meta Analysis. More...","title":"Meta Analysis Methods"},{"location":"doxygen/Modules/group___meta_analysis/#classes","text":"Name class sam::RandomEffectEstimator Random Effect Estimator. class sam::FixedEffectEstimator Fixed Effect Estimator. class sam::EggersTestEstimator Egger's Test of Funnel Plot Symmetry. class sam::TestOfObsOverExptSig Test of Excess of Significant Findings. class sam::TrimAndFill Trim and Fill Publication Bias Test. class sam::RankCorrelation Begg's Rank Correlation Test.","title":"Classes"},{"location":"doxygen/Modules/group___meta_analysis/#detailed-description","text":"List of available Meta Analysis. Description to come! Updated on 29 June 2021 at 16:13:47 CEST","title":"Detailed Description"},{"location":"doxygen/Modules/group___meta_analysis_parameters/","text":"Parameters of Meta Anlaysis Methods \u00b6 List of available Parameters. More... Classes \u00b6 Name struct sam::RandomEffectEstimator::Parameters Parameters of the RandomEffectEstimator . struct sam::EggersTestEstimator::Parameters Parameters of the EggersTestEstimator . struct sam::TestOfObsOverExptSig::Parameters struct sam::RankCorrelation::Parameters Parameters of RankCorrelation . Detailed Description \u00b6 List of available Parameters. Description to come! Updated on 29 June 2021 at 16:13:47 CEST","title":"Parameters of Meta Anlaysis Methods"},{"location":"doxygen/Modules/group___meta_analysis_parameters/#parameters-of-meta-anlaysis-methods","text":"List of available Parameters. More...","title":"Parameters of Meta Anlaysis Methods"},{"location":"doxygen/Modules/group___meta_analysis_parameters/#classes","text":"Name struct sam::RandomEffectEstimator::Parameters Parameters of the RandomEffectEstimator . struct sam::EggersTestEstimator::Parameters Parameters of the EggersTestEstimator . struct sam::TestOfObsOverExptSig::Parameters struct sam::RankCorrelation::Parameters Parameters of RankCorrelation .","title":"Classes"},{"location":"doxygen/Modules/group___meta_analysis_parameters/#detailed-description","text":"List of available Parameters. Description to come! Updated on 29 June 2021 at 16:13:47 CEST","title":"Detailed Description"},{"location":"doxygen/Modules/group___policies/","text":"Policy-related Modules \u00b6 List of available policy-related modules. ## Classes Name struct sam::Policy Implementation of the Policy class. struct sam::PolicyChain Implementation of the PolicyChain class. struct sam::PolicyChainSet Types \u00b6 Name enum int PolicyType { Min, Max, Comp, Random, First, Last, All} Indicates the type of the Policy . enum int PolicyChainType { Selection, Decision} Indicates the type of the PolicyChain . using std::vector< std::vector< std::variant< std::shared_ptr< HackingStrategy >, PolicyChain, PolicyChainSet > >> HackingWorkflow Types Documentation \u00b6 enum PolicyType \u00b6 Enumerator Value Description Min Max Comp Random First Last All Indicates the type of the Policy . This is mainly being used by Policy to decide which type of formula it's dealing with. enum PolicyChainType \u00b6 Enumerator Value Description Selection Decision Indicates the type of the PolicyChain . A PolicyChain can either be used to perform selection , or a decision . The main difference between them being that the ::Selection chains could include a function call, e.g., min , while the ::Decision chains cannot. using HackingWorkflow \u00b6 using sam :: HackingWorkflow = typedef std :: vector < std :: vector < std :: variant < std :: shared_ptr < HackingStrategy > , PolicyChain , PolicyChainSet > >> ; See : Researcher::hackTheResearch() The representation of the Hacking Workflow This is defined to capture a sequence of hacking \u2192 selection \u2192 decision . While it looks rather strange, it allows for some nice and flexible setup using the std::visit(). Updated on 29 June 2021 at 16:13:48 CEST","title":"Policy-related Modules"},{"location":"doxygen/Modules/group___policies/#policy-related-modules","text":"List of available policy-related modules. ## Classes Name struct sam::Policy Implementation of the Policy class. struct sam::PolicyChain Implementation of the PolicyChain class. struct sam::PolicyChainSet","title":"Policy-related Modules"},{"location":"doxygen/Modules/group___policies/#types","text":"Name enum int PolicyType { Min, Max, Comp, Random, First, Last, All} Indicates the type of the Policy . enum int PolicyChainType { Selection, Decision} Indicates the type of the PolicyChain . using std::vector< std::vector< std::variant< std::shared_ptr< HackingStrategy >, PolicyChain, PolicyChainSet > >> HackingWorkflow","title":"Types"},{"location":"doxygen/Modules/group___policies/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxygen/Modules/group___policies/#enum-policytype","text":"Enumerator Value Description Min Max Comp Random First Last All Indicates the type of the Policy . This is mainly being used by Policy to decide which type of formula it's dealing with.","title":"enum PolicyType"},{"location":"doxygen/Modules/group___policies/#enum-policychaintype","text":"Enumerator Value Description Selection Decision Indicates the type of the PolicyChain . A PolicyChain can either be used to perform selection , or a decision . The main difference between them being that the ::Selection chains could include a function call, e.g., min , while the ::Decision chains cannot.","title":"enum PolicyChainType"},{"location":"doxygen/Modules/group___policies/#using-hackingworkflow","text":"using sam :: HackingWorkflow = typedef std :: vector < std :: vector < std :: variant < std :: shared_ptr < HackingStrategy > , PolicyChain , PolicyChainSet > >> ; See : Researcher::hackTheResearch() The representation of the Hacking Workflow This is defined to capture a sequence of hacking \u2192 selection \u2192 decision . While it looks rather strange, it allows for some nice and flexible setup using the std::visit(). Updated on 29 June 2021 at 16:13:48 CEST","title":"using HackingWorkflow"},{"location":"doxygen/Modules/group___research_strategies/","text":"Research Strategies \u00b6 List of available Research Strategies. ## Classes Name class sam::DefaultResearchStrategy The deceleration of the default research strategy. Updated on 29 June 2021 at 16:13:48 CEST","title":"Research Strategies"},{"location":"doxygen/Modules/group___research_strategies/#research-strategies","text":"List of available Research Strategies. ## Classes Name class sam::DefaultResearchStrategy The deceleration of the default research strategy. Updated on 29 June 2021 at 16:13:48 CEST","title":"Research Strategies"},{"location":"doxygen/Modules/group___research_strategy_parameters/","text":"Parameters of the Research Strategies \u00b6 Classes \u00b6 Name struct sam::DefaultResearchStrategy::Parameters The parameters of the strategy. Updated on 29 June 2021 at 16:13:48 CEST","title":"Parameters of the Research Strategies"},{"location":"doxygen/Modules/group___research_strategy_parameters/#parameters-of-the-research-strategies","text":"","title":"Parameters of the Research Strategies"},{"location":"doxygen/Modules/group___research_strategy_parameters/#classes","text":"Name struct sam::DefaultResearchStrategy::Parameters The parameters of the strategy. Updated on 29 June 2021 at 16:13:48 CEST","title":"Classes"},{"location":"doxygen/Modules/group___review_strategies/","text":"Review Strategies \u00b6 Classes \u00b6 Name class sam::PolicyBasedSelection Policy-based Selection Strategy. class sam::SignificantSelection Significant-based Selection Strategy. class sam::RandomSelection Random Selection Strategy. class sam::FreeSelection FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted. Functions \u00b6 Name NLOHMANN_JSON_SERIALIZE_ENUM (SelectionMethod , {{SelectionMethod::PolicyBasedSelection, \"PolicyBasedSelection\"}, {SelectionMethod::SignificantSelection, \"SignificantSelection\"}, {SelectionMethod::RandomSelection, \"RandomSelection\"}, {SelectionMethod::FreeSelection, \"FreeSelection\"}} ) Abstract class for Journal 's selection strategies. Functions Documentation \u00b6 function NLOHMANN_JSON_SERIALIZE_ENUM \u00b6 NLOHMANN_JSON_SERIALIZE_ENUM ( SelectionMethod , {{ SelectionMethod :: PolicyBasedSelection , \"PolicyBasedSelection\" }, { SelectionMethod :: SignificantSelection , \"SignificantSelection\" }, { SelectionMethod :: RandomSelection , \"RandomSelection\" }, { SelectionMethod :: FreeSelection , \"FreeSelection\" }} ) Abstract class for Journal 's selection strategies. A Journal will decide if a Submission is going to be accepted or rejected. This decision can be made based on different criteria or formula. A ReviewStrategy provides an interface for implementing different selection strategies. Pure destructors of the base class Lua's state Selection method's name Constructs the Review Strategy Factory method for building a ReviewStrategy The abstract review method It reviews the submissions and decides if it's going to be accepted or rejected. When deriving from ReviewStrategy, `review` is the main interface and `Journal` relies on its output sA reference to a Submission Returns 'true' if the any of the submissions are going to be accepted. The abstract review method. Like the method above, but this one reviews the entire Experiment instead. It's not yet been used anywhere though SAM, but it will eventually replace the submission review method. exprThe experiment Returns true if the Experiment is going to be accepted. Updated on 29 June 2021 at 16:13:48 CEST","title":"Review Strategies"},{"location":"doxygen/Modules/group___review_strategies/#review-strategies","text":"","title":"Review Strategies"},{"location":"doxygen/Modules/group___review_strategies/#classes","text":"Name class sam::PolicyBasedSelection Policy-based Selection Strategy. class sam::SignificantSelection Significant-based Selection Strategy. class sam::RandomSelection Random Selection Strategy. class sam::FreeSelection FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted.","title":"Classes"},{"location":"doxygen/Modules/group___review_strategies/#functions","text":"Name NLOHMANN_JSON_SERIALIZE_ENUM (SelectionMethod , {{SelectionMethod::PolicyBasedSelection, \"PolicyBasedSelection\"}, {SelectionMethod::SignificantSelection, \"SignificantSelection\"}, {SelectionMethod::RandomSelection, \"RandomSelection\"}, {SelectionMethod::FreeSelection, \"FreeSelection\"}} ) Abstract class for Journal 's selection strategies.","title":"Functions"},{"location":"doxygen/Modules/group___review_strategies/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxygen/Modules/group___review_strategies/#function-nlohmann_json_serialize_enum","text":"NLOHMANN_JSON_SERIALIZE_ENUM ( SelectionMethod , {{ SelectionMethod :: PolicyBasedSelection , \"PolicyBasedSelection\" }, { SelectionMethod :: SignificantSelection , \"SignificantSelection\" }, { SelectionMethod :: RandomSelection , \"RandomSelection\" }, { SelectionMethod :: FreeSelection , \"FreeSelection\" }} ) Abstract class for Journal 's selection strategies. A Journal will decide if a Submission is going to be accepted or rejected. This decision can be made based on different criteria or formula. A ReviewStrategy provides an interface for implementing different selection strategies. Pure destructors of the base class Lua's state Selection method's name Constructs the Review Strategy Factory method for building a ReviewStrategy The abstract review method It reviews the submissions and decides if it's going to be accepted or rejected. When deriving from ReviewStrategy, `review` is the main interface and `Journal` relies on its output sA reference to a Submission Returns 'true' if the any of the submissions are going to be accepted. The abstract review method. Like the method above, but this one reviews the entire Experiment instead. It's not yet been used anywhere though SAM, but it will eventually replace the submission review method. exprThe experiment Returns true if the Experiment is going to be accepted. Updated on 29 June 2021 at 16:13:48 CEST","title":"function NLOHMANN_JSON_SERIALIZE_ENUM"},{"location":"doxygen/Modules/group___review_strategies_parameters/","text":"Parameters of Review Strategies \u00b6 Classes \u00b6 Name struct sam::PolicyBasedSelection::Parameters Parameters of the Policy-based Selection. struct sam::SignificantSelection::Parameters struct sam::RandomSelection::Parameters Parameter of Random Selection review strategy. struct sam::FreeSelection::Parameters Parameters of free selection. Updated on 29 June 2021 at 16:13:48 CEST","title":"Parameters of Review Strategies"},{"location":"doxygen/Modules/group___review_strategies_parameters/#parameters-of-review-strategies","text":"","title":"Parameters of Review Strategies"},{"location":"doxygen/Modules/group___review_strategies_parameters/#classes","text":"Name struct sam::PolicyBasedSelection::Parameters Parameters of the Policy-based Selection. struct sam::SignificantSelection::Parameters struct sam::RandomSelection::Parameters Parameter of Random Selection review strategy. struct sam::FreeSelection::Parameters Parameters of free selection. Updated on 29 June 2021 at 16:13:48 CEST","title":"Classes"},{"location":"doxygen/Modules/group___selection_strategies/","text":"Selection Strategies \u00b6 List of available Selection Strategies. More... Classes \u00b6 Name class sam::PolicyBasedSelection Policy-based Selection Strategy. class sam::SignificantSelection Significant-based Selection Strategy. class sam::RandomSelection Random Selection Strategy. class sam::FreeSelection FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted. Detailed Description \u00b6 List of available Selection Strategies. Description to come!","title":"Selection Strategies"},{"location":"doxygen/Modules/group___selection_strategies/#selection-strategies","text":"List of available Selection Strategies. More...","title":"Selection Strategies"},{"location":"doxygen/Modules/group___selection_strategies/#classes","text":"Name class sam::PolicyBasedSelection Policy-based Selection Strategy. class sam::SignificantSelection Significant-based Selection Strategy. class sam::RandomSelection Random Selection Strategy. class sam::FreeSelection FreeSelection doesn't pose any restriction on the submission and all submissions will be accepted.","title":"Classes"},{"location":"doxygen/Modules/group___selection_strategies/#detailed-description","text":"List of available Selection Strategies. Description to come!","title":"Detailed Description"},{"location":"doxygen/Modules/group___test_strategies/","text":"Test Strategies \u00b6 List of available Test Strategies. More... Classes \u00b6 Name class sam::TTest Declration of t-test. class sam::FTest class sam::YuenTest class sam::WilcoxonTest Detailed Description \u00b6 List of available Test Strategies. Description to come! Updated on 29 June 2021 at 16:13:48 CEST","title":"Test Strategies"},{"location":"doxygen/Modules/group___test_strategies/#test-strategies","text":"List of available Test Strategies. More...","title":"Test Strategies"},{"location":"doxygen/Modules/group___test_strategies/#classes","text":"Name class sam::TTest Declration of t-test. class sam::FTest class sam::YuenTest class sam::WilcoxonTest","title":"Classes"},{"location":"doxygen/Modules/group___test_strategies/#detailed-description","text":"List of available Test Strategies. Description to come! Updated on 29 June 2021 at 16:13:48 CEST","title":"Detailed Description"},{"location":"examples/","text":"Designing Your Own Simulation \u00b6 In this section, we describe the process of reproducing several published simulation studies using SAM. We have tried to reproduce every study as close as possible, and rigorously use them as our extended testing and benchmarking steps. Each example explains in detail how to translate different aspects of a simulation study, eg., data strategy, research workflow, etc., into SAM's configurations. We have selected a wide range of simulations and configurations to showcase the extend of SAM's flexibility and reach.","title":"Introduction"},{"location":"examples/#designing-your-own-simulation","text":"In this section, we describe the process of reproducing several published simulation studies using SAM. We have tried to reproduce every study as close as possible, and rigorously use them as our extended testing and benchmarking steps. Each example explains in detail how to translate different aspects of a simulation study, eg., data strategy, research workflow, etc., into SAM's configurations. We have selected a wide range of simulations and configurations to showcase the extend of SAM's flexibility and reach.","title":"Designing Your Own Simulation"},{"location":"examples/bakker_et_al_2012/","text":"Attention Please check out Abdol et al., 2021 1 for the updated version of this project. In addition, you can find all the codes, and analysis on GitHub . The Rules of the Game Called Psychological Science 2 \u00b6 In this report, we will attempt to discuss the replication and reproduction of the simulation study conducted by Baker et al., 2012 2 . The simulation is designed to recreate a common routine of applying a set of questionable research practices, and consequently evaluate their effects on the observed effect size bias, and chance of finding significance results. Experiment Design / Model Description \u00b6 As described by Bakker, the simulation study is concerned about 4 distinct strategies as follow: Strategy 1. Perform one large study (with N as the sample size) with sufficient power and publish it. Strategy 2. Perform one large study and use some of the QRPs most popular in psychology (John et al., 2012). These QRPs may be performed sequentially until a significant result is found: - Test a second dependent variable that is correlated with the primary dependent variable (for which John et al. found a 65% admittance rate) - Add 10 subjects (sequential testing; 57% admittance rate) - Remove outliers (| Z | > 2) and rerun analysis (41% admittance rate) Strategy 3. Perform, at most, five small studies each with (N/5) as sample size. Players may stop data collection when they find a significant result in the expected direction and only publish the desired result (the other studies are denoted \u201cfailed\u201d; 48% admittance rate). Strategy 4. Perform, at most, five small studies and apply the QRPs described above in each of these small studies if the need arises. Players may report only the first study that \u201cworked.\u201d \u2014 Bakker et al., 2012 Two main distinguishing factors in the simulation are sample size, N , and whether the pre-defined set of QRPs are applied on the study. When it comes to sample sizes, Bakker defines two size classes, small and large. Number of observations in small studies can be a value from {5, 10, 20}, and number of observation in large studies can be either of {25, 50, 100}. Basically, large studies are 5 times larger than small studies. Another difference between small , and large studies is the repetitive nature of conducting small studies. In strategy 3 and 4, each trial is almost an exact replication of the main study \u2014 that might or might not have been gone through the QRP procedure. Results from these trials will be collected and at the end, the researcher will get a chance to report the most desirable outcome. Following flowcharts are visualizing the simulation workflow designed by Bakker. Figure 1 is an equivalent of 1st and 2nd strategies while Figure 2 showcases 3rd and 4th strategies. Notice the \"Perform the QRP Procedure\" step in Figure 2 where a study goes through the entire process described in Figure 1 labeled as \"QRP Procedure\". Figure 1. Flowchart describing Strategy 1, and 2. In the case of Strategy 1, the simulation does not enter the QRP Procedure and reports the first dependent variable. Figure 2. Flowchart describing Strategy 3, and 4. In the case of Strategy 3, the simulation skips the QRP Procedure but still collects the final outcome from each replication attempts. There are several QRPs involved in strategies 2 and 4. Every small or large study might go under the Selective Reporting process in which the researcher evaluates and reports the secondary outcome, if she does not find the primary outcome satisfactory. Every small or large study might go under the Optional Stopping routine in which the researcher adds 10 new subjects to each DV, and re-calculates her statistics in a quest to find a desirable result. Every study might go under the Outliers Removal process in which the researcher attempts to remove all subjects farther than 2 standard deviation from the sample mean in a quest to find a desirable result. In large studies, a simulation will stop as soon as the researcher find a significant result with positive effect. However, in small studies, while the researcher reports her finding after performing the set of QRPs (\u201dQRP Procedure\u201d in Fig. 1), she continues to repeat the same routine 5 times, and collects the outcome of each replication, Later in the simulation, as shown in Fig 2., she will select the appropriate outcome from the pool of outcomes collected from all replications. \u2192 Strategy 3 follows the same logic with the only difference that each replication doesn\u2019t go through the QRP routines, however, the researcher will still review her finding after performing 5 exact replications. Besides individual strategies, Bakker et al., explored a wide range of parameters in order to capture the influence of their design. The list of parameters can be found below: \u03bc \u2208 [0, 1] N \u2208 {5, 10, 20, 25, 50, 100} Small class, {5, 10, 20} Large class, {25, 50, 100} m , n = 2 4 scenarios/strategies 2 with QRP 2 without QRP The rest of this article focuses on simulating Bakker\u2019s study using SAM, and consequently comparing two approach with each other. Further in the report, we will build on top of Bakker's study in order to investigate the nature of observed biases in more detail. SAM Configuration \u00b6 In order to recreate Bakker's simulation using SAM, we start by planning Researcher's Workflow and translating that into a configuration file . Bakker's experiment is a 2x2 factorial design consists of two groups, Control (C) and Treatment (T) each measuring two dependent variables, as shown in Figure below. The sample population is a multivariate normal distribution with mean of \\hat{0} \\hat{0} for control group, and \\hat{\\mu} \\hat{\\mu} for treatment group; and standard deviation of 1 1 , and 0.5 0.5 covarinace between dependent variables. Therefore, DV_{i} \\in MN(\\hat{\\mu}, \\Sigma) DV_{i} \\in MN(\\hat{\\mu}, \\Sigma) where \\hat{\\mu} = (0, 0, \\mu, \\mu) \\hat{\\mu} = (0, 0, \\mu, \\mu) and \\Sigma = \\begin{bmatrix} 1 & 0.5 & 0 & 0 \\\\ 0.5 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0.5 \\\\ 0 & 0 & 0.5 & 1 \\end{bmatrix} \\Sigma = \\begin{bmatrix} 1 & 0.5 & 0 & 0 \\\\ 0.5 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0.5 \\\\ 0 & 0 & 0.5 & 1 \\end{bmatrix} This design can be expressed using a Linear Model data strategy as follow: Configuration: Data Strategy { ... \"experiment_parameters\" : { \"n_obs\" : 20 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 , \u03bc , \u03bc ], \"sigma\" : [[ 1.0 , 0.5 , 0.0 , 0.0 ], [ 0.5 , 1.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.0 , 0.5 ], [ 0.0 , 0.0 , 0.5 , 1.0 ]] } } ... } Bakker's Researcher uses TTest to asses the significant of its findings. This choice can be expressed with Test Strategy's setting as follow: Configuration: Test Strategy { ... \"experiment_parameters\" : { ... \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } ... } For effect size measure, Bakker computed the standardized effect size different between two effect. In order to equip SAM with this method, we can use the following configuration of the Effect Strategy : Configuration: Effect Strategy { ... \"experiment_parameters\" : { ... \"effect_strategy\" : { \"name\" : \"StandardizedMeanDifference\" } } ... } After fully configuring Experiment's parameters, we can start translating the simulation logic from a Research Workflow to Decision Strategy's configuration, and thereafter preparing the list of Hacking Strategies. Strategy 1, and 3 (Without QRPs) \u00b6 Hacking Strategy \u00b6 In 1st and 3rd strategies, researchers will NOT commit any QRPs, therefore the probability_of_being_a_hacker should be set to 0 . This is enough for configuring a researcher who does not explore the Hacking Workflow . Decision Strategies \u00b6 Following the workflow depicted in Figure 1, we are able to set different decision and selection policies in place for the researcher to achieve the exact path described by Bakker. The researcher always starts by checking the primary outcome, if the selected outcome is not significant and does not have a positive effect (i.e. \"initial_selection_policies\": [[\"id == 2\"]] ), she executes the first hacking strategy. Since in 1st and 3rd strategies, we are not performing any QRPs, this path will not be taken. In the case of small studies, the researcher will replicate 5 exact studies. At the end of each replication, the researcher stores the first outcome variable (as indicated by initial_selection_policies ) in a dataset of All Reported Outcome , Figure 2. Finally, she revisits this dataset, and chooses the most desirable outcome among them. Her preferences can be seen under between_replications_selection_policies parameter. This setup is in place to capture the main idea behind Bakker's simulation, that is, \"beneficial to a researcher to run 5 small studies instead of one large study.\" Configuration: Decision Strategy { ... \"researcher_parameters\" : { ... \"probability_of_being_a_hacker\" : 0 , \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"id == 2\" ] ], \"will_start_hacking_decision_policies\" : [ \"effect < 0\" , \"!sig\" ], \"between_hacks_selection_policies\" : [ [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"stashing_policy\" : [ \"all\" ], \"between_replications_selection_policies\" : [ [ \"effect > 0\" , \"sig\" , \"first\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ], } ... } } Strategy 2, and 4 (With QRPs) \u00b6 Hacking Strategies \u00b6 In 2nd and 4th strategies, the researcher will execute at least one of the listed strategies. After each QRP, the researcher gets to select an outcome from the altered Experiment, after her selection, she can decide on whether she is going to stop there, or applies the next hacking strategy. In Bakker\u2019s case, the selection \u2192 decision is simple. The researcher selects the outcome with positive effect and minimum p -value; then, she checks the availability desirability of the selected outcome, if the outcome is not desirable, she executes the next QRP. These settings are highlighted in the following configuration. Configuration: Hacking Strategy { \"researcher_parameters\" : { \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 10 }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ], [ { \"name\" : \"OutliersRemoval\" , \"target\" : \"Both\" , \"max_attempts\" : 1 , \"min_observations\" : 1 , \"multipliers\" : [ 2 ], \"n_attempts\" : 1 , \"num\" : 100 , \"order\" : \"random\" }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ] ] } } Decision Strategy \u00b6 In Bakker\u2019s simulation, the decision making process between strategies with and without QRPs are very similar. The main research workflow stays intact as shown in Figure 1, and 2. However, now that researchers can commit any QRPs, they will need to choose between all altered outcomes. Bakker\u2019s players tend to collect their findings \u2014 regardless of being QRPed \u2014 throughout the simulation, and select the most desirable one at the end of their research. This process is shown in Figure 1 with dashed lines transferring results to a temporary dataset, and finally selecting for the most desirable outcome from the temporary database. As discussed, this process can be simulated in SAM as well. The stashing_policy parameter indicates which of the outcomes will be collected by the researcher during its expedition. At the end of the Hacking Workflow , the between_hacks_selection_policies parameter indicates how is the researcher going to select between those outcomes, ie., Hacked DB, or All Outcomes Database as stated in Figure 1. Configuration File: Decision Strategy { ... \"researcher_parameters\" : { ... \"probability_of_being_a_hacker\" : 1 , \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"between_hacks_selection_policies\" : [ [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"between_replications_selection_policies\" : [ [ \"effect > 0\" , \"sig\" , \"first\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ]], \"initial_selection_policies\" : [ [ \"id == 2\" , \"sig\" , \"effect > 0\" ], [ \"id == 3\" , \"sig\" , \"effect > 0\" ] ], \"stashing_policy\" : [ \"all\" ], \"submission_decision_policies\" : [ \"\" ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"will_start_hacking_decision_policies\" : [ \"effect < 0\" , \"!sig\" ] } ... } } Results \u00b6 We start by comparing the results between the original simulation and the reproduced study. Original vs. Reproduction \u00b6 Figure 4 compares the results of the original study and the reproduced simulation. As it can be seen, the reproduction simulation \u2014 distinguished by points \u2014 are mainly agreeing with the original simulation with exception of some minor discrepancies in small studies. In all cases, the reproduction simulation captures more bias in small studies with QRPs. Figure 4. Comparison between original and reproduced results (using SAM). The Source of Discrepency \u00b6 Further investigation led to the finding of a minor bug in Bakker et al., code where a typo resulted in insertion of a wrong large study in the replication pool of small simulation. This polluted the pool of small studies and reduced the overall observed bias, due to the wrongly inserted large study having lower bias among all other small studies. Figure 5 , shows the comparison of results from the patched script, and SAM's results. As it is shown, patching Bakker's code accounted for the minor discrepancy and consequently we gets a perfect replication. Figure 5. Comparison between results from the patched script and results from SAM. First Extension: \u03b1\u2018s Role \u00b6 Building on top of Bakker\u2019s simulation and using SAM\u2019s flexibility we can extend their simulation to study the observed effect size bias, ES Bias , under different values of \u03b1 \u2208 {0.0005, 0.005, 0.05}. The main body of the simulation is identical to the original simulation performed by Bakker. Therefore, we start from the final configuration file and in order to enforce different alpha levels, the only parameters that needs to be changes is test_alpha . Configuration: Test Strategy { ... \"experiment_parameters\" : { ... \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } ... } By running the simulation under selected range of parameters, we will be able summarize our results for different levels of alpha in Figure 6 and 7 . Here we can follow the effect of alpha on probability of finding significance and the amount of induced biased under Bakker\u2019s rules. Figure 6 shows the chance of finding at least one significant result. As expected, from left to right, the chance of finding significant result \u2014 in all cases \u2014 increases as we increase \u03b1 but not so drastically. Figure 7 shows the level of bias in the estimated effect. The effect of lowering the \u03b1 on ES bias is not as obvious as it is on the chance of finding significant results. In almost all cases, the largest \u03b1 leads to less bias in the effect as the true effect size increases. In 4th strategy, where the researcher applies a set of QRPs on small studies, the bias rises even more drastically as we lower \u03b1 . It\u2019s worth mentioning that the researcher has not adoptted his strategies to the adjusted values of \u03b1 . In all cases, she still adds 10 new subjects and removes subjects with values further than 2 standard deviations. Figure 6. Chance of finding a significant result with regards to different values of \u03b1 . Figure 7. ES Bias with regards to different values of \u03b1 . The effect of \u03b1 on the chance of finding a significant result and ES bias can be visualized using a heatmap as well. Figure 7 and 8 showcase the trends and patterns more vividly. With regards to chance of finding a significant result , as discussed before, we can see a clear decline as we decrease \u03b1 . This can be seen by the movement of the dark region (lower probability) to the right side (higher effects). While we can see a clear change in the probability of finding a significant result, the heatmap of ES bias looks very scattered and with no clear patterns or trends. This is the indication of a non-linear relation between \u03b1 and ES bias. While decreasing alpha makes it harder to find a significant results, a weak experiment design carries its bias with it anyway. Effect of Replications \u00b6 Before we end the first extension, we studied the effect of number of replications in Bakker et al. simulation. Figures below showcase the effect that different number of replications has on the chance of finding significant and also on the bias accumulated in effect size. While these figures might look crowded, the only thing we are trying to emphasize is the fact that more replications lead to more bias in our studies. This can be seen by tracing points' shapes in each plots. In fact we believe this is the only source of bias in Bakker et al. simulation, and the effect of QRP is minimal in comparison to drastic level of bias induced by only running the same study several times. The next extension put this hypothesis to test by replacing Bakker et al. QRPs with more aggressive methods and parameters. Chance of Finding Sig. Chance of finding a significant result with regards to different number of replications. ES Bias ES Bias with regards to different number of replications. Second Extension: More Aggressive QRPs \u00b6 Another extension of this model could investigate the effect of more aggressive QRPs when stricter \u03b1 \u2019s are introduced. For instance, we could adjust Optional Stopping such that the researcher adds new subjects one by one until she finds a significance result. Furthermore, the Outliers Removal procedure can be replaced by a Subjective Outliers Removal method where the researcher continuously lowers k and remove corresponding outliers until she finds a significant results. These two changes can be added to the configuration file as following: Hacking Strategy: Advance Hacker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { ... \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 0.1 , \"defensibility\" : 0.1 , \"max_attempts\" : 1 , \"n_attempts\" : 10 , \"num\" : 1 , \"stopping_condition\" : [ \"sig\" ] }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ], [ { \"name\" : \"SubjectiveOutlierRemoval\" , \"min_observations\" : 5 , \"range\" : [ 2 , 4 ], \"step_size\" : 0.5 , \"target\" : \"Both\" , \"prevalence\" : 0.1 , \"defensibility\" : 0.1 , \"stopping_condition\" : [ \"sig\" ] }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ] ] ... } Figures below show the results of these modifications. As it is shown, while these adjustments introduce slightly more bias into publications; their effect is not as drastic as one would assume. Combining there results with results of previous extension, we are more certain that the effect of QRPs is minimal. This in fact strengthen Bakker et al. hypothesis by showcasing the immense effect and advantage of running small studies over larger studies. Studies with low sample size are volatile enough that a researcher could easily achieve significant results with unrealistic effect sizes throughout the realistic effect size spectrum. Chance of finding a significant result with regards to different values of \u03b1 . ES Bias with regards to different values of \u03b1 . Third Extension: Influence of Publication Bias \u00b6 In our last extension, we will explore the effect of publication bias on the level of effect size bias; moreover, we investigated the power of Egger's 3 test under different publication bias levels. In order to incorporate the effect of publication bias to our simulation, we equip the Journal module with a Selection Strategies that mimics this effect. The Significant Selection allows us to set adjust the publication bias of the Journal, pub_bias and induce different level of publication bias into our simulation. For this study, we use different values of publication bias, {0., 0.1, ..., 0.9, 1.0} . Journal: Publication Bias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { ... \"journal_parameters\" : { \"max_pubs\" : k , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : p , \"alpha\" : \u0251 , \"side\" : 0 , }, \"meta_analysis_metrics\" : [ { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } ] } ... } In this setup, we would like to run our meta analysis methods publication pool size of K = 24 . This can be done by setting max_pubs parameters of journal_parameters . With this configuration, after journal max-ed out its publications list, it calculates RandomEffectEstimator and EggersTestEstimator , and writes the results into different files for further analysis. Starting by our general plots, we can observer the effect of publication bias on proportion of significant results in our publications pool. 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Moreover, the level of bias can be seen below. As expected, raising the publicatoin bias raises the level of bias accross all our configurations, with sharper swell in lower true effect sizes. 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Figures below showcase the power of Egger's test in detecting publication bias. The average performance of the test is accepetable within most parameter configurations. However, we see large regions of false positives where Egger's test overestimate the presence of the publication bias, especially within smaller true effect sizes. It is also worth mentioning that Egger's test performs quite poorly within a pool of studies with larger sample sizes, L; N = 40 , even with publication bias as high as %90. 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Conclusion \u00b6 In this example, we discussed the process of translating an existing project into SAM. We started by replicating the original simulation, fine-tunning our configuration and comparing our results. Consequently, after successfully replicating the original results, we built on top Bakker et al., simulation. In our first extension, we showed that while lowering the alpha decreases the chance of finding significant results it does not necessarily help with the reduction of bias. Moreover, we showed that the number of replications directly influence the level of bias. In the second extension, we showed that more aggressive QRPs do not proportionally contribute to higher effect size biases. Together with our results from first extension, we believe that the main source of bias in Bakker et al., is the number of replications and the role of QRPs are almost negligible. In our third and last extension, we investigated the effect of publication bias on the overall bias and the power of Egger\u2019s test in defecting publication bias. We showed that while Egger's test generally provide a good measure of publication bias in the presence of publication bias, it consistently overestimate the level of bias when there is not publication bias is present. Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9 Marjan Bakker, Annette van Dijk, and Jelte M. Wicherts. The rules of the game called psychological science. Perspectives on Psychological Science , 7 6 6 :543\u2013554, nov 2012. URL: https://doi.org/10.1177%2F1745691612459060 , doi:10.1177/1745691612459060 . \u21a9 \u21a9 Matthias Egger, George Davey Smith, Martin Schneider, and Christoph Minder. Bias in meta-analysis detected by a simple, graphical test. BMJ , 315 7109 7109 :629\u2013634, 1997. \u21a9","title":"Bakker et al., 2012"},{"location":"examples/bakker_et_al_2012/#the-rules-of-the-game-called-psychological-science2","text":"In this report, we will attempt to discuss the replication and reproduction of the simulation study conducted by Baker et al., 2012 2 . The simulation is designed to recreate a common routine of applying a set of questionable research practices, and consequently evaluate their effects on the observed effect size bias, and chance of finding significance results.","title":"The Rules of the Game Called Psychological Science2"},{"location":"examples/bakker_et_al_2012/#experiment-design-model-description","text":"As described by Bakker, the simulation study is concerned about 4 distinct strategies as follow: Strategy 1. Perform one large study (with N as the sample size) with sufficient power and publish it. Strategy 2. Perform one large study and use some of the QRPs most popular in psychology (John et al., 2012). These QRPs may be performed sequentially until a significant result is found: - Test a second dependent variable that is correlated with the primary dependent variable (for which John et al. found a 65% admittance rate) - Add 10 subjects (sequential testing; 57% admittance rate) - Remove outliers (| Z | > 2) and rerun analysis (41% admittance rate) Strategy 3. Perform, at most, five small studies each with (N/5) as sample size. Players may stop data collection when they find a significant result in the expected direction and only publish the desired result (the other studies are denoted \u201cfailed\u201d; 48% admittance rate). Strategy 4. Perform, at most, five small studies and apply the QRPs described above in each of these small studies if the need arises. Players may report only the first study that \u201cworked.\u201d \u2014 Bakker et al., 2012 Two main distinguishing factors in the simulation are sample size, N , and whether the pre-defined set of QRPs are applied on the study. When it comes to sample sizes, Bakker defines two size classes, small and large. Number of observations in small studies can be a value from {5, 10, 20}, and number of observation in large studies can be either of {25, 50, 100}. Basically, large studies are 5 times larger than small studies. Another difference between small , and large studies is the repetitive nature of conducting small studies. In strategy 3 and 4, each trial is almost an exact replication of the main study \u2014 that might or might not have been gone through the QRP procedure. Results from these trials will be collected and at the end, the researcher will get a chance to report the most desirable outcome. Following flowcharts are visualizing the simulation workflow designed by Bakker. Figure 1 is an equivalent of 1st and 2nd strategies while Figure 2 showcases 3rd and 4th strategies. Notice the \"Perform the QRP Procedure\" step in Figure 2 where a study goes through the entire process described in Figure 1 labeled as \"QRP Procedure\". Figure 1. Flowchart describing Strategy 1, and 2. In the case of Strategy 1, the simulation does not enter the QRP Procedure and reports the first dependent variable. Figure 2. Flowchart describing Strategy 3, and 4. In the case of Strategy 3, the simulation skips the QRP Procedure but still collects the final outcome from each replication attempts. There are several QRPs involved in strategies 2 and 4. Every small or large study might go under the Selective Reporting process in which the researcher evaluates and reports the secondary outcome, if she does not find the primary outcome satisfactory. Every small or large study might go under the Optional Stopping routine in which the researcher adds 10 new subjects to each DV, and re-calculates her statistics in a quest to find a desirable result. Every study might go under the Outliers Removal process in which the researcher attempts to remove all subjects farther than 2 standard deviation from the sample mean in a quest to find a desirable result. In large studies, a simulation will stop as soon as the researcher find a significant result with positive effect. However, in small studies, while the researcher reports her finding after performing the set of QRPs (\u201dQRP Procedure\u201d in Fig. 1), she continues to repeat the same routine 5 times, and collects the outcome of each replication, Later in the simulation, as shown in Fig 2., she will select the appropriate outcome from the pool of outcomes collected from all replications. \u2192 Strategy 3 follows the same logic with the only difference that each replication doesn\u2019t go through the QRP routines, however, the researcher will still review her finding after performing 5 exact replications. Besides individual strategies, Bakker et al., explored a wide range of parameters in order to capture the influence of their design. The list of parameters can be found below: \u03bc \u2208 [0, 1] N \u2208 {5, 10, 20, 25, 50, 100} Small class, {5, 10, 20} Large class, {25, 50, 100} m , n = 2 4 scenarios/strategies 2 with QRP 2 without QRP The rest of this article focuses on simulating Bakker\u2019s study using SAM, and consequently comparing two approach with each other. Further in the report, we will build on top of Bakker's study in order to investigate the nature of observed biases in more detail.","title":"Experiment Design / Model Description"},{"location":"examples/bakker_et_al_2012/#sam-configuration","text":"In order to recreate Bakker's simulation using SAM, we start by planning Researcher's Workflow and translating that into a configuration file . Bakker's experiment is a 2x2 factorial design consists of two groups, Control (C) and Treatment (T) each measuring two dependent variables, as shown in Figure below. The sample population is a multivariate normal distribution with mean of \\hat{0} \\hat{0} for control group, and \\hat{\\mu} \\hat{\\mu} for treatment group; and standard deviation of 1 1 , and 0.5 0.5 covarinace between dependent variables. Therefore, DV_{i} \\in MN(\\hat{\\mu}, \\Sigma) DV_{i} \\in MN(\\hat{\\mu}, \\Sigma) where \\hat{\\mu} = (0, 0, \\mu, \\mu) \\hat{\\mu} = (0, 0, \\mu, \\mu) and \\Sigma = \\begin{bmatrix} 1 & 0.5 & 0 & 0 \\\\ 0.5 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0.5 \\\\ 0 & 0 & 0.5 & 1 \\end{bmatrix} \\Sigma = \\begin{bmatrix} 1 & 0.5 & 0 & 0 \\\\ 0.5 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0.5 \\\\ 0 & 0 & 0.5 & 1 \\end{bmatrix} This design can be expressed using a Linear Model data strategy as follow: Configuration: Data Strategy { ... \"experiment_parameters\" : { \"n_obs\" : 20 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 , \u03bc , \u03bc ], \"sigma\" : [[ 1.0 , 0.5 , 0.0 , 0.0 ], [ 0.5 , 1.0 , 0.0 , 0.0 ], [ 0.0 , 0.0 , 1.0 , 0.5 ], [ 0.0 , 0.0 , 0.5 , 1.0 ]] } } ... } Bakker's Researcher uses TTest to asses the significant of its findings. This choice can be expressed with Test Strategy's setting as follow: Configuration: Test Strategy { ... \"experiment_parameters\" : { ... \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } ... } For effect size measure, Bakker computed the standardized effect size different between two effect. In order to equip SAM with this method, we can use the following configuration of the Effect Strategy : Configuration: Effect Strategy { ... \"experiment_parameters\" : { ... \"effect_strategy\" : { \"name\" : \"StandardizedMeanDifference\" } } ... } After fully configuring Experiment's parameters, we can start translating the simulation logic from a Research Workflow to Decision Strategy's configuration, and thereafter preparing the list of Hacking Strategies.","title":"SAM Configuration"},{"location":"examples/bakker_et_al_2012/#strategy-1-and-3-without-qrps","text":"","title":"Strategy 1, and 3 (Without QRPs)"},{"location":"examples/bakker_et_al_2012/#hacking-strategy","text":"In 1st and 3rd strategies, researchers will NOT commit any QRPs, therefore the probability_of_being_a_hacker should be set to 0 . This is enough for configuring a researcher who does not explore the Hacking Workflow .","title":"Hacking Strategy"},{"location":"examples/bakker_et_al_2012/#decision-strategies","text":"Following the workflow depicted in Figure 1, we are able to set different decision and selection policies in place for the researcher to achieve the exact path described by Bakker. The researcher always starts by checking the primary outcome, if the selected outcome is not significant and does not have a positive effect (i.e. \"initial_selection_policies\": [[\"id == 2\"]] ), she executes the first hacking strategy. Since in 1st and 3rd strategies, we are not performing any QRPs, this path will not be taken. In the case of small studies, the researcher will replicate 5 exact studies. At the end of each replication, the researcher stores the first outcome variable (as indicated by initial_selection_policies ) in a dataset of All Reported Outcome , Figure 2. Finally, she revisits this dataset, and chooses the most desirable outcome among them. Her preferences can be seen under between_replications_selection_policies parameter. This setup is in place to capture the main idea behind Bakker's simulation, that is, \"beneficial to a researcher to run 5 small studies instead of one large study.\" Configuration: Decision Strategy { ... \"researcher_parameters\" : { ... \"probability_of_being_a_hacker\" : 0 , \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"id == 2\" ] ], \"will_start_hacking_decision_policies\" : [ \"effect < 0\" , \"!sig\" ], \"between_hacks_selection_policies\" : [ [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"stashing_policy\" : [ \"all\" ], \"between_replications_selection_policies\" : [ [ \"effect > 0\" , \"sig\" , \"first\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ], } ... } }","title":"Decision Strategies"},{"location":"examples/bakker_et_al_2012/#strategy-2-and-4-with-qrps","text":"","title":"Strategy 2, and 4 (With QRPs)"},{"location":"examples/bakker_et_al_2012/#hacking-strategies","text":"In 2nd and 4th strategies, the researcher will execute at least one of the listed strategies. After each QRP, the researcher gets to select an outcome from the altered Experiment, after her selection, she can decide on whether she is going to stop there, or applies the next hacking strategy. In Bakker\u2019s case, the selection \u2192 decision is simple. The researcher selects the outcome with positive effect and minimum p -value; then, she checks the availability desirability of the selected outcome, if the outcome is not desirable, she executes the next QRP. These settings are highlighted in the following configuration. Configuration: Hacking Strategy { \"researcher_parameters\" : { \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 10 }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ], [ { \"name\" : \"OutliersRemoval\" , \"target\" : \"Both\" , \"max_attempts\" : 1 , \"min_observations\" : 1 , \"multipliers\" : [ 2 ], \"n_attempts\" : 1 , \"num\" : 100 , \"order\" : \"random\" }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ] ] } }","title":"Hacking Strategies"},{"location":"examples/bakker_et_al_2012/#decision-strategy","text":"In Bakker\u2019s simulation, the decision making process between strategies with and without QRPs are very similar. The main research workflow stays intact as shown in Figure 1, and 2. However, now that researchers can commit any QRPs, they will need to choose between all altered outcomes. Bakker\u2019s players tend to collect their findings \u2014 regardless of being QRPed \u2014 throughout the simulation, and select the most desirable one at the end of their research. This process is shown in Figure 1 with dashed lines transferring results to a temporary dataset, and finally selecting for the most desirable outcome from the temporary database. As discussed, this process can be simulated in SAM as well. The stashing_policy parameter indicates which of the outcomes will be collected by the researcher during its expedition. At the end of the Hacking Workflow , the between_hacks_selection_policies parameter indicates how is the researcher going to select between those outcomes, ie., Hacked DB, or All Outcomes Database as stated in Figure 1. Configuration File: Decision Strategy { ... \"researcher_parameters\" : { ... \"probability_of_being_a_hacker\" : 1 , \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"between_hacks_selection_policies\" : [ [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"between_replications_selection_policies\" : [ [ \"effect > 0\" , \"sig\" , \"first\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ]], \"initial_selection_policies\" : [ [ \"id == 2\" , \"sig\" , \"effect > 0\" ], [ \"id == 3\" , \"sig\" , \"effect > 0\" ] ], \"stashing_policy\" : [ \"all\" ], \"submission_decision_policies\" : [ \"\" ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"will_start_hacking_decision_policies\" : [ \"effect < 0\" , \"!sig\" ] } ... } }","title":"Decision Strategy"},{"location":"examples/bakker_et_al_2012/#results","text":"We start by comparing the results between the original simulation and the reproduced study.","title":"Results"},{"location":"examples/bakker_et_al_2012/#original-vs-reproduction","text":"Figure 4 compares the results of the original study and the reproduced simulation. As it can be seen, the reproduction simulation \u2014 distinguished by points \u2014 are mainly agreeing with the original simulation with exception of some minor discrepancies in small studies. In all cases, the reproduction simulation captures more bias in small studies with QRPs. Figure 4. Comparison between original and reproduced results (using SAM).","title":"Original vs. Reproduction"},{"location":"examples/bakker_et_al_2012/#the-source-of-discrepency","text":"Further investigation led to the finding of a minor bug in Bakker et al., code where a typo resulted in insertion of a wrong large study in the replication pool of small simulation. This polluted the pool of small studies and reduced the overall observed bias, due to the wrongly inserted large study having lower bias among all other small studies. Figure 5 , shows the comparison of results from the patched script, and SAM's results. As it is shown, patching Bakker's code accounted for the minor discrepancy and consequently we gets a perfect replication. Figure 5. Comparison between results from the patched script and results from SAM.","title":"The Source of Discrepency"},{"location":"examples/bakker_et_al_2012/#first-extension-s-role","text":"Building on top of Bakker\u2019s simulation and using SAM\u2019s flexibility we can extend their simulation to study the observed effect size bias, ES Bias , under different values of \u03b1 \u2208 {0.0005, 0.005, 0.05}. The main body of the simulation is identical to the original simulation performed by Bakker. Therefore, we start from the final configuration file and in order to enforce different alpha levels, the only parameters that needs to be changes is test_alpha . Configuration: Test Strategy { ... \"experiment_parameters\" : { ... \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } ... } By running the simulation under selected range of parameters, we will be able summarize our results for different levels of alpha in Figure 6 and 7 . Here we can follow the effect of alpha on probability of finding significance and the amount of induced biased under Bakker\u2019s rules. Figure 6 shows the chance of finding at least one significant result. As expected, from left to right, the chance of finding significant result \u2014 in all cases \u2014 increases as we increase \u03b1 but not so drastically. Figure 7 shows the level of bias in the estimated effect. The effect of lowering the \u03b1 on ES bias is not as obvious as it is on the chance of finding significant results. In almost all cases, the largest \u03b1 leads to less bias in the effect as the true effect size increases. In 4th strategy, where the researcher applies a set of QRPs on small studies, the bias rises even more drastically as we lower \u03b1 . It\u2019s worth mentioning that the researcher has not adoptted his strategies to the adjusted values of \u03b1 . In all cases, she still adds 10 new subjects and removes subjects with values further than 2 standard deviations. Figure 6. Chance of finding a significant result with regards to different values of \u03b1 . Figure 7. ES Bias with regards to different values of \u03b1 . The effect of \u03b1 on the chance of finding a significant result and ES bias can be visualized using a heatmap as well. Figure 7 and 8 showcase the trends and patterns more vividly. With regards to chance of finding a significant result , as discussed before, we can see a clear decline as we decrease \u03b1 . This can be seen by the movement of the dark region (lower probability) to the right side (higher effects). While we can see a clear change in the probability of finding a significant result, the heatmap of ES bias looks very scattered and with no clear patterns or trends. This is the indication of a non-linear relation between \u03b1 and ES bias. While decreasing alpha makes it harder to find a significant results, a weak experiment design carries its bias with it anyway.","title":"First Extension: \u03b1\u2018s Role"},{"location":"examples/bakker_et_al_2012/#effect-of-replications","text":"Before we end the first extension, we studied the effect of number of replications in Bakker et al. simulation. Figures below showcase the effect that different number of replications has on the chance of finding significant and also on the bias accumulated in effect size. While these figures might look crowded, the only thing we are trying to emphasize is the fact that more replications lead to more bias in our studies. This can be seen by tracing points' shapes in each plots. In fact we believe this is the only source of bias in Bakker et al. simulation, and the effect of QRP is minimal in comparison to drastic level of bias induced by only running the same study several times. The next extension put this hypothesis to test by replacing Bakker et al. QRPs with more aggressive methods and parameters. Chance of Finding Sig. Chance of finding a significant result with regards to different number of replications. ES Bias ES Bias with regards to different number of replications.","title":"Effect of Replications"},{"location":"examples/bakker_et_al_2012/#second-extension-more-aggressive-qrps","text":"Another extension of this model could investigate the effect of more aggressive QRPs when stricter \u03b1 \u2019s are introduced. For instance, we could adjust Optional Stopping such that the researcher adds new subjects one by one until she finds a significance result. Furthermore, the Outliers Removal procedure can be replaced by a Subjective Outliers Removal method where the researcher continuously lowers k and remove corresponding outliers until she finds a significant results. These two changes can be added to the configuration file as following: Hacking Strategy: Advance Hacker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { ... \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 0.1 , \"defensibility\" : 0.1 , \"max_attempts\" : 1 , \"n_attempts\" : 10 , \"num\" : 1 , \"stopping_condition\" : [ \"sig\" ] }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ], [ { \"name\" : \"SubjectiveOutlierRemoval\" , \"min_observations\" : 5 , \"range\" : [ 2 , 4 ], \"step_size\" : 0.5 , \"target\" : \"Both\" , \"prevalence\" : 0.1 , \"defensibility\" : 0.1 , \"stopping_condition\" : [ \"sig\" ] }, [ [ \"effect > 0\" , \"min(pvalue)\" ] ], [ \"effect < 0\" , \"!sig\" ] ] ] ... } Figures below show the results of these modifications. As it is shown, while these adjustments introduce slightly more bias into publications; their effect is not as drastic as one would assume. Combining there results with results of previous extension, we are more certain that the effect of QRPs is minimal. This in fact strengthen Bakker et al. hypothesis by showcasing the immense effect and advantage of running small studies over larger studies. Studies with low sample size are volatile enough that a researcher could easily achieve significant results with unrealistic effect sizes throughout the realistic effect size spectrum. Chance of finding a significant result with regards to different values of \u03b1 . ES Bias with regards to different values of \u03b1 .","title":"Second Extension: More Aggressive QRPs"},{"location":"examples/bakker_et_al_2012/#third-extension-influence-of-publication-bias","text":"In our last extension, we will explore the effect of publication bias on the level of effect size bias; moreover, we investigated the power of Egger's 3 test under different publication bias levels. In order to incorporate the effect of publication bias to our simulation, we equip the Journal module with a Selection Strategies that mimics this effect. The Significant Selection allows us to set adjust the publication bias of the Journal, pub_bias and induce different level of publication bias into our simulation. For this study, we use different values of publication bias, {0., 0.1, ..., 0.9, 1.0} . Journal: Publication Bias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { ... \"journal_parameters\" : { \"max_pubs\" : k , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : p , \"alpha\" : \u0251 , \"side\" : 0 , }, \"meta_analysis_metrics\" : [ { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } ] } ... } In this setup, we would like to run our meta analysis methods publication pool size of K = 24 . This can be done by setting max_pubs parameters of journal_parameters . With this configuration, after journal max-ed out its publications list, it calculates RandomEffectEstimator and EggersTestEstimator , and writes the results into different files for further analysis. Starting by our general plots, we can observer the effect of publication bias on proportion of significant results in our publications pool. 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Moreover, the level of bias can be seen below. As expected, raising the publicatoin bias raises the level of bias accross all our configurations, with sharper swell in lower true effect sizes. 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 Figures below showcase the power of Egger's test in detecting publication bias. The average performance of the test is accepetable within most parameter configurations. However, we see large regions of false positives where Egger's test overestimate the presence of the publication bias, especially within smaller true effect sizes. It is also worth mentioning that Egger's test performs quite poorly within a pool of studies with larger sample sizes, L; N = 40 , even with publication bias as high as %90. 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0","title":"Third Extension: Influence of Publication Bias"},{"location":"examples/bakker_et_al_2012/#conclusion","text":"In this example, we discussed the process of translating an existing project into SAM. We started by replicating the original simulation, fine-tunning our configuration and comparing our results. Consequently, after successfully replicating the original results, we built on top Bakker et al., simulation. In our first extension, we showed that while lowering the alpha decreases the chance of finding significant results it does not necessarily help with the reduction of bias. Moreover, we showed that the number of replications directly influence the level of bias. In the second extension, we showed that more aggressive QRPs do not proportionally contribute to higher effect size biases. Together with our results from first extension, we believe that the main source of bias in Bakker et al., is the number of replications and the role of QRPs are almost negligible. In our third and last extension, we investigated the effect of publication bias on the overall bias and the power of Egger\u2019s test in defecting publication bias. We showed that while Egger's test generally provide a good measure of publication bias in the presence of publication bias, it consistently overestimate the level of bias when there is not publication bias is present. Amir M. Abdol and Jelte M. Wicherts. Science Abstract Model Simulation Framework. PsyArXiv , 09 2021. URL: https://psyarxiv.com/zy29t , doi:10.31234/osf.io/zy29t . \u21a9 Marjan Bakker, Annette van Dijk, and Jelte M. Wicherts. The rules of the game called psychological science. Perspectives on Psychological Science , 7 6 6 :543\u2013554, nov 2012. URL: https://doi.org/10.1177%2F1745691612459060 , doi:10.1177/1745691612459060 . \u21a9 \u21a9 Matthias Egger, George Davey Smith, Martin Schneider, and Christoph Minder. Bias in meta-analysis detected by a simple, graphical test. BMJ , 315 7109 7109 :629\u2013634, 1997. \u21a9","title":"Conclusion"},{"location":"examples/bakker_et_al_2014/","text":"Outlier Removal, Sum Scores, and The Inflation of the Type I Error Rate In Independent Samples T Tests: The Power of Alternatives and Recommendations 1 \u00b6 This report discusses the process of partially reproducing the simulation study conducted by Bakker et al, 2014 1 . The simulation aims to study effects of removing outliers on Type I error. Besides a regular Linear Model , Bakker et al have simulated data from the General Graded Response Model 2 . The original study also explores the power of alternative tests, e.g., Yuen's Test 3 , and Wilcoxon's Test 4 . Experiment Design / Model Description \u00b6 The original study is testing the effects of removing outliers in two main scenarios: Non-Subjective Outliers Removal , in which the effect of removing outliers with | Z | > k \u2014 **for a fixed *k** \u2014 is being measured. Subjective Outliers Removal , in which the effect of removing outliers with a variable k \u2208 {3, 2.5, 2} is being measured. Figure 1 shows the flow of two main simulation scenarios. As discussed, by Bakker et al, 2014, the subjective Type I error is calculated based on results of the non-subjective simulation: Furthermore, we investigated the subjective use of k . This means that a comparison is counted as statistically significant if the test showed a statistically significant difference when all values were included in the sample or when the test showed a statistically significant difference when k is 3, 2.5, or 2. This is comparable with adapting k until a statistically significant p -value is found . This reflects a manner in which researchers can chase for significance (Ioannidis, 2005, 2012), ... \u2014 Bakker et al., 2012, page 5. As stated by Bakker, this should be equivalent to calculating the subjective Type I Error from the posterior of the non-subjective simulation. We put this theory to test by running a separate simulation for the subjective outliers removal . In fact, in the reproduction simulation we are going to simulate the behavior of a researcher who dynamically reduces k until she finds a significant result. Figure 1. Simulation Flowcharts SAM Configuration \u00b6 Experiment Parameters and Study Design \u00b6 In the original study, the data is generated based on two models, Linear Model and General GRM with following parameters: different number of items, i \u2208 {2, 5, 10, 20, 40} different number of options per items, j \u2208 {1, 5} different difficulty levels, \u03b2 \u2208 {0, 3} different sample sizes, N \u2208 {20, 40, 100, 500} and one ability level, \u03b1 \u2208 0 Finally, the [Rasch Model] 5 is being used as the response function of the GRM: Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} where \\theta_j \\theta_j is j j 'th examinee ability trait, and \\beta_i \\beta_i is the difficulty of item i i . In both scenarios, the study design consists of two groups, and a single dependent variant is being measured in each group, as described in Figure 2 . Figure 2. Study Designs Configurations below showcase how one can express the presented design in SAM. In the case of Linear Model, the setup is simple, we set the data strategy to Linear Model and define a multivariate normal distribution to populate all DVs. For simulating Rasch and GRM model, we use the General Graded Response Model framework, and set appropriate difficulty and ability parameters as shown below: Configuration: Data Strategy Linear \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 100 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , \u03bc ], \"stddevs\" : 1.0 , \"covs\" : 0.0 } }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"use_continuity\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } Rasch \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 100 , \"data_strategy\" : { \"name\" : \"GradedResponseModel\" , \"n_items\" : 40 , \"abilities\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , \u03bc ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"n_categories\" : 5 , \"difficulties\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ \u03b8 , \u03b8 , \u03b8 , \u03b8 ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"response_function\" : \"Rasch\" , }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"use_continuity\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } GRM \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 100 , \"data_strategy\" : { \"name\" : \"GradedResponseModel\" , \"n_items\" : 40 , \"abilities\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"n_categories\" : 2 , \"difficulties\" : [ { \"dist\" : \"normal_distribution\" , \"mean\" : 0 , \"stddev\" : 1.0 } ], \"response_function\" : \"Rasch\" , }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"use_continuity\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } Hacking Strategies \u00b6 For simulating the Outliers Removal process, we take a different approach than the one we have used for Bakker et al., 2012 simulation. Here, we simulate the outliers removal step before passing the Experiment to the Researcher. This is equivalent to pre-processing the data and then running the final tests and analyses on it. For this purpose, we are using the pre_processing_methods parameter in researcher_parameters section. Pre-processing steps are similar to normal hacking strategies with the difference that the Researcher does not get to perform a selection \u2192 decision sequence after each step. They are being fully applied one after another, and when the list is exhausted, a copy of the modified Experiment will be passed to the Researcher for further analysis. Configuration: Pre-processing Non Subjective \"probability_of_being_a_hacker\" : 0 , \"probability_of_committing_a_hack\" : 0 , \"hacking_strategies\" : [ \"\" ], \"is_pre_processing\" : true , \"pre_processing_methods\" : [ { \"name\" : \"OutliersRemoval\" , \"target\" : \"Both\" , \"prevalence\" : 0.5 , \"defensibility\" : 0.1 , \"min_observations\" : 5 , \"multipliers\" : [ k ], \"n_attempts\" : 1 , \"num\" : N , \"order\" : \"random\" } ] Subjective \"probability_of_being_a_hacker\" : 0 , \"probability_of_committing_a_hack\" : 0 , \"hacking_strategies\" : [ \"\" ], \"is_pre_processing\" : true , \"pre_processing_methods\" : [ { \"name\" : \"SubjectiveOutlierRemoval\" , \"min_observations\" : 5 , \"prevalence\" : 0.5 , \"target\" : \"Both\" , \"defensibility\" : 0.1 , \"range\" : [ 2 , 3 ], \"step_size\" : 0.5 , \"stopping_condition\" : [ \"sig\" ] } ] Decision Strategies \u00b6 Neither of the simulation scenarios involve a complicated design making routine compared to Bakker et al., 2012 multistep decision making process. Here, in both cases, we are only interested in reporting the only available dependent variable, and this can be done by setting initial_selection_policies to [\"id == 1\"] or [\"pre-reg\"] . With this configuration, the Researcher initializes an Experiment, perform the pre-processing step, and \"blindly\" submit the only DV to the Journal without altering the experiment. This simple decision strategy can be used to skip the entire decision workflow, and study the Experiment in its purity without any dynamic interventions from the Researcher. Configuration: Decision Strategy \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"id == 1\" ] ], \"between_hacks_selection_policies\" : [[ \"\" ]], \"between_replications_selection_policies\" : [[ \"\" ]], \"stashing_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"will_start_hacking_decision_policies\" : [ \"\" ] } Results \u00b6 Original vs. Reproduction \u00b6 Figure 3 shows the results of removing outliers from a normally distributed sum scores, aka. linear model. This is the equivalent of results showcased in Figure 1 of Bakker et al. 2014. While we didn't overly the results from the original study due to difficulty of extracting the data in compatible format, it can be seen that our results agrees with results form the original study, and we see a similar trends in Type I Error reduction as we increase k . Chance of finding a significant result with regards to different values of \u03b1 . Similarly, Figure 4 shows the results of removing outliers from Rasch and GRM. Figure 4 is equivalent of results presented in Figure 2, and 3 of Bakker study. We again see a similar trends with respect to increasing k , number of items and higher difficultly. Chance of finding a significant result with regards to different values of \u03b1 . First Extension: Effect of Publication Bias \u00b6 As we did with Bakker et al., 2012 study, we demonstrate how we can extend the currently established simulation with a few modification and explore different aspects of the problem using SAM. In the first extension, we introduce a biased journal to the simulation by modifying the selection strategy of the Journal module as follow: Configuration: Biased Journal \"journal_parameters\" : { \"max_pubs\" : 5000 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.05 , \"pub_bias\" : Pb , \"side\" : 0 } } By varying this configuration, and keeping the rest of the setup intact, we will be able to study the effect of publication bias on our design. Figure 5 shows the results of this modification. As one would expect, we can see higher Type I error in publications as we increase the publication bias rate, from top to bottom. Also, we can see that Type I error rate decreases as we increase the number of items, and examinees, as expected. Rasch, \u03b8 = 0 Chance of finding a significant result with regards to different values of \u03b1 . Rasch, \u03b8 = 3 Chance of finding a significant result with regards to different values of \u03b1 . GRM, \u03b8 = 0 Chance of finding a significant result with regards to different values of \u03b1 . GRM, \u03b8 = 3 Chance of finding a significant result with regards to different values of \u03b1 . Second Extension: Meta-analysis and Bias Level \u00b6 While we will discuss the power of Egger's Test and several other meta-analysis metrics, and publication bias correction methods in Maassen et al. simulation study, here for the second extension, we focus on the linear model of Bakker et al., 2014 simulation and study the power/accuracy of Egger's Test on two different meta-analysis pool with different size as well as the accuracy of Random Effect estimator, Figure 6 and Figure 7 respectively. Configuration: Biased Journal \"journal_parameters\" : { \"max_pubs\" : 5000 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.05 , \"pub_bias\" : Pb , \"side\" : 0 }, \"meta_analysis_metrics\" : [ { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } ] } Chance of finding a significant result with regards to different values of \u03b1 . Chance of finding a significant result with regards to different values of \u03b1 . Marjan Bakker and Jelte M. Wicherts. Outlier removal, sum scores, and the inflation of the type i error rate in independent samples t tests: the power of alternatives and recommendations. Psychological Methods , 19 3 3 :409\u2013427, 2014. URL: https://doi.org/10.1037%2Fmet0000014 , doi:10.1037/met0000014 . \u21a9 \u21a9 Fumiko Samejima. Graded Response Model , pages 85\u2013100. Springer New York, New York, NY, 1997. URL: https://doi.org/10.1007/978-1-4757-2691-6_5 , doi:10.1007/978-1-4757-2691-6_5 . \u21a9 KAREN K. YUEN. The two-sample trimmed t for unequal population variances. Biometrika , 61 1 1 :165\u2013170, 04 1974. URL: https://doi.org/10.1093/biomet/61.1.165 , doi:10.1093/biomet/61.1.165 . \u21a9 Frank Wilcoxon. Individual Comparisons by Ranking Methods , pages 196\u2013202. Springer New York, New York, NY, 1992. URL: https://doi.org/10.1007/978-1-4612-4380-9_16 , doi:10.1007/978-1-4612-4380-9_16 . \u21a9 Susan E Embretson and Steven Paul Reise. Item response theory for psychologists. Maheah . New Jersey: Lawrence Erlbaum Associates, Publishers, 2000. \u21a9","title":"Bakker et al., 2014"},{"location":"examples/bakker_et_al_2014/#outlier-removal-sum-scores-and-the-inflation-of-the-type-i-error-rate-in-independent-samples-t-tests-the-power-of-alternatives-and-recommendations1","text":"This report discusses the process of partially reproducing the simulation study conducted by Bakker et al, 2014 1 . The simulation aims to study effects of removing outliers on Type I error. Besides a regular Linear Model , Bakker et al have simulated data from the General Graded Response Model 2 . The original study also explores the power of alternative tests, e.g., Yuen's Test 3 , and Wilcoxon's Test 4 .","title":"Outlier Removal, Sum Scores, and The Inflation of the Type I Error Rate In Independent Samples T Tests: The Power of Alternatives and Recommendations1"},{"location":"examples/bakker_et_al_2014/#experiment-design-model-description","text":"The original study is testing the effects of removing outliers in two main scenarios: Non-Subjective Outliers Removal , in which the effect of removing outliers with | Z | > k \u2014 **for a fixed *k** \u2014 is being measured. Subjective Outliers Removal , in which the effect of removing outliers with a variable k \u2208 {3, 2.5, 2} is being measured. Figure 1 shows the flow of two main simulation scenarios. As discussed, by Bakker et al, 2014, the subjective Type I error is calculated based on results of the non-subjective simulation: Furthermore, we investigated the subjective use of k . This means that a comparison is counted as statistically significant if the test showed a statistically significant difference when all values were included in the sample or when the test showed a statistically significant difference when k is 3, 2.5, or 2. This is comparable with adapting k until a statistically significant p -value is found . This reflects a manner in which researchers can chase for significance (Ioannidis, 2005, 2012), ... \u2014 Bakker et al., 2012, page 5. As stated by Bakker, this should be equivalent to calculating the subjective Type I Error from the posterior of the non-subjective simulation. We put this theory to test by running a separate simulation for the subjective outliers removal . In fact, in the reproduction simulation we are going to simulate the behavior of a researcher who dynamically reduces k until she finds a significant result. Figure 1. Simulation Flowcharts","title":"Experiment Design / Model Description"},{"location":"examples/bakker_et_al_2014/#sam-configuration","text":"","title":"SAM Configuration"},{"location":"examples/bakker_et_al_2014/#experiment-parameters-and-study-design","text":"In the original study, the data is generated based on two models, Linear Model and General GRM with following parameters: different number of items, i \u2208 {2, 5, 10, 20, 40} different number of options per items, j \u2208 {1, 5} different difficulty levels, \u03b2 \u2208 {0, 3} different sample sizes, N \u2208 {20, 40, 100, 500} and one ability level, \u03b1 \u2208 0 Finally, the [Rasch Model] 5 is being used as the response function of the GRM: Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} Pr(X_{ij} = 1) = \\frac{exp(\\theta_j - \\beta_i)}{1 + exp(\\theta_j - \\beta_i)} where \\theta_j \\theta_j is j j 'th examinee ability trait, and \\beta_i \\beta_i is the difficulty of item i i . In both scenarios, the study design consists of two groups, and a single dependent variant is being measured in each group, as described in Figure 2 . Figure 2. Study Designs Configurations below showcase how one can express the presented design in SAM. In the case of Linear Model, the setup is simple, we set the data strategy to Linear Model and define a multivariate normal distribution to populate all DVs. For simulating Rasch and GRM model, we use the General Graded Response Model framework, and set appropriate difficulty and ability parameters as shown below: Configuration: Data Strategy Linear \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 100 , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , \u03bc ], \"stddevs\" : 1.0 , \"covs\" : 0.0 } }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"use_continuity\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } Rasch \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 100 , \"data_strategy\" : { \"name\" : \"GradedResponseModel\" , \"n_items\" : 40 , \"abilities\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , \u03bc ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"n_categories\" : 5 , \"difficulties\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ \u03b8 , \u03b8 , \u03b8 , \u03b8 ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"response_function\" : \"Rasch\" , }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"use_continuity\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } } GRM \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 1 , \"n_obs\" : 100 , \"data_strategy\" : { \"name\" : \"GradedResponseModel\" , \"n_items\" : 40 , \"abilities\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0 , 0 ], \"stddevs\" : 1.0 , \"covs\" : 0.0 }, \"n_categories\" : 2 , \"difficulties\" : [ { \"dist\" : \"normal_distribution\" , \"mean\" : 0 , \"stddev\" : 1.0 } ], \"response_function\" : \"Rasch\" , }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"use_continuity\" : true }, \"effect_strategy\" : { \"name\" : \"MeanDifference\" } }","title":"Experiment Parameters and Study Design"},{"location":"examples/bakker_et_al_2014/#hacking-strategies","text":"For simulating the Outliers Removal process, we take a different approach than the one we have used for Bakker et al., 2012 simulation. Here, we simulate the outliers removal step before passing the Experiment to the Researcher. This is equivalent to pre-processing the data and then running the final tests and analyses on it. For this purpose, we are using the pre_processing_methods parameter in researcher_parameters section. Pre-processing steps are similar to normal hacking strategies with the difference that the Researcher does not get to perform a selection \u2192 decision sequence after each step. They are being fully applied one after another, and when the list is exhausted, a copy of the modified Experiment will be passed to the Researcher for further analysis. Configuration: Pre-processing Non Subjective \"probability_of_being_a_hacker\" : 0 , \"probability_of_committing_a_hack\" : 0 , \"hacking_strategies\" : [ \"\" ], \"is_pre_processing\" : true , \"pre_processing_methods\" : [ { \"name\" : \"OutliersRemoval\" , \"target\" : \"Both\" , \"prevalence\" : 0.5 , \"defensibility\" : 0.1 , \"min_observations\" : 5 , \"multipliers\" : [ k ], \"n_attempts\" : 1 , \"num\" : N , \"order\" : \"random\" } ] Subjective \"probability_of_being_a_hacker\" : 0 , \"probability_of_committing_a_hack\" : 0 , \"hacking_strategies\" : [ \"\" ], \"is_pre_processing\" : true , \"pre_processing_methods\" : [ { \"name\" : \"SubjectiveOutlierRemoval\" , \"min_observations\" : 5 , \"prevalence\" : 0.5 , \"target\" : \"Both\" , \"defensibility\" : 0.1 , \"range\" : [ 2 , 3 ], \"step_size\" : 0.5 , \"stopping_condition\" : [ \"sig\" ] } ]","title":"Hacking Strategies"},{"location":"examples/bakker_et_al_2014/#decision-strategies","text":"Neither of the simulation scenarios involve a complicated design making routine compared to Bakker et al., 2012 multistep decision making process. Here, in both cases, we are only interested in reporting the only available dependent variable, and this can be done by setting initial_selection_policies to [\"id == 1\"] or [\"pre-reg\"] . With this configuration, the Researcher initializes an Experiment, perform the pre-processing step, and \"blindly\" submit the only DV to the Journal without altering the experiment. This simple decision strategy can be used to skip the entire decision workflow, and study the Experiment in its purity without any dynamic interventions from the Researcher. Configuration: Decision Strategy \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"id == 1\" ] ], \"between_hacks_selection_policies\" : [[ \"\" ]], \"between_replications_selection_policies\" : [[ \"\" ]], \"stashing_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"will_start_hacking_decision_policies\" : [ \"\" ] }","title":"Decision Strategies"},{"location":"examples/bakker_et_al_2014/#results","text":"","title":"Results"},{"location":"examples/bakker_et_al_2014/#original-vs-reproduction","text":"Figure 3 shows the results of removing outliers from a normally distributed sum scores, aka. linear model. This is the equivalent of results showcased in Figure 1 of Bakker et al. 2014. While we didn't overly the results from the original study due to difficulty of extracting the data in compatible format, it can be seen that our results agrees with results form the original study, and we see a similar trends in Type I Error reduction as we increase k . Chance of finding a significant result with regards to different values of \u03b1 . Similarly, Figure 4 shows the results of removing outliers from Rasch and GRM. Figure 4 is equivalent of results presented in Figure 2, and 3 of Bakker study. We again see a similar trends with respect to increasing k , number of items and higher difficultly. Chance of finding a significant result with regards to different values of \u03b1 .","title":"Original vs. Reproduction"},{"location":"examples/bakker_et_al_2014/#first-extension-effect-of-publication-bias","text":"As we did with Bakker et al., 2012 study, we demonstrate how we can extend the currently established simulation with a few modification and explore different aspects of the problem using SAM. In the first extension, we introduce a biased journal to the simulation by modifying the selection strategy of the Journal module as follow: Configuration: Biased Journal \"journal_parameters\" : { \"max_pubs\" : 5000 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.05 , \"pub_bias\" : Pb , \"side\" : 0 } } By varying this configuration, and keeping the rest of the setup intact, we will be able to study the effect of publication bias on our design. Figure 5 shows the results of this modification. As one would expect, we can see higher Type I error in publications as we increase the publication bias rate, from top to bottom. Also, we can see that Type I error rate decreases as we increase the number of items, and examinees, as expected. Rasch, \u03b8 = 0 Chance of finding a significant result with regards to different values of \u03b1 . Rasch, \u03b8 = 3 Chance of finding a significant result with regards to different values of \u03b1 . GRM, \u03b8 = 0 Chance of finding a significant result with regards to different values of \u03b1 . GRM, \u03b8 = 3 Chance of finding a significant result with regards to different values of \u03b1 .","title":"First Extension: Effect of Publication Bias"},{"location":"examples/bakker_et_al_2014/#second-extension-meta-analysis-and-bias-level","text":"While we will discuss the power of Egger's Test and several other meta-analysis metrics, and publication bias correction methods in Maassen et al. simulation study, here for the second extension, we focus on the linear model of Bakker et al., 2014 simulation and study the power/accuracy of Egger's Test on two different meta-analysis pool with different size as well as the accuracy of Random Effect estimator, Figure 6 and Figure 7 respectively. Configuration: Biased Journal \"journal_parameters\" : { \"max_pubs\" : 5000 , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"alpha\" : 0.05 , \"pub_bias\" : Pb , \"side\" : 0 }, \"meta_analysis_metrics\" : [ { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 } ] } Chance of finding a significant result with regards to different values of \u03b1 . Chance of finding a significant result with regards to different values of \u03b1 . Marjan Bakker and Jelte M. Wicherts. Outlier removal, sum scores, and the inflation of the type i error rate in independent samples t tests: the power of alternatives and recommendations. Psychological Methods , 19 3 3 :409\u2013427, 2014. URL: https://doi.org/10.1037%2Fmet0000014 , doi:10.1037/met0000014 . \u21a9 \u21a9 Fumiko Samejima. Graded Response Model , pages 85\u2013100. Springer New York, New York, NY, 1997. URL: https://doi.org/10.1007/978-1-4757-2691-6_5 , doi:10.1007/978-1-4757-2691-6_5 . \u21a9 KAREN K. YUEN. The two-sample trimmed t for unequal population variances. Biometrika , 61 1 1 :165\u2013170, 04 1974. URL: https://doi.org/10.1093/biomet/61.1.165 , doi:10.1093/biomet/61.1.165 . \u21a9 Frank Wilcoxon. Individual Comparisons by Ranking Methods , pages 196\u2013202. Springer New York, New York, NY, 1992. URL: https://doi.org/10.1007/978-1-4612-4380-9_16 , doi:10.1007/978-1-4612-4380-9_16 . \u21a9 Susan E Embretson and Steven Paul Reise. Item response theory for psychologists. Maheah . New Jersey: Lawrence Erlbaum Associates, Publishers, 2000. \u21a9","title":"Second Extension: Meta-analysis and Bias Level"},{"location":"examples/esther_first_year/","text":"Estimating Effect Size in Meta-analysis in the Presence of Publication Bias and Questionable Research Practices \u00b6 In this report, we aim to reproduce and expand Maassen's research project. In her project, Maassen evaluated the power of several publication bias tests on studies that have been gone under different questionable research practices. Additionally, she altered the intensity of publication bias in order to asses the volatility of their power's. This paper investigates the impact of publication bias, two questionable research practices (i.e. optional stopping and selective reporting of dependent variables) and their combination on effect size estimates, coverage and power of fixed effect meta-analysis and heterogeneity estimates of random effects meta-analysis. Additionally, the power of three publication bias tests will be estimated, as well as the effect size estimate adjusted for funnel plot asymmetry and the number of trimmed studies from the trim and fill method. \u2014 Maassen Beyond fixed- and random-effects estimators, the list of publication bias tests includes: Egger's Test 1 Test of Excess of Significant Findings 2 Trim and Fill 3 Rank Correlation 4 Simulation Design \u00b6 Maassen has included a range of parameters in her study. The simulation study has been conducted on all combination of parameters from the list below. n \u2208 {2, 5} P b \u2208 {0., 0.05, 0.5, 1} K \u2208 {8, 24, 72} N 75% Small \u2208 [6, 21] 25% Large \u2208 [22, 300] \u03bc \u2208 {0, 0.147, 0.3835, 0.699375} \u0251 \u2208 0.05 QRPs None Selective Reporting Selective Reporting Optional Stopping Starting from the top, the simulation study concerns itself with two main Experiment Setup . One with 2, and another with 5 conditions. The sample size, N , of each study is drawn from a piecewise linear distribution where 75% of samples are from [6, 21], and the rest are spreading uniformly between 22 and 300. In addition, true means, \u03bc , of treatment conditions varies between 4 pre-calculated effect size representing studies with small, medium and large power. Maassen's Experiment Design In terms of QRPs, two main methods have been utilized, Selective Reporting , and Optional Stopping . While the optional stopping has been applied on both study designs (at most 3 times, adding \u2153 \u2a09 N new observations), the selective reporting can only be applied on the design with 5 conditions (selecting the outcome with minimum p -value). Finally, after simulating K studies, Maassen applied both meta-analytic methods, and publication bias estimators, and reported their performance. SAM's Configuration \u00b6 As discussed in other examples, visualizing the simulation flow helps us translate our design to SAM's configuration, Figure 2. While the right-hand side of the flowchart shows the main decision workflow, the left-side mainly describes the process of applying different QRPs based on specific simulation configurations. Figure 2. Maassen's Simulation Design Decision Strategy \u00b6 As we discussed, selective reporting is being applied using the decision strategy module. The Researcher will either select the only available outcome if there is only one primary outcome (ie., no selective reporting), or she will select an outcome with minimum p -value in the presence of selective reporting, line 4. In cases where the Researcher is equipped with optional stopping, she will decide to apply the method if the selected outcome is not significant, line 5. Finally, if optional stopping has been applied more than once on a study, the last result will be selected, line 6. Configuration: Decision Strategy 2 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"id == 1\" ] ], \"will_start_hacking_decision_policies\" : [ \"!sig\" ], \"stashing_policy\" : [ \"min(pvalue)\" ], \"between_hacks_selection_policies\" : [ [ \"last\" ] ], \"between_replications_selection_policies\" : [[ \"\" ]], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] } } 5 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"min(pvalue)\" ] ], \"will_start_hacking_decision_policies\" : [ \"!sig\" ], \"stashing_policy\" : [ \"min(pvalue)\" ], \"between_hacks_selection_policies\" : [ [ \"last\" ] ], \"between_replications_selection_policies\" : [[ \"\" ]], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] } } Hacking Strategy \u00b6 We can configure our hacking strategy as follows. Notice the repetition of decision and selection policies at highlighted lines. This configuration mimics the behavior of \"peeking at minimum p -value after each step\". After addition of \u2153 \u2a09 N, the Researcher selects the outcome with minimum p -value, and if the selected outcome is significant, she stops and reports the outcome, if not, she continues adding another batch of observations, and repeat this process at most 3 times. Configuration: Hacking Strategy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 { \"probability_of_being_a_hacker\" : 0 or 1 , \"probability_of_committing_a_hack\" : 1 , \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"add_by_fraction\" : 0.3 }, [ [ \"min(pvalue)\" ] ], [ \"!sig\" ] ], [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"add_by_fraction\" : 0.3 }, [ [ \"min(pvalue)\" ] ], [ \"!sig\" ] ], [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"add_by_fraction\" : 0.3 }, [ [ \"min(pvalue)\" ] ], [ \"!sig\" ] ] ] } Data, Test, and Effect Strategy \u00b6 The combination of Decision Strategy and Hacking Strategy configurations will simulate the process described in Figure 2. Configurations for Data , Test , and Effect strategies have been discussed in more detail in Bakker et al., 2012 example. Configuration: Data Strategy 2 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : n , \"n_dep_vars\" : 1 , \"n_obs\" : { \"dist\" : \"piecewise_constant_distribution\" , \"intervals\" : [ 6 , 24 , 300 ], \"densities\" : [ 0.75 , 0.25 ] }, \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , \u03bc ], \"covs\" : 0.0 , \"stddevs\" : 1.0 } } } 5 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : n , \"n_dep_vars\" : 1 , \"n_obs\" : { \"dist\" : \"piecewise_constant_distribution\" , \"intervals\" : [ 6 , 24 , 300 ], \"densities\" : [ 0.75 , 0.25 ] }, \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , \u03bc , \u03bc , \u03bc , \u03bc ], \"covs\" : 0.0 , \"stddevs\" : 1.0 } } } Configuration: Test Strategy 1 2 3 4 5 6 7 8 9 10 11 12 13 { ... \"experiment_parameters\" : { ... \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : \u0251 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } ... } Configuration: Effect Strategy 1 2 3 4 5 6 7 8 9 10 { ... \"experiment_parameters\" : { ... \"effect_strategy\" : { \"name\" : \"MeanDifferences\" } } ... } Journal \u00b6 In the case of Maassen, we need to induce different level of publication bias on our selection procedure. Moreover, we need to calculate a set of meta-analysis and publication bias tests after maxing-out the publications pool. These parameters can be set as follow: Journal: Publication Bias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 { ... \"journal_parameters\" : { \"max_pubs\" : K , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : Pb , \"alpha\" : \u0251 , \"side\" : 0 , }, \"meta_analysis_metrics\" : [ { \"name\" : \"FixedEffectEstimator\" }, { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 }, { \"name\" : \"TrimAndFill\" , \"alpha\" : 0.1 , \"estimator\" : \"R0\" , \"side\" : \"auto\" }, { \"name\" : \"RankCorrelation\" , \"alpha\" : 0.1 , \"alternative\" : \"TwoSided\" }, { \"name\" : \"TestOfObsOverExptSig\" , \"alpha\" : 0.1 } ] } ... } Extended Simulation \u00b6 In the case of Maassen's simulation, we decided to extend the simulation by covering full range of publication bias, P b , and true effect size, \u03bc . This extension does not change our main body of configuration. We only need to generate more configuration files with different values of P b , and \u03bc . \u03bc \u2208 [0, 1] P b \u2208 [0., 1.] Figures 3\u20138 illustrate our results in the form of contour plots. The x-axis corresponds to the range of true effect sizes, and y-axis shows the publication bias level, finally contour regions represent the level of bias, or power of our tests. Staring by the proportion of significant results in our outcomes pool, we notice a regular and expected pattern of higher proportion of significant results with higher true effect sizes and higher rate of publication bias, ie., the yellow region of each plot. Moreover, we see a clear shrinkage in the size of this region as we lower \u0251 . Furthermore, notice the growth of the darker regions in lower effect sizes; which can be seen as the influence of lowering \u0251 on diminishing the chance of finding significant results with lower true effect sizes. Figure 3. Probability of Finding Sig. Looking at the level of effect size bias, we observe higher bias in studies with 5 dependent variables. Moreover, notice the minor negligible effect of our QRPs on the level of bias. This is inline with our results from Bakker et al., 2012 where we concluded that the source of biases is the number of replications, and not the QRPs. Figure 4. Effect Size Bias Figure below visualizes the accuracy of random-effect estimate's of the effect size. As we expected, the random-effect estimate improves as we increase K , and declines as we introduce more dependent variables. Figure 5. Random Effect Estimate's Bias As shown below, power of Egger's test consistently improves as we add more publications to our pool, K . Moreover, as expected, we can observe the correlation of higher power with the increase of the publication bias rate. Notice the slight increase of the yellow region as we lowers \u0251 , and add more dependent variables. Furthermore, as we discussed in Bakker et al., 2012 , we observe a high rate of false positive in simulations with low publication bias rate. Figure 6. Power of Egger's Test Begg's Rank Correlation Test is an another test for detecting publication bias. As stated by Begg et al. 4 , the test has a fair power with K > 75 , and expected to have lower power with lower K 's. While we only simulated pools of publications with K = 72 , we can observe the increase in Begg's test power as we increase K . It is worth mentioning that Begg's test performs better than Egger's test in terms of false positives. This can be seen by comparing the size of yellow regions within lower half of each plot, as we see much smaller confidence in reporting publication bias when the true publication bias is lower. Figure 7. Power of Begg's Rank Correlation Test Test Of Excess of Significant Findings [In Progress] Finally, we measured the power of Test Of Excess of Significant Findings. Figure below shows the results of this measure across our parameters landscape. We are quite surprised with the test, and cannot quite make sense of it yet! Further explanation will follow! Figure 8. Power of Test of Excess of Significant Findings. Matthias Egger, George Davey Smith, Martin Schneider, and Christoph Minder. Bias in meta-analysis detected by a simple, graphical test. BMJ , 315 7109 7109 :629\u2013634, 1997. \u21a9 John PA Ioannidis and Thomas A Trikalinos. An exploratory test for an excess of significant findings. Clinical Trials: Journal of the Society for Clinical Trials , 4 3 3 :245\u2013253, jun 2007. URL: https://doi.org/10.1177%2F1740774507079441 , doi:10.1177/1740774507079441 . \u21a9 Sue Duval and Richard Tweedie. Trim and fill: a simple funnel-plot\u2013based method of testing and adjusting for publication bias in meta-analysis. Biometrics , 56 2 2 :455\u2013463, 2000. URL: https://onlinelibrary.wiley.com/doi/abs/10.1111/j.0006-341X.2000.00455.x , arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.0006-341X.2000.00455.x , doi:10.1111/j.0006-341X.2000.00455.x . \u21a9 Colin B. Begg and Madhuchhanda Mazumdar. Operating characteristics of a rank correlation test for publication bias. Biometrics , 50 4 4 :1088\u20131101, 1994. URL: http://www.jstor.org/stable/2533446 . \u21a9 \u21a9","title":"Maassen et al., 2016"},{"location":"examples/esther_first_year/#estimating-effect-size-in-meta-analysis-in-the-presence-of-publication-bias-and-questionable-research-practices","text":"In this report, we aim to reproduce and expand Maassen's research project. In her project, Maassen evaluated the power of several publication bias tests on studies that have been gone under different questionable research practices. Additionally, she altered the intensity of publication bias in order to asses the volatility of their power's. This paper investigates the impact of publication bias, two questionable research practices (i.e. optional stopping and selective reporting of dependent variables) and their combination on effect size estimates, coverage and power of fixed effect meta-analysis and heterogeneity estimates of random effects meta-analysis. Additionally, the power of three publication bias tests will be estimated, as well as the effect size estimate adjusted for funnel plot asymmetry and the number of trimmed studies from the trim and fill method. \u2014 Maassen Beyond fixed- and random-effects estimators, the list of publication bias tests includes: Egger's Test 1 Test of Excess of Significant Findings 2 Trim and Fill 3 Rank Correlation 4","title":"Estimating Effect Size in Meta-analysis in the Presence of Publication Bias and Questionable Research Practices"},{"location":"examples/esther_first_year/#simulation-design","text":"Maassen has included a range of parameters in her study. The simulation study has been conducted on all combination of parameters from the list below. n \u2208 {2, 5} P b \u2208 {0., 0.05, 0.5, 1} K \u2208 {8, 24, 72} N 75% Small \u2208 [6, 21] 25% Large \u2208 [22, 300] \u03bc \u2208 {0, 0.147, 0.3835, 0.699375} \u0251 \u2208 0.05 QRPs None Selective Reporting Selective Reporting Optional Stopping Starting from the top, the simulation study concerns itself with two main Experiment Setup . One with 2, and another with 5 conditions. The sample size, N , of each study is drawn from a piecewise linear distribution where 75% of samples are from [6, 21], and the rest are spreading uniformly between 22 and 300. In addition, true means, \u03bc , of treatment conditions varies between 4 pre-calculated effect size representing studies with small, medium and large power. Maassen's Experiment Design In terms of QRPs, two main methods have been utilized, Selective Reporting , and Optional Stopping . While the optional stopping has been applied on both study designs (at most 3 times, adding \u2153 \u2a09 N new observations), the selective reporting can only be applied on the design with 5 conditions (selecting the outcome with minimum p -value). Finally, after simulating K studies, Maassen applied both meta-analytic methods, and publication bias estimators, and reported their performance.","title":"Simulation Design"},{"location":"examples/esther_first_year/#sams-configuration","text":"As discussed in other examples, visualizing the simulation flow helps us translate our design to SAM's configuration, Figure 2. While the right-hand side of the flowchart shows the main decision workflow, the left-side mainly describes the process of applying different QRPs based on specific simulation configurations. Figure 2. Maassen's Simulation Design","title":"SAM's Configuration"},{"location":"examples/esther_first_year/#decision-strategy","text":"As we discussed, selective reporting is being applied using the decision strategy module. The Researcher will either select the only available outcome if there is only one primary outcome (ie., no selective reporting), or she will select an outcome with minimum p -value in the presence of selective reporting, line 4. In cases where the Researcher is equipped with optional stopping, she will decide to apply the method if the selected outcome is not significant, line 5. Finally, if optional stopping has been applied more than once on a study, the last result will be selected, line 6. Configuration: Decision Strategy 2 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"id == 1\" ] ], \"will_start_hacking_decision_policies\" : [ \"!sig\" ], \"stashing_policy\" : [ \"min(pvalue)\" ], \"between_hacks_selection_policies\" : [ [ \"last\" ] ], \"between_replications_selection_policies\" : [[ \"\" ]], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] } } 5 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"min(pvalue)\" ] ], \"will_start_hacking_decision_policies\" : [ \"!sig\" ], \"stashing_policy\" : [ \"min(pvalue)\" ], \"between_hacks_selection_policies\" : [ [ \"last\" ] ], \"between_replications_selection_policies\" : [[ \"\" ]], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] } }","title":"Decision Strategy"},{"location":"examples/esther_first_year/#hacking-strategy","text":"We can configure our hacking strategy as follows. Notice the repetition of decision and selection policies at highlighted lines. This configuration mimics the behavior of \"peeking at minimum p -value after each step\". After addition of \u2153 \u2a09 N, the Researcher selects the outcome with minimum p -value, and if the selected outcome is significant, she stops and reports the outcome, if not, she continues adding another batch of observations, and repeat this process at most 3 times. Configuration: Hacking Strategy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 { \"probability_of_being_a_hacker\" : 0 or 1 , \"probability_of_committing_a_hack\" : 1 , \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"add_by_fraction\" : 0.3 }, [ [ \"min(pvalue)\" ] ], [ \"!sig\" ] ], [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"add_by_fraction\" : 0.3 }, [ [ \"min(pvalue)\" ] ], [ \"!sig\" ] ], [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"add_by_fraction\" : 0.3 }, [ [ \"min(pvalue)\" ] ], [ \"!sig\" ] ] ] }","title":"Hacking Strategy"},{"location":"examples/esther_first_year/#data-test-and-effect-strategy","text":"The combination of Decision Strategy and Hacking Strategy configurations will simulate the process described in Figure 2. Configurations for Data , Test , and Effect strategies have been discussed in more detail in Bakker et al., 2012 example. Configuration: Data Strategy 2 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : n , \"n_dep_vars\" : 1 , \"n_obs\" : { \"dist\" : \"piecewise_constant_distribution\" , \"intervals\" : [ 6 , 24 , 300 ], \"densities\" : [ 0.75 , 0.25 ] }, \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , \u03bc ], \"covs\" : 0.0 , \"stddevs\" : 1.0 } } } 5 Conditions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : n , \"n_dep_vars\" : 1 , \"n_obs\" : { \"dist\" : \"piecewise_constant_distribution\" , \"intervals\" : [ 6 , 24 , 300 ], \"densities\" : [ 0.75 , 0.25 ] }, \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , \u03bc , \u03bc , \u03bc , \u03bc ], \"covs\" : 0.0 , \"stddevs\" : 1.0 } } } Configuration: Test Strategy 1 2 3 4 5 6 7 8 9 10 11 12 13 { ... \"experiment_parameters\" : { ... \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : \u0251 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } ... } Configuration: Effect Strategy 1 2 3 4 5 6 7 8 9 10 { ... \"experiment_parameters\" : { ... \"effect_strategy\" : { \"name\" : \"MeanDifferences\" } } ... }","title":"Data, Test, and Effect Strategy"},{"location":"examples/esther_first_year/#journal","text":"In the case of Maassen, we need to induce different level of publication bias on our selection procedure. Moreover, we need to calculate a set of meta-analysis and publication bias tests after maxing-out the publications pool. These parameters can be set as follow: Journal: Publication Bias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 { ... \"journal_parameters\" : { \"max_pubs\" : K , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : Pb , \"alpha\" : \u0251 , \"side\" : 0 , }, \"meta_analysis_metrics\" : [ { \"name\" : \"FixedEffectEstimator\" }, { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 }, { \"name\" : \"TrimAndFill\" , \"alpha\" : 0.1 , \"estimator\" : \"R0\" , \"side\" : \"auto\" }, { \"name\" : \"RankCorrelation\" , \"alpha\" : 0.1 , \"alternative\" : \"TwoSided\" }, { \"name\" : \"TestOfObsOverExptSig\" , \"alpha\" : 0.1 } ] } ... }","title":"Journal"},{"location":"examples/esther_first_year/#extended-simulation","text":"In the case of Maassen's simulation, we decided to extend the simulation by covering full range of publication bias, P b , and true effect size, \u03bc . This extension does not change our main body of configuration. We only need to generate more configuration files with different values of P b , and \u03bc . \u03bc \u2208 [0, 1] P b \u2208 [0., 1.] Figures 3\u20138 illustrate our results in the form of contour plots. The x-axis corresponds to the range of true effect sizes, and y-axis shows the publication bias level, finally contour regions represent the level of bias, or power of our tests. Staring by the proportion of significant results in our outcomes pool, we notice a regular and expected pattern of higher proportion of significant results with higher true effect sizes and higher rate of publication bias, ie., the yellow region of each plot. Moreover, we see a clear shrinkage in the size of this region as we lower \u0251 . Furthermore, notice the growth of the darker regions in lower effect sizes; which can be seen as the influence of lowering \u0251 on diminishing the chance of finding significant results with lower true effect sizes. Figure 3. Probability of Finding Sig. Looking at the level of effect size bias, we observe higher bias in studies with 5 dependent variables. Moreover, notice the minor negligible effect of our QRPs on the level of bias. This is inline with our results from Bakker et al., 2012 where we concluded that the source of biases is the number of replications, and not the QRPs. Figure 4. Effect Size Bias Figure below visualizes the accuracy of random-effect estimate's of the effect size. As we expected, the random-effect estimate improves as we increase K , and declines as we introduce more dependent variables. Figure 5. Random Effect Estimate's Bias As shown below, power of Egger's test consistently improves as we add more publications to our pool, K . Moreover, as expected, we can observe the correlation of higher power with the increase of the publication bias rate. Notice the slight increase of the yellow region as we lowers \u0251 , and add more dependent variables. Furthermore, as we discussed in Bakker et al., 2012 , we observe a high rate of false positive in simulations with low publication bias rate. Figure 6. Power of Egger's Test Begg's Rank Correlation Test is an another test for detecting publication bias. As stated by Begg et al. 4 , the test has a fair power with K > 75 , and expected to have lower power with lower K 's. While we only simulated pools of publications with K = 72 , we can observe the increase in Begg's test power as we increase K . It is worth mentioning that Begg's test performs better than Egger's test in terms of false positives. This can be seen by comparing the size of yellow regions within lower half of each plot, as we see much smaller confidence in reporting publication bias when the true publication bias is lower. Figure 7. Power of Begg's Rank Correlation Test Test Of Excess of Significant Findings [In Progress] Finally, we measured the power of Test Of Excess of Significant Findings. Figure below shows the results of this measure across our parameters landscape. We are quite surprised with the test, and cannot quite make sense of it yet! Further explanation will follow! Figure 8. Power of Test of Excess of Significant Findings. Matthias Egger, George Davey Smith, Martin Schneider, and Christoph Minder. Bias in meta-analysis detected by a simple, graphical test. BMJ , 315 7109 7109 :629\u2013634, 1997. \u21a9 John PA Ioannidis and Thomas A Trikalinos. An exploratory test for an excess of significant findings. Clinical Trials: Journal of the Society for Clinical Trials , 4 3 3 :245\u2013253, jun 2007. URL: https://doi.org/10.1177%2F1740774507079441 , doi:10.1177/1740774507079441 . \u21a9 Sue Duval and Richard Tweedie. Trim and fill: a simple funnel-plot\u2013based method of testing and adjusting for publication bias in meta-analysis. Biometrics , 56 2 2 :455\u2013463, 2000. URL: https://onlinelibrary.wiley.com/doi/abs/10.1111/j.0006-341X.2000.00455.x , arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.0006-341X.2000.00455.x , doi:10.1111/j.0006-341X.2000.00455.x . \u21a9 Colin B. Begg and Madhuchhanda Mazumdar. Operating characteristics of a rank correlation test for publication bias. Biometrics , 50 4 4 :1088\u20131101, 1994. URL: http://www.jstor.org/stable/2533446 . \u21a9 \u21a9","title":"Extended Simulation"},{"location":"examples/friese_et_al_2020/","text":"p -Hacking and Publication Bias Interact to Distort Meta- Analytic Effect Size Estimates 1 \u00b6 Friese Simulation Malte Friese and Julius Frankenbach. P-hacking and publication bias interact to distort meta-analytic effect size estimates. Psychol Methods , 25 4 4 :456\u2013471, Aug 2020. doi:10.1037/met0000246 . \u21a9","title":"Friese et al., 2020"},{"location":"examples/friese_et_al_2020/#p-hacking-and-publication-bias-interact-to-distort-meta-analytic-effect-size-estimates1","text":"Friese Simulation Malte Friese and Julius Frankenbach. P-hacking and publication bias interact to distort meta-analytic effect size estimates. Psychol Methods , 25 4 4 :456\u2013471, Aug 2020. doi:10.1037/met0000246 . \u21a9","title":"p-Hacking and Publication Bias Interact to Distort Meta- Analytic Effect Size Estimates1"},{"location":"frodo/frodo/","text":"Frodo \u00b6 Frodo is a collection of scripts that facilitates the process of creating, managing and running SAM projects. With Frodo, you can create, remove, or archive your projects. In addition, when within your project, Frodo offers several useful tools to simplify the process of configuring and running your project. Attention Frodo has developed as an internal tool to help us test and develop SAM with greater speed and precision. As the project grew, we realized that some of the tools might be useful to other developers too; so, we decided to package and release it as well. Requirement \u00b6 Frodo is mainly written in GNU Make and it should be available on most operation systems by default. On Windows, you may either install Cygwin or if you are running newer version of Windows, e.g., Windows 10, you may install the Windows Subsystem for Linux . Alternatively, if you find the method above tedious, you may opt for installing the Anaconda package to get most of the tools needed to run Frodo and its dependent scripts. This is a valid alternative on all three mainstream operation systems if you do not currently have a development environment ready, or do not know how to set it up correctly. Often installing Anaconda is enough to get a proper and well-functioning scientific development environment. Getting Started with Frodo \u00b6 After successfully preparing your system, you can download Frodo from GitHub using: git clone https://github.com/amirmasoudabdol/Frodo.git You may now cd into the Frodo folder, and simply type make on the command line to run Frodo. This should show some helpful information about available commands and parameters. This is Frodo, a handy toolset for preparing a new project using SAM. In the process of 'prepare'-ing a new project, this Makefile produces several template files for configuring and running a SAM project on your local machine or on Lisa cluster. Make sure that this Makefile knows where SAM and other dependencies are located. You can set their path through the parameters defined in line 9 \u2013 12 of the Makefile. Usage: make <target> parameter=value help Display this help [Parameters] project Project name path Project path, defaults to ./projects/ ----------------------------------------------------------- Build prepare Create a new project by running <config> and <sam> config Building necessary files and folders for a new project sam Build SAMrun executable. Note: This will update SAM source directory and rebuild it compress Zip everything in the <project> Cleanup clean Remove all output files, i.e., configs, outputs, logs, jobs veryclean Remove all project files remove Delete the entire project directory Example Usage: make prepare project=apollo path=HOME/Projects/ make remove project=apollo Start by preparing a project, and observing the output, e.g., make prepare project=apollo . This creates a folder in the projects/ folder named apollo , and populates it with files and scripts necessary for running a SAM simulation. Notice the messages produced by Frodo during this process. Sample output of make prepare project=apollo An example output of Frodo's prepare command: > Preparing apollo... > Prepare a copy of SAM for apollo... > Preparing project files... > Copying SAM... > Configuring SAM... ... some CMake messages ... > Building SAM... ... some CMake messages ... [100%] Built target SAMrun > Successfully prepared and saved \"apollo\" in \"/projects\" ... > `cd` into the project folder and start with the `make` command ... Warning Frodo stores several template scripts in the scripts/ folder, and it uses them to configure your projects correctly. It's recommended not to mess with these files unless you know what you are doing! Primary Commands \u00b6 While Frodo offers a range of commands, there are a few important ones that you should know about: The prepare command \u00b6 Use the prepare command to create a new project, e.g., make prepare project=your-project-name . After using the prepare command, Frodo creates a new directory at projects/your-project-name and fill it with all the necessary files. Two files are particularity important: your-project-name_prepare_config_files.py is a project-specific script that describe the specification of your parameters space. You can find and modify this file at projects/your-project-name/scripts/your-project-name_prepare_config_files.py your-project-name_post_processing.R is another project-specific script that is being used by Frodo to perform post-processing analysis on SAM's output. You can find and modify this file at projects/your-project-name/scripts/your-project-name_prepare_config_files.py Project Frodo will cover the full list of these files and folders. The load Command and templates/ folder \u00b6 With the load command, you are telling Frodo that you like to load your projects with some of your customized script files. The templates/ folder is where Frodo looks for project-specific files and templates. Two of the most important template files that you should prepare for your projects are: your-project-name_prepare_config_files.py and your-project-name_post_processing.R . If you have created and placed these files for your projects in the templates/ folder, running make load project=your-project-name will replace the default scripts with these two user-defined templates. Example You may use the template folder for quickly setting up new projects. The general procedure looks something like this: make prepare project=discovery to create a new project Create two project-specific template files, e.g., discovery_prepare_config_files.py and discovery_post_processing.R make load project=discovery cd projects/discovery to go into your project folder make parameters to generate new configuration files based on the discovery_prepare_config_files.py Project Frodo \u00b6 After preparing a project, you can head into the projects/your-project-name , and observe all the files created by Frodo for your projects. Makefile , this is the Project Frodo ! SAMrun , an instance of SAM program that you can use to run your simulation. Run ./SAMrun --help for more info. configfilenames.pool , a list of all the configuration files to run using SAM. SAM/ , a folder containing SAM's code and its dependencies. configs/ , a folder containing all the configuration files. dbs/ , a folder containing databases generated by Frodo. jobs/ , a folder containing job scripts for running SAM on SURFSara's Lisa Cluster. logs/ , a folder containing log files produced by SAM. outputs/ , a folder containing output files produced by SAM. scripts/ , a folder containing scripts used by Frodo to run, configure, and summarize SAM's results. As you can see, each file and folder has its purpose and unless you know what you are doing you should not mess with them. The SAMrun executable is the most important item of this list. You can either use this file manually to run your simulation, ./SAMrun --config=your-config-file.json , or use the Project Frodo to run a batch of configuration files. Using the Project Frodo \u00b6 You can run the Project Frodo as before by running the make command inside your project folder. Executing the make command again shows a list of commands and parameters offered by Project Frodo. This is Project Frodo, you can control your project using this Makefile. There are several commands are available for running your simulation locally or on a cluster. It's also possible to run the simulation sequentially or in parallel on your local machine. Usage: make <target> help Display this help [Paramters] using Path to a new parameter generator name The name of the archive -------------------------------------------------------------- Build sam-build Rebuild the binaries, run this if you've modified the code parameters Preparing config files for SAM Post-processing csv Create a set of files `*_prepared.csv` by adding all keys/values to them. Use this when the database is too big stack Stack several CSV files into one CSV file stacker Faster version of stacker. Use this for lager data files database Aggregate output files into a SQLite database summary Runinng the `post-processing.R` script on every file in output/ folder Run run-seq-local Running the simulation sequentially on the local machine run-par-local Running the simulation in parallel on the local machine run-par-lisa Running the simulation in parallel on the Lisa cluster run-par-lisa-batch Running the simulation in parallel on the Lisa cluster Packaging archive Archiving the entire project directory to ../marjan_2012_all_test_archive/archive/CUREENT_DATE_TIME or ../marjan_2012_all_test_analysis/archive/<name> compress Compress the outputs/*, logs/* and configs/* Cleanup clean Remove most project specific files, configs, jobs, logs, etc. veryclean Remove all project files, including outputs Example Usage: make parameters using=~/projects_config/2012_project.py make run-seq-local; make archive name=Feb_5.zip Here, Frodo turns into a project-specific helper tool and helps you configure and run your simulation, as well as exporting and archiving your results. In order to run a big simulation with lots of configuration files using the Project Frodo, you first need to create a list of configuration files using parameters , and then execute SAM on every one of them using the run-seq-local command. make parameters make run-seq-local The make parameters first runs the your-project-name_prepare_config_files.py file to generates all your configuration files and store them into the configs/ folder. In addition, Frodo stores a list of all the generated configuration files into the configfilenames.pool file. After successfully running the make parameters , you can run your simulation on every files using make run-seq-local , or by manually running SAM on any of the available configuration files using ./SAMrun --config=configs/your-selected-config-file.json . Note Frodo assumes that you have already prepared the your-project-name_prepare_config_files.py file beforehand. If you have not, you may head into the scripts/ folder, modify it based on your preferences and head back and run the make parameters again. If you have already placed a customized version of the your-project-name_prepare_config_files.py script in the templates/ folder, then you may simply load it to the project and speed up your process. make prepare project = discovery make load project = discovery cd projects/discovery make parameters make run-seq-local This is specially a useful approach if you are planning to iterate over your design. In this case, you can run your simulation, process your results, then modify the your-project-name_prepare_config_files.py file, and head back to your project to repeat the process with new set of parameters and simulation specification. Cleaning Up Your Project \u00b6 You should be aware that after each run, most of the folders are filled with your project files, e.g., configs/ , outputs/ , logs/ . If you plan to re-run your project, it is recommended to clean up the project before running Frodo/SAM again. This guarantees that your output files are corresponding to your configuration files, and no file from the previous run is lurking around in your project folder. make clean command removes all your project specific files but leaves the outputs/ files intact. make veryclean command removes all your project files, including your outputs/ files. Running the Simulations in Parallel \u00b6 As you may have noticed, Frodo offers several run commands. The second part of the command indicates whether the simulations will be run sequentially; or they can run in parallel (e.g., 8 simulation at a time). run-seq-local , runs run-par-local run-par-lisa In addition, if you are using the SURFsara Lisa cluster, you may use the last command to fully take advantage of the cluster system and distribute your simulation across the Lisa cluster. This command automatically creates a temporary folder on Lisa, request several nodes, distribute and run SAM across the cluster and finally collects all the output data and stores them into the outputs/ folder. Post Processing \u00b6 After running your simulation, Frodo stores all of the output files generated by SAM into the outputs/ folder. At this stage, you may start extracting the output files and analyze your simulation data. While you can simply copy the files and process them using R, or any other programming language. The Project Frodo offers a few utilities to make your life a bit easier. csv stack stacker database summary The csv command is maybe one of the most useful commands in Frodo. It essentially combines your configuration file with your outputs. This is very useful for when you are working with a large grid of parameters. For instance, if you are running a re-running your simulation setup for 10 different values of true effect size, \u03bc, you will at least have 10 output files. While SAM names your output files similar to your config files, you simulation parameters are not listed in the output files. The csv command basically merge each configuration file with its appropriate output file. This is is very handy especially when you want to group your output files in R.","title":"Frodo"},{"location":"frodo/frodo/#frodo","text":"Frodo is a collection of scripts that facilitates the process of creating, managing and running SAM projects. With Frodo, you can create, remove, or archive your projects. In addition, when within your project, Frodo offers several useful tools to simplify the process of configuring and running your project. Attention Frodo has developed as an internal tool to help us test and develop SAM with greater speed and precision. As the project grew, we realized that some of the tools might be useful to other developers too; so, we decided to package and release it as well.","title":"Frodo"},{"location":"frodo/frodo/#requirement","text":"Frodo is mainly written in GNU Make and it should be available on most operation systems by default. On Windows, you may either install Cygwin or if you are running newer version of Windows, e.g., Windows 10, you may install the Windows Subsystem for Linux . Alternatively, if you find the method above tedious, you may opt for installing the Anaconda package to get most of the tools needed to run Frodo and its dependent scripts. This is a valid alternative on all three mainstream operation systems if you do not currently have a development environment ready, or do not know how to set it up correctly. Often installing Anaconda is enough to get a proper and well-functioning scientific development environment.","title":"Requirement"},{"location":"frodo/frodo/#getting-started-with-frodo","text":"After successfully preparing your system, you can download Frodo from GitHub using: git clone https://github.com/amirmasoudabdol/Frodo.git You may now cd into the Frodo folder, and simply type make on the command line to run Frodo. This should show some helpful information about available commands and parameters. This is Frodo, a handy toolset for preparing a new project using SAM. In the process of 'prepare'-ing a new project, this Makefile produces several template files for configuring and running a SAM project on your local machine or on Lisa cluster. Make sure that this Makefile knows where SAM and other dependencies are located. You can set their path through the parameters defined in line 9 \u2013 12 of the Makefile. Usage: make <target> parameter=value help Display this help [Parameters] project Project name path Project path, defaults to ./projects/ ----------------------------------------------------------- Build prepare Create a new project by running <config> and <sam> config Building necessary files and folders for a new project sam Build SAMrun executable. Note: This will update SAM source directory and rebuild it compress Zip everything in the <project> Cleanup clean Remove all output files, i.e., configs, outputs, logs, jobs veryclean Remove all project files remove Delete the entire project directory Example Usage: make prepare project=apollo path=HOME/Projects/ make remove project=apollo Start by preparing a project, and observing the output, e.g., make prepare project=apollo . This creates a folder in the projects/ folder named apollo , and populates it with files and scripts necessary for running a SAM simulation. Notice the messages produced by Frodo during this process. Sample output of make prepare project=apollo An example output of Frodo's prepare command: > Preparing apollo... > Prepare a copy of SAM for apollo... > Preparing project files... > Copying SAM... > Configuring SAM... ... some CMake messages ... > Building SAM... ... some CMake messages ... [100%] Built target SAMrun > Successfully prepared and saved \"apollo\" in \"/projects\" ... > `cd` into the project folder and start with the `make` command ... Warning Frodo stores several template scripts in the scripts/ folder, and it uses them to configure your projects correctly. It's recommended not to mess with these files unless you know what you are doing!","title":"Getting Started with Frodo"},{"location":"frodo/frodo/#primary-commands","text":"While Frodo offers a range of commands, there are a few important ones that you should know about:","title":"Primary Commands"},{"location":"frodo/frodo/#the-prepare-command","text":"Use the prepare command to create a new project, e.g., make prepare project=your-project-name . After using the prepare command, Frodo creates a new directory at projects/your-project-name and fill it with all the necessary files. Two files are particularity important: your-project-name_prepare_config_files.py is a project-specific script that describe the specification of your parameters space. You can find and modify this file at projects/your-project-name/scripts/your-project-name_prepare_config_files.py your-project-name_post_processing.R is another project-specific script that is being used by Frodo to perform post-processing analysis on SAM's output. You can find and modify this file at projects/your-project-name/scripts/your-project-name_prepare_config_files.py Project Frodo will cover the full list of these files and folders.","title":"The prepare command"},{"location":"frodo/frodo/#the-load-command-and-templates-folder","text":"With the load command, you are telling Frodo that you like to load your projects with some of your customized script files. The templates/ folder is where Frodo looks for project-specific files and templates. Two of the most important template files that you should prepare for your projects are: your-project-name_prepare_config_files.py and your-project-name_post_processing.R . If you have created and placed these files for your projects in the templates/ folder, running make load project=your-project-name will replace the default scripts with these two user-defined templates. Example You may use the template folder for quickly setting up new projects. The general procedure looks something like this: make prepare project=discovery to create a new project Create two project-specific template files, e.g., discovery_prepare_config_files.py and discovery_post_processing.R make load project=discovery cd projects/discovery to go into your project folder make parameters to generate new configuration files based on the discovery_prepare_config_files.py","title":"The load Command and templates/ folder"},{"location":"frodo/frodo/#project-frodo","text":"After preparing a project, you can head into the projects/your-project-name , and observe all the files created by Frodo for your projects. Makefile , this is the Project Frodo ! SAMrun , an instance of SAM program that you can use to run your simulation. Run ./SAMrun --help for more info. configfilenames.pool , a list of all the configuration files to run using SAM. SAM/ , a folder containing SAM's code and its dependencies. configs/ , a folder containing all the configuration files. dbs/ , a folder containing databases generated by Frodo. jobs/ , a folder containing job scripts for running SAM on SURFSara's Lisa Cluster. logs/ , a folder containing log files produced by SAM. outputs/ , a folder containing output files produced by SAM. scripts/ , a folder containing scripts used by Frodo to run, configure, and summarize SAM's results. As you can see, each file and folder has its purpose and unless you know what you are doing you should not mess with them. The SAMrun executable is the most important item of this list. You can either use this file manually to run your simulation, ./SAMrun --config=your-config-file.json , or use the Project Frodo to run a batch of configuration files.","title":"Project Frodo"},{"location":"frodo/frodo/#using-the-project-frodo","text":"You can run the Project Frodo as before by running the make command inside your project folder. Executing the make command again shows a list of commands and parameters offered by Project Frodo. This is Project Frodo, you can control your project using this Makefile. There are several commands are available for running your simulation locally or on a cluster. It's also possible to run the simulation sequentially or in parallel on your local machine. Usage: make <target> help Display this help [Paramters] using Path to a new parameter generator name The name of the archive -------------------------------------------------------------- Build sam-build Rebuild the binaries, run this if you've modified the code parameters Preparing config files for SAM Post-processing csv Create a set of files `*_prepared.csv` by adding all keys/values to them. Use this when the database is too big stack Stack several CSV files into one CSV file stacker Faster version of stacker. Use this for lager data files database Aggregate output files into a SQLite database summary Runinng the `post-processing.R` script on every file in output/ folder Run run-seq-local Running the simulation sequentially on the local machine run-par-local Running the simulation in parallel on the local machine run-par-lisa Running the simulation in parallel on the Lisa cluster run-par-lisa-batch Running the simulation in parallel on the Lisa cluster Packaging archive Archiving the entire project directory to ../marjan_2012_all_test_archive/archive/CUREENT_DATE_TIME or ../marjan_2012_all_test_analysis/archive/<name> compress Compress the outputs/*, logs/* and configs/* Cleanup clean Remove most project specific files, configs, jobs, logs, etc. veryclean Remove all project files, including outputs Example Usage: make parameters using=~/projects_config/2012_project.py make run-seq-local; make archive name=Feb_5.zip Here, Frodo turns into a project-specific helper tool and helps you configure and run your simulation, as well as exporting and archiving your results. In order to run a big simulation with lots of configuration files using the Project Frodo, you first need to create a list of configuration files using parameters , and then execute SAM on every one of them using the run-seq-local command. make parameters make run-seq-local The make parameters first runs the your-project-name_prepare_config_files.py file to generates all your configuration files and store them into the configs/ folder. In addition, Frodo stores a list of all the generated configuration files into the configfilenames.pool file. After successfully running the make parameters , you can run your simulation on every files using make run-seq-local , or by manually running SAM on any of the available configuration files using ./SAMrun --config=configs/your-selected-config-file.json . Note Frodo assumes that you have already prepared the your-project-name_prepare_config_files.py file beforehand. If you have not, you may head into the scripts/ folder, modify it based on your preferences and head back and run the make parameters again. If you have already placed a customized version of the your-project-name_prepare_config_files.py script in the templates/ folder, then you may simply load it to the project and speed up your process. make prepare project = discovery make load project = discovery cd projects/discovery make parameters make run-seq-local This is specially a useful approach if you are planning to iterate over your design. In this case, you can run your simulation, process your results, then modify the your-project-name_prepare_config_files.py file, and head back to your project to repeat the process with new set of parameters and simulation specification.","title":"Using the Project Frodo"},{"location":"frodo/frodo/#cleaning-up-your-project","text":"You should be aware that after each run, most of the folders are filled with your project files, e.g., configs/ , outputs/ , logs/ . If you plan to re-run your project, it is recommended to clean up the project before running Frodo/SAM again. This guarantees that your output files are corresponding to your configuration files, and no file from the previous run is lurking around in your project folder. make clean command removes all your project specific files but leaves the outputs/ files intact. make veryclean command removes all your project files, including your outputs/ files.","title":"Cleaning Up Your Project"},{"location":"frodo/frodo/#running-the-simulations-in-parallel","text":"As you may have noticed, Frodo offers several run commands. The second part of the command indicates whether the simulations will be run sequentially; or they can run in parallel (e.g., 8 simulation at a time). run-seq-local , runs run-par-local run-par-lisa In addition, if you are using the SURFsara Lisa cluster, you may use the last command to fully take advantage of the cluster system and distribute your simulation across the Lisa cluster. This command automatically creates a temporary folder on Lisa, request several nodes, distribute and run SAM across the cluster and finally collects all the output data and stores them into the outputs/ folder.","title":"Running the Simulations in Parallel"},{"location":"frodo/frodo/#post-processing","text":"After running your simulation, Frodo stores all of the output files generated by SAM into the outputs/ folder. At this stage, you may start extracting the output files and analyze your simulation data. While you can simply copy the files and process them using R, or any other programming language. The Project Frodo offers a few utilities to make your life a bit easier. csv stack stacker database summary The csv command is maybe one of the most useful commands in Frodo. It essentially combines your configuration file with your outputs. This is very useful for when you are working with a large grid of parameters. For instance, if you are running a re-running your simulation setup for 10 different values of true effect size, \u03bc, you will at least have 10 output files. While SAM names your output files similar to your config files, you simulation parameters are not listed in the output files. The csv command basically merge each configuration file with its appropriate output file. This is is very handy especially when you want to group your output files in R.","title":"Post Processing"},{"location":"frodo/sample-frodo-project/","text":"title: \"Sample Frodo Project\" \u00b6","title":"Sample frodo project"},{"location":"frodo/sample-frodo-project/#title-sample-frodo-project","text":"","title":"title: \"Sample Frodo Project\""},{"location":"hacking-strategies/fabricating-data/","text":"Fabricating Data \u00b6 Fabricating data is the process of producing imaginary data to support a certain hypothesis [cite, cite]. In this case, the Researcher comes up with datapoint and inject them into actual measurements in order to achieve or legitimize a certain conclusion. Data fabrication is neither defensible nor prevalent [cite, cite]; however unfortunately it can be deployed by researchers. Here we focus on two main known/speculated approaches: data generation , data duplication . Data Generation is the process of generating completely new datapoint with the goal of steering test statistics or any other metrics toward a satisfactory conclusion. Data Duplication is the process of duplicating certain datapoint in a selected group, in order to weight the group in certain direction. Like many other hacking strategies, a range of options can be used to customize the behavior of the Researcher during this hacking strategy.","title":"Fabricating Data"},{"location":"hacking-strategies/fabricating-data/#fabricating-data","text":"Fabricating data is the process of producing imaginary data to support a certain hypothesis [cite, cite]. In this case, the Researcher comes up with datapoint and inject them into actual measurements in order to achieve or legitimize a certain conclusion. Data fabrication is neither defensible nor prevalent [cite, cite]; however unfortunately it can be deployed by researchers. Here we focus on two main known/speculated approaches: data generation , data duplication . Data Generation is the process of generating completely new datapoint with the goal of steering test statistics or any other metrics toward a satisfactory conclusion. Data Duplication is the process of duplicating certain datapoint in a selected group, in order to weight the group in certain direction. Like many other hacking strategies, a range of options can be used to customize the behavior of the Researcher during this hacking strategy.","title":"Fabricating Data"},{"location":"hacking-strategies/falsifying-data/","text":"Falsifying Data \u00b6 Falsifying data is the act of deliberately modifying, adding, or removing measurements in order to steer the primary outcome of research toward a certain satisfactory conclusion. While this process can take many different forms, as mentioned, the main incentive is to contaminate the dataset in order to legitimize a certain conclusion or decision. [cite, cite, cite] Here we offer a customizable algorithm to achieve a few variations of data falsification. We focused on three primary form of data falsification: perturbation, swapping, and switching data. In permutation approach , the Researcher selects a set of value from a specific group, and adds a certain level of noise to each. In swapping approach , the Researcher selects a set of treatment groups, or dependent variables, and swap certain number of datapoint between them. In switching approach , the Researcher selects a certain number of datapoint and move them to an another group. Every approach can be customized even further to achieve a certain behavior.","title":"Falsifying Data"},{"location":"hacking-strategies/falsifying-data/#falsifying-data","text":"Falsifying data is the act of deliberately modifying, adding, or removing measurements in order to steer the primary outcome of research toward a certain satisfactory conclusion. While this process can take many different forms, as mentioned, the main incentive is to contaminate the dataset in order to legitimize a certain conclusion or decision. [cite, cite, cite] Here we offer a customizable algorithm to achieve a few variations of data falsification. We focused on three primary form of data falsification: perturbation, swapping, and switching data. In permutation approach , the Researcher selects a set of value from a specific group, and adds a certain level of noise to each. In swapping approach , the Researcher selects a set of treatment groups, or dependent variables, and swap certain number of datapoint between them. In switching approach , the Researcher selects a certain number of datapoint and move them to an another group. Every approach can be customized even further to achieve a certain behavior.","title":"Falsifying Data"},{"location":"hacking-strategies/group-pooling/","text":"Group Pooling \u00b6 Group pooling is the act of pooling data from two or more groups into one new group and compare the newly formed treatment group with the control group. Group pooling can be applied by adding the following JSON object to the list of hacking methods. { \"name\" : \"Group Pooling\" , \"num\" : 2 } Group pooling algorithm can pool different number of groups, num , together in order to form a new group. In its current setup, the Researcher traverses through every permutation of length num and create a new group. When, s/he collected all the combinations, s/he will then ask the DecisionStrategy for its verdict and consequently checks the significance of every new group. Parameters Type Details num int Indicates the number of groups to be pooled together","title":"Group pooling"},{"location":"hacking-strategies/group-pooling/#group-pooling","text":"Group pooling is the act of pooling data from two or more groups into one new group and compare the newly formed treatment group with the control group. Group pooling can be applied by adding the following JSON object to the list of hacking methods. { \"name\" : \"Group Pooling\" , \"num\" : 2 } Group pooling algorithm can pool different number of groups, num , together in order to form a new group. In its current setup, the Researcher traverses through every permutation of length num and create a new group. When, s/he collected all the combinations, s/he will then ask the DecisionStrategy for its verdict and consequently checks the significance of every new group. Parameters Type Details num int Indicates the number of groups to be pooled together","title":"Group Pooling"},{"location":"hacking-strategies/optional-stopping/","text":"Optional Stopping \u00b6 Optional stopping \u2014 in its most prominent form \u2014 is the practice of adding new observations to an Experiment after the initial data collection is concluded. Often the main incentive behind applying this method is to push one of the dependent variable to significant. Like selective reporting , optional stopping sits high up in the list of defensible and prevalent questionable research practices [cite, cite]. maybe I can add more \u201cfact\u201d about each method Optional Stopping Algorithm Optional stopping can be performed in various ways. SAM\u2019s implementation tries to provide a wide range of customizations in order to be able to cover different forms of optional stopping. Figure 1 shows the main body of the optional stopping algorithm as implemented in SAM. Like most hacking strategies, the optional stopping algorithm is implemented based on the fact that often a researcher perform multiple attempts to achieve significance, n_attempts . At each attempt, researcher reaches to data strategy and request num new observations for each group. Data strategy returns exactly num new observations from the same distribution that been used to initialize the Experiment. For instance, if we have configured a graded response model as our population, each newly generated observation will be calculated exactly based on the given model, e.g., Rasch Model. After adding new observations, all statistics, tests, and effects will be recalled and the Researcher continue to evaluate the stopping_condition , if there is any. If stopping condition is satisfied, the Researcher quits the algorithm, and moves to the defined selection \u2192 decision sequence. The configuration below showcases a sample implementation of optional stopping as it has been used in Maassen simulation. Optional Stopping { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"ratio\" : 0.3 } Besides common parameters shared between all hacking strategies, optional stopping specific parameters are as follow: num , indicates number of observations be added on each attempt. ratio , indicates a multiplier that its going to be used to calculate the number of new observations \u2014 based on current N \u2014 to be added to each group. n_attempts , indicates number of attempts fore stopping the process.","title":"Optional Stopping"},{"location":"hacking-strategies/optional-stopping/#optional-stopping","text":"Optional stopping \u2014 in its most prominent form \u2014 is the practice of adding new observations to an Experiment after the initial data collection is concluded. Often the main incentive behind applying this method is to push one of the dependent variable to significant. Like selective reporting , optional stopping sits high up in the list of defensible and prevalent questionable research practices [cite, cite]. maybe I can add more \u201cfact\u201d about each method Optional Stopping Algorithm Optional stopping can be performed in various ways. SAM\u2019s implementation tries to provide a wide range of customizations in order to be able to cover different forms of optional stopping. Figure 1 shows the main body of the optional stopping algorithm as implemented in SAM. Like most hacking strategies, the optional stopping algorithm is implemented based on the fact that often a researcher perform multiple attempts to achieve significance, n_attempts . At each attempt, researcher reaches to data strategy and request num new observations for each group. Data strategy returns exactly num new observations from the same distribution that been used to initialize the Experiment. For instance, if we have configured a graded response model as our population, each newly generated observation will be calculated exactly based on the given model, e.g., Rasch Model. After adding new observations, all statistics, tests, and effects will be recalled and the Researcher continue to evaluate the stopping_condition , if there is any. If stopping condition is satisfied, the Researcher quits the algorithm, and moves to the defined selection \u2192 decision sequence. The configuration below showcases a sample implementation of optional stopping as it has been used in Maassen simulation. Optional Stopping { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 1 , \"num\" : 0 , \"ratio\" : 0.3 } Besides common parameters shared between all hacking strategies, optional stopping specific parameters are as follow: num , indicates number of observations be added on each attempt. ratio , indicates a multiplier that its going to be used to calculate the number of new observations \u2014 based on current N \u2014 to be added to each group. n_attempts , indicates number of attempts fore stopping the process.","title":"Optional Stopping"},{"location":"hacking-strategies/outliers-removal/","text":"Outliers Removal \u00b6 Removing outliers is an important degree of freedom in the list degrees of freedom available to a researcher. While usage of outliers removal methods are not fully condemned [cite] and they are not strictly listed as questionable researcher practices [cite], they should not be applied blindly. Remisful application of these methods could disturb the observed effect size, and influence the significant level. Unfortunately, most researchers are not aware of consequences of these methods, and as shown by [cite, cite], outliers removal methods are being applied recklessly without taking their influences into the consideration and only to achieve significance level, or removing \u201cunwanted\u201d observations [cite]. As mentioned, there is a range of methods and approaches available to remove outliers from an Experiment, each having their own strength and weakness [cite, cite, cite]. In its simplest form, outliers removal is done by calculating the relative distances of observations from the sample mean, d_i = \\frac{x_i - \\bar{x}}{\\sigma^2} d_i = \\frac{x_i - \\bar{x}}{\\sigma^2} , and deciding whether to call an observation an outlier based on a pre-selected threshold, k . In this case, items further than k are considered outliers. Figure 1. Outliers Removal Algorithm Figure 1 shows the implementation of aforementioned method. Like [optional stopping], outliers removal algorithm is designed based on the idea that Researchers might give the procedure several attempts before stop trying, n_attempts . Beside the number of attempts, we are able to provide a range of multipliers, k \u2019s to be considered. At each iteration, we start by a k , and remove num observations from targeted groups. This routine will run n_attemtps times or at any time where stopping_condition is satisfied. The configuration below showcases a sample implementation of outliers removal: Outlier Removal { \"name\" : \"Outlier Removal\" , \"num\" : 2 , \"n_attempts\" : 3 , \"min_observations\" : 20 , \"multipliers\" : [ 3 , 2 , 1 ] } Besides hacking strategies shared parameters, outliers removal has its own customization parameters as follow: num , n , int , indicates number of items to be moved at each attempt n_attempts , indicates number of attempts to move outliers for ch multiplier min_observations , indicates the minimum number of servations. Outliers removal stops removing observations when a group reaches the given minimum. multipliers , indicates a list of multipliers to be used order , indicates the order in which observations will be removed from the Experiment \u201drandom\u201d , removing items randomly \u201dasc\u201d , removing furthest items from \\bar{x} \\bar{x} first \u201ddesc\u201d , removing closest items to \\bar{x} \\bar{x} first","title":"Outliers Removal"},{"location":"hacking-strategies/outliers-removal/#outliers-removal","text":"Removing outliers is an important degree of freedom in the list degrees of freedom available to a researcher. While usage of outliers removal methods are not fully condemned [cite] and they are not strictly listed as questionable researcher practices [cite], they should not be applied blindly. Remisful application of these methods could disturb the observed effect size, and influence the significant level. Unfortunately, most researchers are not aware of consequences of these methods, and as shown by [cite, cite], outliers removal methods are being applied recklessly without taking their influences into the consideration and only to achieve significance level, or removing \u201cunwanted\u201d observations [cite]. As mentioned, there is a range of methods and approaches available to remove outliers from an Experiment, each having their own strength and weakness [cite, cite, cite]. In its simplest form, outliers removal is done by calculating the relative distances of observations from the sample mean, d_i = \\frac{x_i - \\bar{x}}{\\sigma^2} d_i = \\frac{x_i - \\bar{x}}{\\sigma^2} , and deciding whether to call an observation an outlier based on a pre-selected threshold, k . In this case, items further than k are considered outliers. Figure 1. Outliers Removal Algorithm Figure 1 shows the implementation of aforementioned method. Like [optional stopping], outliers removal algorithm is designed based on the idea that Researchers might give the procedure several attempts before stop trying, n_attempts . Beside the number of attempts, we are able to provide a range of multipliers, k \u2019s to be considered. At each iteration, we start by a k , and remove num observations from targeted groups. This routine will run n_attemtps times or at any time where stopping_condition is satisfied. The configuration below showcases a sample implementation of outliers removal: Outlier Removal { \"name\" : \"Outlier Removal\" , \"num\" : 2 , \"n_attempts\" : 3 , \"min_observations\" : 20 , \"multipliers\" : [ 3 , 2 , 1 ] } Besides hacking strategies shared parameters, outliers removal has its own customization parameters as follow: num , n , int , indicates number of items to be moved at each attempt n_attempts , indicates number of attempts to move outliers for ch multiplier min_observations , indicates the minimum number of servations. Outliers removal stops removing observations when a group reaches the given minimum. multipliers , indicates a list of multipliers to be used order , indicates the order in which observations will be removed from the Experiment \u201drandom\u201d , removing items randomly \u201dasc\u201d , removing furthest items from \\bar{x} \\bar{x} first \u201ddesc\u201d , removing closest items to \\bar{x} \\bar{x} first","title":"Outliers Removal"},{"location":"hacking-strategies/selective-reporting/","text":"Selective Reporting \u00b6 Selective reporting is among the most prevalent questionable research practices [cite, cite]. It also sits high in the list of defensible QRPs among researchers [cite]. Despite its popularity and prevalent, it has been shown and argued that it has a devastating effect on our research. It gives the researcher a path to select any dependent variables from any treatment group, and present it as the primary outcome. This often allows the researcher to experiment with outcome variables and choose the satisfactory \u2014 e.g., significant \u2014 outcome variable. As selective reporting often mainly induced in research in the form of a decision, SAM models this specific hacking strategy using the decision strategy. While the description of decision strategy and research workflow should already be sufficient enough for the reader on how this method is being deployed in SAM, we use this section to elaborate on the implementation and implication of selective reporting. Selective Reporting as a Hacking Strategy \u00b6 Unlike other hacking strategies, selective reporting is not being included in the list of hacking_strategies in the configuration file. Instead, we utilize different selection \u2192 decision sequences to simulate selective reporting. While most simulation studies apply the selective reporting in the beginning or at the end of the study, SAM is able to induce the selective reporting during any of the decision stages . In fact, any of _selection_policies listed in Figure 1 can be used to divert researchers selection from the pre-registered or primary outcome of the study. The simplest and most prominent way of alternating researchers selection is by configuring initial_selection_policies . Here we can lead the researcher to select an outcome with minimum p -value: \u201cinitial_selection_policies\u201d: [[\u201cmin(pvalue)\u201d]] Or, maybe we want to design a researcher who first checks the significance of the pre-registered outcome, and in the case of not being significant then selects an outcome with minimum p -value: \u201cinitial_selection_policies\u201d: [[\u201cpre-reg\u201d, \u201csig\u201d], [\u201cmin(pvalue)\u201d]] As discussed, initial_selection_policies is a policy chain set , which means its policies will be executed in the given order, and researcher stops after a successful execution of a policy chain, ie., a query with an unique outcome. Selective Reporting Reach \u00b6 Implementation of selective reporting through decision strategies opens a lot of opportunities for the researcher to selectively report different outcomes than those he/she pre-registered. Looking back at the list of possible selections, we will have \u2192 initial_selection_policies will_start_hacking_decision_policies stashing_policy \u2192 h_s_selection h_s_decision ... \u2192 between_hacks_selection_policies \u2192 between_replications_selection_policies will_continue_replicating_decision_policy \u2192 submission_decision_policies Basically, Researcher can adjust his selection during the study. Keeping in mind that each selection policy is a policy chain set means that Researcher can chain all his previous selection together and deploy a highly questionable selection scheme, and even adjust it through his/her research. For instance, Researcher\u2019s selections could always start with checking the pre-registered outcome first, and only moves to other options when that one is not satisfactory. { \"initial_selection_policies\" : [ [ \"pre-reg\" , \"sig\" ], [ \"min(pvalue)\" ] ], \"between_hacks_selection_policies\" : [ [ \"pre-reg\" , \"sig\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ], ], \"between_replications_selection_policies\" : [ [ \"pre-reg\" , \"sig\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"sig\" , \"min(pvalue)\" ]] } Notice Researcher\u2019s persistent on checking the pre-reg outcome in all different selection stages, and only accepting it when it is significant. This likely leads to an exceptionally hard to detect selective reporting. Moreover, as previously discussed, each hacking strategy get to have their own set of selection policies. This means we can specifically tune a hacking strategy to achieve a certain goal; therefore, incorporating selective reporting into each hacking strategy and the entire hacking workflow .","title":"Selective Reporting"},{"location":"hacking-strategies/selective-reporting/#selective-reporting","text":"Selective reporting is among the most prevalent questionable research practices [cite, cite]. It also sits high in the list of defensible QRPs among researchers [cite]. Despite its popularity and prevalent, it has been shown and argued that it has a devastating effect on our research. It gives the researcher a path to select any dependent variables from any treatment group, and present it as the primary outcome. This often allows the researcher to experiment with outcome variables and choose the satisfactory \u2014 e.g., significant \u2014 outcome variable. As selective reporting often mainly induced in research in the form of a decision, SAM models this specific hacking strategy using the decision strategy. While the description of decision strategy and research workflow should already be sufficient enough for the reader on how this method is being deployed in SAM, we use this section to elaborate on the implementation and implication of selective reporting.","title":"Selective Reporting"},{"location":"hacking-strategies/selective-reporting/#selective-reporting-as-a-hacking-strategy","text":"Unlike other hacking strategies, selective reporting is not being included in the list of hacking_strategies in the configuration file. Instead, we utilize different selection \u2192 decision sequences to simulate selective reporting. While most simulation studies apply the selective reporting in the beginning or at the end of the study, SAM is able to induce the selective reporting during any of the decision stages . In fact, any of _selection_policies listed in Figure 1 can be used to divert researchers selection from the pre-registered or primary outcome of the study. The simplest and most prominent way of alternating researchers selection is by configuring initial_selection_policies . Here we can lead the researcher to select an outcome with minimum p -value: \u201cinitial_selection_policies\u201d: [[\u201cmin(pvalue)\u201d]] Or, maybe we want to design a researcher who first checks the significance of the pre-registered outcome, and in the case of not being significant then selects an outcome with minimum p -value: \u201cinitial_selection_policies\u201d: [[\u201cpre-reg\u201d, \u201csig\u201d], [\u201cmin(pvalue)\u201d]] As discussed, initial_selection_policies is a policy chain set , which means its policies will be executed in the given order, and researcher stops after a successful execution of a policy chain, ie., a query with an unique outcome.","title":"Selective Reporting as a Hacking Strategy"},{"location":"hacking-strategies/selective-reporting/#selective-reporting-reach","text":"Implementation of selective reporting through decision strategies opens a lot of opportunities for the researcher to selectively report different outcomes than those he/she pre-registered. Looking back at the list of possible selections, we will have \u2192 initial_selection_policies will_start_hacking_decision_policies stashing_policy \u2192 h_s_selection h_s_decision ... \u2192 between_hacks_selection_policies \u2192 between_replications_selection_policies will_continue_replicating_decision_policy \u2192 submission_decision_policies Basically, Researcher can adjust his selection during the study. Keeping in mind that each selection policy is a policy chain set means that Researcher can chain all his previous selection together and deploy a highly questionable selection scheme, and even adjust it through his/her research. For instance, Researcher\u2019s selections could always start with checking the pre-registered outcome first, and only moves to other options when that one is not satisfactory. { \"initial_selection_policies\" : [ [ \"pre-reg\" , \"sig\" ], [ \"min(pvalue)\" ] ], \"between_hacks_selection_policies\" : [ [ \"pre-reg\" , \"sig\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ], ], \"between_replications_selection_policies\" : [ [ \"pre-reg\" , \"sig\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"sig\" , \"min(pvalue)\" ]] } Notice Researcher\u2019s persistent on checking the pre-reg outcome in all different selection stages, and only accepting it when it is significant. This likely leads to an exceptionally hard to detect selective reporting. Moreover, as previously discussed, each hacking strategy get to have their own set of selection policies. This means we can specifically tune a hacking strategy to achieve a certain goal; therefore, incorporating selective reporting into each hacking strategy and the entire hacking workflow .","title":"Selective Reporting Reach"},{"location":"hacking-strategies/subjective-outliers-removal/","text":"Subjective Outliers Removal \u00b6 Subjective outliers removal is defined by Bakker et al., 2014 1 as a special and even more questionable case of outliers removal where the researcher lowers k (the threshold of considering an item to be an outlier) dynamically during the data analysis. While we are able to mimic this behavior by tweaking the parameters of outliers removal , SAM has a built-in hacking strategy for this specific method. !!! hackingstrategy \u201cSubjective Outliers Removal\u201d { \"name\" : \"SubjectiveOutlierRemoval\" , \"min_observations\" : 5 , \"range\" : [ 2 , 3 ], \"step_size\" : 0.5 , \"stopping_condition\" : [ \"sig\" ] } The main difference between this algorithm, and general outliers removal is that fact that SAM generates an array of equally distant k \u2019s between the given range using the given step_size . For instance, in the above example, a range of k \u2019s will be {3, 2.5, 2}. Notice that the algorithm starts from highest to the lowest k . Marjan Bakker and Jelte M. Wicherts. Outlier removal, sum scores, and the inflation of the type i error rate in independent samples t tests: the power of alternatives and recommendations. Psychological Methods , 19 3 3 :409\u2013427, 2014. URL: https://doi.org/10.1037%2Fmet0000014 , doi:10.1037/met0000014 . \u21a9","title":"Subjective Outliers Removal"},{"location":"hacking-strategies/subjective-outliers-removal/#subjective-outliers-removal","text":"Subjective outliers removal is defined by Bakker et al., 2014 1 as a special and even more questionable case of outliers removal where the researcher lowers k (the threshold of considering an item to be an outlier) dynamically during the data analysis. While we are able to mimic this behavior by tweaking the parameters of outliers removal , SAM has a built-in hacking strategy for this specific method. !!! hackingstrategy \u201cSubjective Outliers Removal\u201d { \"name\" : \"SubjectiveOutlierRemoval\" , \"min_observations\" : 5 , \"range\" : [ 2 , 3 ], \"step_size\" : 0.5 , \"stopping_condition\" : [ \"sig\" ] } The main difference between this algorithm, and general outliers removal is that fact that SAM generates an array of equally distant k \u2019s between the given range using the given step_size . For instance, in the above example, a range of k \u2019s will be {3, 2.5, 2}. Notice that the algorithm starts from highest to the lowest k . Marjan Bakker and Jelte M. Wicherts. Outlier removal, sum scores, and the inflation of the type i error rate in independent samples t tests: the power of alternatives and recommendations. Psychological Methods , 19 3 3 :409\u2013427, 2014. URL: https://doi.org/10.1037%2Fmet0000014 , doi:10.1037/met0000014 . \u21a9","title":"Subjective Outliers Removal"},{"location":"studies/optional-stopping-variation/","text":"Optional Stopping Variation \u00b6 After investigating the influecens of initial selection logic, and sample size, here, we will investigate the effect of applying several variants of Optional Stopping on the probability of finding significant results and the level of effect size bias. Similarly to our Sample Size Variation and Selection Variation studies, we will cover a range of parameters in order to draw a landscape of our both target metrics, e.g., Probability of Finding Significant (PFS), and Effect Size Bias, (ESB). Study Design \u00b6 Based on results of our sample size study, we will adjust our sample size parameters, from simulating the entire range of [8, 100] to a discrete set of values. We think our approximation can still provide an overview of the interaction as we observed a predictable change of PFS and ES Bias along a fine-grind range of N . For the rest of Experiment\u2019s parameters, we use the same set of parameters in order to draw a complete and comparable picture as before. \u03bc \u2208 [0, 1] m \u2208 {2, 4, 6} N \u2208 {10, 20, 30, 40, 50, 60, 70, 80} P b \u2208 {0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95} In order to cover a range of optional stopping approaches, we start by simulating a more conventional optional stopping and narrow down our search parameters. Optional Stopping on Both Groups \u00b6 In our first study, we simulate the optional stopping by adding new observations as much as of S percent of the current sample size to every group. For example, a group with N = 20 will have 22 observations after adding 10% new observations, S = 10% . Additionally, we vary the maxiumum number of trials that the Researcher could perform the optional stopping with the given S . For instance, a Researcher \u2014 who is allowed to perform a maximum of 5 optional stopping trials \u2014 will continue adding 2 new obervations, for maximum number of 5 times, to each group until it finds a significant result. The variation of described parameters is as follow: S \u2208 {0.1, 0.2, 0.3, 0.4, 0.5} T \u2208 {1, 3, 5} With these paramters, we hope that we could cover a wide range of possible optional stopping variations, and hopefully find valuable insight into the landsacpe of PFS, and ES Bias. Configuration: Hacking Strategy { ... \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 3 , \"ratio\" : 0.4 , \"stopping_condition\" : [ \"sig\" ] }, [ [ \"sig\" , \"effect > 0\" , \"random\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], [ \"id < 0\" ] ] ], ... } Results \u00b6 For our first results, we present the probablity of finding significant in the following set of figures. We present three main set of figures, each showcasing results from studies with different number of dependent variables, ie., 2, 4, 6. Additionally, we filtered our results for T = 1 . Appendix A will discuss the effect of number of attempts. In both cases, as we increase S , while we see some growth (and a shift toward left) in the yellow region of the contour plot, (region with highest probablity of finding significant) we do not believe that this growth or even the overall change of the landscape is noticeably different from our benchmark column \u2014 first column with no optional stopping. 2 Dependent Variables 0.05 2 Dependent Variables 0.005 2 Dependent Variables 0.0005 2 Dependent Variables 4 Dependent Variables 0.05 4 Dependent Variables 0.005 4 Dependent Variables 0.0005 4 Dependent Variables 6 Dependent Variables 0.05 6 Dependent Variables 0.005 6 Dependent Variables 0.0005 6 Dependent Variables In the case of effect size bias, as we showed in the sample size variation study, we see that the level of bias is higher as we add more dependent variables to our studies. Additionally, while optional stopping does not increase the overall level of bias, it shifts it toward higher sample sizes. This is expected, as a Moreover, we observe that the level of bias lowers as we increase S ; however, the region that bias appears in the contour plot doesn\u2019t move and only shrinks. We can also see that the bias region moves higher in the y-axes (ie., true effect size) as we increase the \u03b1 level. Finally, we can see the influence of publication bias on the effect size bias. Expectedly, increasing the publication bias will reduce our overall effect size bias while it still includes highly biased studies within the region of small true effect sizes. 2 Dependent Variables 0.05 2 Dependent Variables 0.005 2 Dependent Variables 0.0005 2 Dependent Variables 4 Dependent Variables 0.05 4 Dependent Variables 0.005 4 Dependent Variables 0.0005 4 Dependent Variables 6 Dependent Variables 0.05 6 Dependent Variables 0.005 6 Dependent Variables 0.0005 6 Dependent Variables First Extension: Optional Stopping Only on Treatment Group \u00b6 In our first extension, we investigate the effect of only applying the optional stopping on treatment groups, meaning that the Researcher will only add new observations to the treatment group and leave the control group intact. In the figure below, we can see the comparison between this study and the one performed previously, ie., adding new observation to both groups. In contrast to our expectation, adding new observation only to treatment groups does not have a considerable impact on the level of bias. This can be seen in the figure by tracking the slightly wider bias region in \u201cTreatment\u201d columns compared to their \u201cBoth\u201d counterparts. 2 Dependent Variables 0.05 0.005 0.0005 Second Extension: Optional Stopping Field \u00b6 In our second extension of our study, we investigate the effect of variable optional stopping parameters . In contrast to our previous simulations where we simulated a range of parameters, in this simulation we draw a random value for two main parameters of the optional stopping, ratio and n_attempts . Our choices for distribution of ratio and n_attempts is based on fine-tuned *truncated normal distribution*s as shown here. These distribution are mimicing a scenario in which Researches prefer to addi/collect fewer new observations, besides they ought to repeat this process as seldemly as possible. Hackingstrategy { ... \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"ratio\" : { \"dist\" : \"truncated_normal_distribution\" , \"mean\" : 0.1 , \"stddev\" : 0.125 , \"lower\" : 0.1 , \"upper\" : 0.5 , }, \"n_attempts\" : { \"dist\" : \"truncated_normal_distribution\" , \"mean\" : 1 , \"stddev\" : 1.25 , \"lower\" : 1 , \"upper\" : 5 }, \"stopping_condition\" : [ \"sig\" ] }, [ [ \"sig\" , \"effect > 0\" , \"random\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], [ \"id < 0\" ] ] ], ... } As before, it is difficult to observe any meaningful changes in the landscape of PFS; however, we are able to spot more minor changes. \u0251 = 0.05 0.005 0.0005 While the changes to the landscape of PFS is almost invisible, we are surely able to observe some changes in the level of bias. As before, althought these changes are not drastic, they tend to confirm that optional stopping tends to reduce the level of bias. However, this is only more prevalent in lower effect sizes within lower sample sizes, lower left region of figures . In contrast, within the range of higher effect sizes, optional stopping tend to increase the bias ever so slightly. It is important to point out that while we see minimal improvment on the level of bias in studies with optional stopping, this does not mean that those studies are now better. In contrast, our results indicates the detrimental effect of optional stopping on published studies. If a study is already biased, optional stopping does not reduce the bias enough that makes it a good study; in fact, it burries its bias under higher sample size, and gives Journals a wrong incentive to publish the study. \u0251 = 0.05 0.005 0.0005 Publication Bias and Meta-Analysis \u00b6 Another difference of our last extension is the fact that we changed our Journal\u2019s configuration in order to be able to collect batches of results. Here we competed two batch sizes, K = {8, 24} . Configuration: Journal { ... \"journal_parameters\" : { \"max_pubs\" : k , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : p , \"alpha\" : \u0251 , \"side\" : 0 , }, \"meta_analysis_metrics\" : [ { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 }, { \"name\" : \"RankCorrelation\" , \"alpha\" : 0.1 } ] } ... } As discussed in Meta Analysis , we can use these batches as our meta analysis pool, and consequently apply different meta analyses methods on them. Later these results can be exported and analyzed as shown in Maassen\u2019s Simulation . Publication Bias \u00b6 While we do not expect Egger's Test to be able to detect the influence of optional stopping on publication bias, we are curious to see how it performs within the range of our parameters. As we can see in the figure below, Egger's test clearly performs better with larger sample sizes. Moreover, as expected, Egger gets more confident as publication level raises. As shown in Maassen\u2019s Simulation , Egger performs much better in lower \u0251-levels as well. In addtion, notice the fact that Egger's Test is only capable of detecting high ( > 50% ) publication bias within very extreme P b values, and even then only within very high true effect sizes and low sample sizes. In fact, Egger's Test is fairly ineffective in a large region of our parameters set. The good news is, its most effective region lies within small sample sizes, N \u2272 20 . In all cases, we can see a slightly more power withing studies undergone the optional stopping. However, as one would guess this is not to the courtesy of Egger's Test in detecting the influence of optional stopping. In fact, this is shows how optional stopping can pollute publication bias metrics like Egger's Test. K = 8 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables K = 24 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables We also included Begg's Rank Correlation Test in our meta analysis. Figures below showcase the variation of its power. As we know Begg's test does not perform well with small samples sizes, and it performs the best with at least K \u2273 72 [cite], see Maassen et al., 2016 . Here, we can observe the same behavior, as we see much brigher contour batches with K = 24 . In comparison to Egger's test, Begg's test has a lower power, and does not necessary come out more successful. Similarly, Begg's test is more powerful withing the region of N \u2272 20 , and higher true effect sizes, \u03b8 . K = 8 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables K = 24 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables Third Extension \u00b6 In our last extension, we remove an another dimension by replacing a set of sample sizes with values drawn from a custom designed destribution. As shown here, we aim for a distirbution with higher chance of returning smaller N 's and lower chance of returning higher values. We tuned our distirbution such that 75% of our sample sizes lie within [6, 24], and the rest are drawn from [25, 300]. We can achieve this by tuning a piecewise_constant_distribution as follow within our Data Strategy configuration. Configuration: Data Strategy { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"n_obs\" : { \"dist\" : \"piecewise_constant_distribution\" , \"intervals\" : [ 6 , 24 , 300 ], \"densities\" : [ 0.75 , 0.25 ] }, \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , \u03bc , \u03bc ], \"covs\" : 0.5 , \"stddevs\" : 1.0 } }, \"effect_strategy\" : { \"name\" : \"StandardizedMeanDifference\" }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } As before, we investigate the probability of finding significant results. The figure below shows the overall level of PFS in different scenarios. As before, we can see that optional stopping does not greatly streches the chance of finding significant results. As this is consistent with our previous observations, we may speculate that optional stopping might not necessarily helps one in its journey of finding significant results. Similarly, we see a minimal variation in the level of bias! Publication Bias \u00b6 Looking into our publication bias measures, we see similar trends as before in many different parameters pools. Egger's test perform well within higher true effect sizes, and loses its edge in lower effect sizes. Moreover, we again see a minimal influece of optional stopping on its power. One interesting difference in Egger's test performance is high positive rate within journals with low publication bias. Notice three top-right figures where we simulated a journal with no publication bias; but, Egger's test is very confident taht we are dealing with very high publication bias. The same true is for Begg's test, ie., very lower power with K = 8 , with power improving as we increase K to 24. In contrast to Egger's, Begg's test seems to be more conservative with announcing publication bias when no publication bias is present. Conclusion \u00b6 Appendix A: Effect of Different Number of Attemps in Optional Stopping \u00b6 Effect Size Bias \u00b6 2 Dependent Variables 0.05 0.005 0.0005 4 Dependent Variables 0.05 0.005 0.0005 First Extension: Effect Size Bias \u00b6 2 Dependent Variables 0.05 0.005 0.0005 4 Dependent Variables 0.05 0.005 0.0005","title":"Optional Stopping Variation"},{"location":"studies/optional-stopping-variation/#optional-stopping-variation","text":"After investigating the influecens of initial selection logic, and sample size, here, we will investigate the effect of applying several variants of Optional Stopping on the probability of finding significant results and the level of effect size bias. Similarly to our Sample Size Variation and Selection Variation studies, we will cover a range of parameters in order to draw a landscape of our both target metrics, e.g., Probability of Finding Significant (PFS), and Effect Size Bias, (ESB).","title":"Optional Stopping Variation"},{"location":"studies/optional-stopping-variation/#study-design","text":"Based on results of our sample size study, we will adjust our sample size parameters, from simulating the entire range of [8, 100] to a discrete set of values. We think our approximation can still provide an overview of the interaction as we observed a predictable change of PFS and ES Bias along a fine-grind range of N . For the rest of Experiment\u2019s parameters, we use the same set of parameters in order to draw a complete and comparable picture as before. \u03bc \u2208 [0, 1] m \u2208 {2, 4, 6} N \u2208 {10, 20, 30, 40, 50, 60, 70, 80} P b \u2208 {0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95} In order to cover a range of optional stopping approaches, we start by simulating a more conventional optional stopping and narrow down our search parameters.","title":"Study Design"},{"location":"studies/optional-stopping-variation/#optional-stopping-on-both-groups","text":"In our first study, we simulate the optional stopping by adding new observations as much as of S percent of the current sample size to every group. For example, a group with N = 20 will have 22 observations after adding 10% new observations, S = 10% . Additionally, we vary the maxiumum number of trials that the Researcher could perform the optional stopping with the given S . For instance, a Researcher \u2014 who is allowed to perform a maximum of 5 optional stopping trials \u2014 will continue adding 2 new obervations, for maximum number of 5 times, to each group until it finds a significant result. The variation of described parameters is as follow: S \u2208 {0.1, 0.2, 0.3, 0.4, 0.5} T \u2208 {1, 3, 5} With these paramters, we hope that we could cover a wide range of possible optional stopping variations, and hopefully find valuable insight into the landsacpe of PFS, and ES Bias. Configuration: Hacking Strategy { ... \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"n_attempts\" : 3 , \"ratio\" : 0.4 , \"stopping_condition\" : [ \"sig\" ] }, [ [ \"sig\" , \"effect > 0\" , \"random\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], [ \"id < 0\" ] ] ], ... }","title":"Optional Stopping on Both Groups"},{"location":"studies/optional-stopping-variation/#results","text":"For our first results, we present the probablity of finding significant in the following set of figures. We present three main set of figures, each showcasing results from studies with different number of dependent variables, ie., 2, 4, 6. Additionally, we filtered our results for T = 1 . Appendix A will discuss the effect of number of attempts. In both cases, as we increase S , while we see some growth (and a shift toward left) in the yellow region of the contour plot, (region with highest probablity of finding significant) we do not believe that this growth or even the overall change of the landscape is noticeably different from our benchmark column \u2014 first column with no optional stopping. 2 Dependent Variables 0.05 2 Dependent Variables 0.005 2 Dependent Variables 0.0005 2 Dependent Variables 4 Dependent Variables 0.05 4 Dependent Variables 0.005 4 Dependent Variables 0.0005 4 Dependent Variables 6 Dependent Variables 0.05 6 Dependent Variables 0.005 6 Dependent Variables 0.0005 6 Dependent Variables In the case of effect size bias, as we showed in the sample size variation study, we see that the level of bias is higher as we add more dependent variables to our studies. Additionally, while optional stopping does not increase the overall level of bias, it shifts it toward higher sample sizes. This is expected, as a Moreover, we observe that the level of bias lowers as we increase S ; however, the region that bias appears in the contour plot doesn\u2019t move and only shrinks. We can also see that the bias region moves higher in the y-axes (ie., true effect size) as we increase the \u03b1 level. Finally, we can see the influence of publication bias on the effect size bias. Expectedly, increasing the publication bias will reduce our overall effect size bias while it still includes highly biased studies within the region of small true effect sizes. 2 Dependent Variables 0.05 2 Dependent Variables 0.005 2 Dependent Variables 0.0005 2 Dependent Variables 4 Dependent Variables 0.05 4 Dependent Variables 0.005 4 Dependent Variables 0.0005 4 Dependent Variables 6 Dependent Variables 0.05 6 Dependent Variables 0.005 6 Dependent Variables 0.0005 6 Dependent Variables","title":"Results"},{"location":"studies/optional-stopping-variation/#first-extension-optional-stopping-only-on-treatment-group","text":"In our first extension, we investigate the effect of only applying the optional stopping on treatment groups, meaning that the Researcher will only add new observations to the treatment group and leave the control group intact. In the figure below, we can see the comparison between this study and the one performed previously, ie., adding new observation to both groups. In contrast to our expectation, adding new observation only to treatment groups does not have a considerable impact on the level of bias. This can be seen in the figure by tracking the slightly wider bias region in \u201cTreatment\u201d columns compared to their \u201cBoth\u201d counterparts. 2 Dependent Variables 0.05 0.005 0.0005","title":"First Extension: Optional Stopping Only on Treatment Group"},{"location":"studies/optional-stopping-variation/#second-extension-optional-stopping-field","text":"In our second extension of our study, we investigate the effect of variable optional stopping parameters . In contrast to our previous simulations where we simulated a range of parameters, in this simulation we draw a random value for two main parameters of the optional stopping, ratio and n_attempts . Our choices for distribution of ratio and n_attempts is based on fine-tuned *truncated normal distribution*s as shown here. These distribution are mimicing a scenario in which Researches prefer to addi/collect fewer new observations, besides they ought to repeat this process as seldemly as possible. Hackingstrategy { ... \"hacking_strategies\" : [ [ { \"name\" : \"OptionalStopping\" , \"target\" : \"Both\" , \"prevalence\" : 1 , \"defensibility\" : 1 , \"max_attempts\" : 1 , \"ratio\" : { \"dist\" : \"truncated_normal_distribution\" , \"mean\" : 0.1 , \"stddev\" : 0.125 , \"lower\" : 0.1 , \"upper\" : 0.5 , }, \"n_attempts\" : { \"dist\" : \"truncated_normal_distribution\" , \"mean\" : 1 , \"stddev\" : 1.25 , \"lower\" : 1 , \"upper\" : 5 }, \"stopping_condition\" : [ \"sig\" ] }, [ [ \"sig\" , \"effect > 0\" , \"random\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], [ \"id < 0\" ] ] ], ... } As before, it is difficult to observe any meaningful changes in the landscape of PFS; however, we are able to spot more minor changes. \u0251 = 0.05 0.005 0.0005 While the changes to the landscape of PFS is almost invisible, we are surely able to observe some changes in the level of bias. As before, althought these changes are not drastic, they tend to confirm that optional stopping tends to reduce the level of bias. However, this is only more prevalent in lower effect sizes within lower sample sizes, lower left region of figures . In contrast, within the range of higher effect sizes, optional stopping tend to increase the bias ever so slightly. It is important to point out that while we see minimal improvment on the level of bias in studies with optional stopping, this does not mean that those studies are now better. In contrast, our results indicates the detrimental effect of optional stopping on published studies. If a study is already biased, optional stopping does not reduce the bias enough that makes it a good study; in fact, it burries its bias under higher sample size, and gives Journals a wrong incentive to publish the study. \u0251 = 0.05 0.005 0.0005","title":"Second Extension: Optional Stopping Field"},{"location":"studies/optional-stopping-variation/#publication-bias-and-meta-analysis","text":"Another difference of our last extension is the fact that we changed our Journal\u2019s configuration in order to be able to collect batches of results. Here we competed two batch sizes, K = {8, 24} . Configuration: Journal { ... \"journal_parameters\" : { \"max_pubs\" : k , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : p , \"alpha\" : \u0251 , \"side\" : 0 , }, \"meta_analysis_metrics\" : [ { \"name\" : \"RandomEffectEstimator\" , \"estimator\" : \"DL\" }, { \"name\" : \"EggersTestEstimator\" , \"alpha\" : 0.1 }, { \"name\" : \"RankCorrelation\" , \"alpha\" : 0.1 } ] } ... } As discussed in Meta Analysis , we can use these batches as our meta analysis pool, and consequently apply different meta analyses methods on them. Later these results can be exported and analyzed as shown in Maassen\u2019s Simulation .","title":"Publication Bias and Meta-Analysis"},{"location":"studies/optional-stopping-variation/#publication-bias","text":"While we do not expect Egger's Test to be able to detect the influence of optional stopping on publication bias, we are curious to see how it performs within the range of our parameters. As we can see in the figure below, Egger's test clearly performs better with larger sample sizes. Moreover, as expected, Egger gets more confident as publication level raises. As shown in Maassen\u2019s Simulation , Egger performs much better in lower \u0251-levels as well. In addtion, notice the fact that Egger's Test is only capable of detecting high ( > 50% ) publication bias within very extreme P b values, and even then only within very high true effect sizes and low sample sizes. In fact, Egger's Test is fairly ineffective in a large region of our parameters set. The good news is, its most effective region lies within small sample sizes, N \u2272 20 . In all cases, we can see a slightly more power withing studies undergone the optional stopping. However, as one would guess this is not to the courtesy of Egger's Test in detecting the influence of optional stopping. In fact, this is shows how optional stopping can pollute publication bias metrics like Egger's Test. K = 8 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables K = 24 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables We also included Begg's Rank Correlation Test in our meta analysis. Figures below showcase the variation of its power. As we know Begg's test does not perform well with small samples sizes, and it performs the best with at least K \u2273 72 [cite], see Maassen et al., 2016 . Here, we can observe the same behavior, as we see much brigher contour batches with K = 24 . In comparison to Egger's test, Begg's test has a lower power, and does not necessary come out more successful. Similarly, Begg's test is more powerful withing the region of N \u2272 20 , and higher true effect sizes, \u03b8 . K = 8 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables K = 24 2 Dependent Variables 4 Dependent Variables 6 Dependent Variables","title":"Publication Bias"},{"location":"studies/optional-stopping-variation/#third-extension","text":"In our last extension, we remove an another dimension by replacing a set of sample sizes with values drawn from a custom designed destribution. As shown here, we aim for a distirbution with higher chance of returning smaller N 's and lower chance of returning higher values. We tuned our distirbution such that 75% of our sample sizes lie within [6, 24], and the rest are drawn from [25, 300]. We can achieve this by tuning a piecewise_constant_distribution as follow within our Data Strategy configuration. Configuration: Data Strategy { \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : 2 , \"n_obs\" : { \"dist\" : \"piecewise_constant_distribution\" , \"intervals\" : [ 6 , 24 , 300 ], \"densities\" : [ 0.75 , 0.25 ] }, \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , \u03bc , \u03bc ], \"covs\" : 0.5 , \"stddevs\" : 1.0 } }, \"effect_strategy\" : { \"name\" : \"StandardizedMeanDifference\" }, \"test_strategy\" : { \"name\" : \"TTest\" , \"alpha\" : 0.05 , \"alternative\" : \"TwoSided\" , \"var_equal\" : true } } As before, we investigate the probability of finding significant results. The figure below shows the overall level of PFS in different scenarios. As before, we can see that optional stopping does not greatly streches the chance of finding significant results. As this is consistent with our previous observations, we may speculate that optional stopping might not necessarily helps one in its journey of finding significant results. Similarly, we see a minimal variation in the level of bias!","title":"Third Extension"},{"location":"studies/optional-stopping-variation/#publication-bias_1","text":"Looking into our publication bias measures, we see similar trends as before in many different parameters pools. Egger's test perform well within higher true effect sizes, and loses its edge in lower effect sizes. Moreover, we again see a minimal influece of optional stopping on its power. One interesting difference in Egger's test performance is high positive rate within journals with low publication bias. Notice three top-right figures where we simulated a journal with no publication bias; but, Egger's test is very confident taht we are dealing with very high publication bias. The same true is for Begg's test, ie., very lower power with K = 8 , with power improving as we increase K to 24. In contrast to Egger's, Begg's test seems to be more conservative with announcing publication bias when no publication bias is present.","title":"Publication Bias"},{"location":"studies/optional-stopping-variation/#conclusion","text":"","title":"Conclusion"},{"location":"studies/optional-stopping-variation/#appendix-a-effect-of-different-number-of-attemps-in-optional-stopping","text":"","title":"Appendix A: Effect of Different Number of Attemps in Optional Stopping"},{"location":"studies/optional-stopping-variation/#effect-size-bias","text":"2 Dependent Variables 0.05 0.005 0.0005 4 Dependent Variables 0.05 0.005 0.0005","title":"Effect Size Bias"},{"location":"studies/optional-stopping-variation/#first-extension-effect-size-bias","text":"2 Dependent Variables 0.05 0.005 0.0005 4 Dependent Variables 0.05 0.005 0.0005","title":"First Extension: Effect Size Bias"},{"location":"studies/sample-size-variation/","text":"Sample Size Variation \u00b6 In this study, we will investigate the effect of sample size variation, N , on the level of bias, and probablity of finding significant results. We will also investigate whether Researcher's perseverance to design studies with N ~ 20 is driven by an unwritten property of this specific sample size. Study Design \u00b6 As with our selection variation study, we simulate a range of parameters; however, we will only use one of the listed policies, Initial S , as we have shown that there is no meaningful difference between them, see here . \u03bc \u2208 [0, 1] P b \u2208 {0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95} m \u2208 {2, 3, 4, 5, 6} N \u2208 {8, 9, ..., 99, 100} Initial S , [\"sig\", \"effect > 0\", \"random\"], [\"effect > 0\", \"min(pvalue)\"], [\"effect < 0\", \"max(pvalue)\"] In order to get an accurate picture of landscape of ES Bias, and PFS, we will simulate a full range of true effect sizes between 0 and 1, as well as a wide range of possible sample sizes. Results \u00b6 Figure below shows the contour plot of PFS against true effect size, \u03bc (y-axis), and sample size, N (x-axis). Additionally, each row is dedicated to a specific level of publication bias, P b , and each column presents a set of studies with different number of dependent variables, m . Finally, the vertical red indicator accross all plots corresponds to N = 20 . As we can see by following the trace of yellow region, ie., a region with highest PFS, Researcher's chance of finding significant results with higher effect sizes declines as the number of dependent variables decreases. Notice the slight shift of the yellow region \u2014 at the top left corner \u2014 from right to left (and top to bottom) accross all configurations as we increase the number of dependent variables. While other regions has higher concenration of significant results, the yellow region provides the higher proportion of significant results. In fact, this is the region that provides highest reward meaning if conducting a study in this region will most likely leads to an outcome with significant results. That being said, notice that fact that, in almost all configurations, the yellow region is always available for N < 20 . What this entails is the fact that N \u2272 20 always stays a viable region with high chance of finding signficant results \u2014 despite all variation of all other parameters \u2014, with m = 2 providing the highest chance of finding something significant among studies with N \u2272 20. Expectedly, researcher's chance of finding significant result declines as we lower \u0251. However, looking closely at results, we can conclude while researcher does not have as high of a chance of finding significant results, \u2013 ie., yellow region with [80%, 100%] \u2013 his chance of finding significant is still quite high and varies between 0% to 80%, with [20%, 80%] providing plenty oppurtunities. We should also point out the fact that even within very low \u0251-levels, researches with N \u2272 20 still have a higher chance of finding significant. More noticably, increasing the publication bias streches the yellow region downward by emphasizing on significant studies. In fact, we speculate that journals with higher publication bias are most likely accumulating more studies with N \u2272 20 . Landscape of Probablity of Finding Significant \u00b6 0.05 0.005 0.0005 Landscape of ES Bias \u00b6 Looking at the level of effect size bias, we oberve an interesting phenomena where increasing the number of depedent variables, m , streches the bias region toward right, meaning as we increase m , we will most definitely incrase our overall bias. Noticably, increasing the publication bias, will shift our bias toward studies with lower true effect size, \u03b8 , and larger sample size. Combined with our observations from PFS, we can speculate that journals with high publication bias are either accumulating studies with low sample size and large biases ( d > 0.6 ), or studies with large sample size and medium biases, 0.0 < d < 0.6 . Focusing our attention to a region of N \u2272 20 , we can see that the level of bias could be as high as 80% and reaching 100% as we increase the publication bias. Surprisingly, we see that lowering \u0251 will shift the bias toward higher true effect sizes, \u03b8 . As we discussed during the analysis of PFS, this phenomena entails that as we lower the \u0251, we reduce researcher's chance of finding significant results while we force those significants results to have a higher bias. Moreover, we can see the devestating effect of lower \u0251-level combined with high publications bias. In fact, to add to our conclusion, we see that journals with lower \u0251-level, will tend to accumulate publications with high biases toward upper bound of true effect size. In fact, their effect sizes look more dramatic while being grimly incorrect. 0.05 0.005 0.0005","title":"Sample Size Variation"},{"location":"studies/sample-size-variation/#sample-size-variation","text":"In this study, we will investigate the effect of sample size variation, N , on the level of bias, and probablity of finding significant results. We will also investigate whether Researcher's perseverance to design studies with N ~ 20 is driven by an unwritten property of this specific sample size.","title":"Sample Size Variation"},{"location":"studies/sample-size-variation/#study-design","text":"As with our selection variation study, we simulate a range of parameters; however, we will only use one of the listed policies, Initial S , as we have shown that there is no meaningful difference between them, see here . \u03bc \u2208 [0, 1] P b \u2208 {0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95} m \u2208 {2, 3, 4, 5, 6} N \u2208 {8, 9, ..., 99, 100} Initial S , [\"sig\", \"effect > 0\", \"random\"], [\"effect > 0\", \"min(pvalue)\"], [\"effect < 0\", \"max(pvalue)\"] In order to get an accurate picture of landscape of ES Bias, and PFS, we will simulate a full range of true effect sizes between 0 and 1, as well as a wide range of possible sample sizes.","title":"Study Design"},{"location":"studies/sample-size-variation/#results","text":"Figure below shows the contour plot of PFS against true effect size, \u03bc (y-axis), and sample size, N (x-axis). Additionally, each row is dedicated to a specific level of publication bias, P b , and each column presents a set of studies with different number of dependent variables, m . Finally, the vertical red indicator accross all plots corresponds to N = 20 . As we can see by following the trace of yellow region, ie., a region with highest PFS, Researcher's chance of finding significant results with higher effect sizes declines as the number of dependent variables decreases. Notice the slight shift of the yellow region \u2014 at the top left corner \u2014 from right to left (and top to bottom) accross all configurations as we increase the number of dependent variables. While other regions has higher concenration of significant results, the yellow region provides the higher proportion of significant results. In fact, this is the region that provides highest reward meaning if conducting a study in this region will most likely leads to an outcome with significant results. That being said, notice that fact that, in almost all configurations, the yellow region is always available for N < 20 . What this entails is the fact that N \u2272 20 always stays a viable region with high chance of finding signficant results \u2014 despite all variation of all other parameters \u2014, with m = 2 providing the highest chance of finding something significant among studies with N \u2272 20. Expectedly, researcher's chance of finding significant result declines as we lower \u0251. However, looking closely at results, we can conclude while researcher does not have as high of a chance of finding significant results, \u2013 ie., yellow region with [80%, 100%] \u2013 his chance of finding significant is still quite high and varies between 0% to 80%, with [20%, 80%] providing plenty oppurtunities. We should also point out the fact that even within very low \u0251-levels, researches with N \u2272 20 still have a higher chance of finding significant. More noticably, increasing the publication bias streches the yellow region downward by emphasizing on significant studies. In fact, we speculate that journals with higher publication bias are most likely accumulating more studies with N \u2272 20 .","title":"Results"},{"location":"studies/sample-size-variation/#landscape-of-probablity-of-finding-significant","text":"0.05 0.005 0.0005","title":"Landscape of Probablity of Finding Significant"},{"location":"studies/sample-size-variation/#landscape-of-es-bias","text":"Looking at the level of effect size bias, we oberve an interesting phenomena where increasing the number of depedent variables, m , streches the bias region toward right, meaning as we increase m , we will most definitely incrase our overall bias. Noticably, increasing the publication bias, will shift our bias toward studies with lower true effect size, \u03b8 , and larger sample size. Combined with our observations from PFS, we can speculate that journals with high publication bias are either accumulating studies with low sample size and large biases ( d > 0.6 ), or studies with large sample size and medium biases, 0.0 < d < 0.6 . Focusing our attention to a region of N \u2272 20 , we can see that the level of bias could be as high as 80% and reaching 100% as we increase the publication bias. Surprisingly, we see that lowering \u0251 will shift the bias toward higher true effect sizes, \u03b8 . As we discussed during the analysis of PFS, this phenomena entails that as we lower the \u0251, we reduce researcher's chance of finding significant results while we force those significants results to have a higher bias. Moreover, we can see the devestating effect of lower \u0251-level combined with high publications bias. In fact, to add to our conclusion, we see that journals with lower \u0251-level, will tend to accumulate publications with high biases toward upper bound of true effect size. In fact, their effect sizes look more dramatic while being grimly incorrect. 0.05 0.005 0.0005","title":"Landscape of ES Bias"},{"location":"studies/selection-variation/","text":"Selection Variation \u00b6 In this study we investigate the effect of varying Researcher's intial selection policy . As we discussed, by modifying each of the selection \u2192 decision routine, we can influence Researcher's judgments on his research. This is as we enforce the Researcher to take different paths when it comes to reporting his final outcome, a.k.a, Selective Reporting . Here, we are interested in finding how different choices influence the Probability of Finding Significant, PFS , and Level of Bias . Study Design and Parameters Pool \u00b6 We start by a simple Linear Model consists of two groups, and variable number of dependant variables. Configuration: Data Strategy \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : m , \"n_obs\" : N , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : \u03bc , \"covs\" : 0.5 , \"stddevs\" : 1.0 } } ... } In order to study the effect of selective reporting on a wide range of study design and parameters, we will simulate all combinations of following parameters: \u03bc \u2208 [0, 1] m \u2208 {2, 3, 4, 5} N \u2208 {5, 10, 20, 30, 50, 80} P b \u2208 {0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95} As discussed, we achieve the selective reporting through the alternation of initial_selection_policies , i.e., Researcher's first prefered choice. Each item in the list below indicates Researcher's first and prefered choice. [\"sig\", \"effect > 0\", \"first\"] [\"sig\", \"effect > 0\", \"random\"] [\"sig\", \"effect > 0\", \"last\"] [\"sig\", \"effect > 0\", \"min(pvalue)\"] [\"sig\", \"effect > 0\", \"max(pvalue)\"] As we discussed, initial_selection_policies is a Policy Chain Set , meaning that it can be followed by alternatives in the case of the Researcher not being able to find an outcome with the given criteria. We follow each selection with two Policy Chain , [\"effect > 0\", \"min(pvalue)\"], [\"effect < 0\", \"max(pvalue)\"] . In this configuration, our Researcher priotrizes each set after failing to satisfy the previous set. Due to the fact that the first policy chain is the only policy chain emphesizing on significant, the aggregate outcome of the simulation can be used to measure the Probablity Of Finding Significant results, a.k.a, Proportion Of Significant results. Configuration: Initial Selection Policy { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"sig\" , \"effect > 0\" , \"max(pvalue)\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"will_start_hacking_decision_policies\" : [ \"\" ], \"stashing_policy\" : [ \"\" ], \"between_hacks_selection_policies\" : [[ \"\" ]], \"between_replications_selection_policies\" : [[ \"\" ]], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] } } We can simply leave other selection and decision policies empty, as we do not plan to incorporate any further decision, hacking strategies or replications. Journal: Publication Bias 1 2 3 4 5 6 7 8 9 10 11 { ... \"journal_parameters\" : { \"max_pubs\" : k , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : Pb , \"alpha\" : \u0251 , \"side\" : 0 , } } As for Journal's configuration, we can incorporate the Significant Selection method to account for different level of publications bias that we are planning to study. Results \u00b6 Landscape of Probability of Finding Significant \u00b6 First, we look at the probability of finding significant results within the predefined hypercube of parameters enlisted above. Figure 1 is splited into 4 different parts, each showing results for a simulation study with different number of dependent variables. Overall, we see that most lines are overlapping each other. This indicates that our selections for selective reporting variation does not necessarily translate to a meaningful difference in the probability of finding significant results. However, the effect of different \u0251-level is visible and meaningful. Basically, lowering \u0251-level lowers the chance of finding significant results, as expected. Moveover, we can observe the effect of publication bias on our results. As one would expect, higher publication bias will lead to higher concentration of significant results in the Journal. In SAM, higher publication bias encourages the Journal to accept less non-significant results, therefore, more non-significant results will be discarded, see Journal . 2 3 4 5 Level of ES Bias \u00b6 Looking at the level of bias among our result, we again see alomst no difference between our different selection logics, except the case of researcher's who has priotrized [\"sig\", \"effect > 0\", \"max(pvalue)\"] which expectedly has a slightly lower bias level. Looking more closely, we can observe an steady decline of ES Bias as we increase N . This decline in bias is more apparent as we increase m , number of dependent variables. Moreover, the wild volatility of bias in lower sample sizes and higher publication biases is very noticable. 2 3 4 5 More importantly, notice the effect of \u0251 on trends of bias within rows with higher publication bias. While lower \u0251 generally lowers the level of bias, it does not behave linearly. Looking at studies with N = 20 , m \u2208 {2, 3, 4, 5} , and P b = 0.95 , we can see that lines with different \u0251 will cross each other at least once as we move toward higher true effect sizes, \u03b8 . In fact, while lowering \u0251 reduce the level bias in studies with lower true effect sizes, it promotes publications with higher bias within larger true effect sizes. Mean of Significant P-values \u00b6 Next, in order to investiage a bit deeper, we look into the distribution of significant p -values by looking at their mean withing our selected range of parameters. As expected, we can see that in every row, average p -value drops as we approach higher effect sizes, with max(pvalue) having slower decline compared to all other choices. Another interesting observation is the steady trends of average signififcant p -values for \u0251 \u2208 {0.005, 0.0005} where in both cases we do not see a large variation. Basically, significant outcomes captured with these \u0251-levels stays strongly significant in the entire range of \u03b8 . This is in contrast to trends seen with \u0251 = 0.05 , as we see variable significance-y level within the range of N , and P b . In addition, while both publication bias and sample size variation influence the intensity of significance at \u0251 = 0.05 , they barely influence it within other \u0251 levels. 2 3 4 5","title":"Selection Variation"},{"location":"studies/selection-variation/#selection-variation","text":"In this study we investigate the effect of varying Researcher's intial selection policy . As we discussed, by modifying each of the selection \u2192 decision routine, we can influence Researcher's judgments on his research. This is as we enforce the Researcher to take different paths when it comes to reporting his final outcome, a.k.a, Selective Reporting . Here, we are interested in finding how different choices influence the Probability of Finding Significant, PFS , and Level of Bias .","title":"Selection Variation"},{"location":"studies/selection-variation/#study-design-and-parameters-pool","text":"We start by a simple Linear Model consists of two groups, and variable number of dependant variables. Configuration: Data Strategy \"experiment_parameters\" : { \"n_reps\" : 1 , \"n_conditions\" : 2 , \"n_dep_vars\" : m , \"n_obs\" : N , \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : \u03bc , \"covs\" : 0.5 , \"stddevs\" : 1.0 } } ... } In order to study the effect of selective reporting on a wide range of study design and parameters, we will simulate all combinations of following parameters: \u03bc \u2208 [0, 1] m \u2208 {2, 3, 4, 5} N \u2208 {5, 10, 20, 30, 50, 80} P b \u2208 {0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95} As discussed, we achieve the selective reporting through the alternation of initial_selection_policies , i.e., Researcher's first prefered choice. Each item in the list below indicates Researcher's first and prefered choice. [\"sig\", \"effect > 0\", \"first\"] [\"sig\", \"effect > 0\", \"random\"] [\"sig\", \"effect > 0\", \"last\"] [\"sig\", \"effect > 0\", \"min(pvalue)\"] [\"sig\", \"effect > 0\", \"max(pvalue)\"] As we discussed, initial_selection_policies is a Policy Chain Set , meaning that it can be followed by alternatives in the case of the Researcher not being able to find an outcome with the given criteria. We follow each selection with two Policy Chain , [\"effect > 0\", \"min(pvalue)\"], [\"effect < 0\", \"max(pvalue)\"] . In this configuration, our Researcher priotrizes each set after failing to satisfy the previous set. Due to the fact that the first policy chain is the only policy chain emphesizing on significant, the aggregate outcome of the simulation can be used to measure the Probablity Of Finding Significant results, a.k.a, Proportion Of Significant results. Configuration: Initial Selection Policy { \"decision_strategy\" : { \"name\" : \"DefaultDecisionMaker\" , \"initial_selection_policies\" : [ [ \"sig\" , \"effect > 0\" , \"max(pvalue)\" ], [ \"effect > 0\" , \"min(pvalue)\" ], [ \"effect < 0\" , \"max(pvalue)\" ] ], \"will_start_hacking_decision_policies\" : [ \"\" ], \"stashing_policy\" : [ \"\" ], \"between_hacks_selection_policies\" : [[ \"\" ]], \"between_replications_selection_policies\" : [[ \"\" ]], \"will_continue_replicating_decision_policy\" : [ \"\" ], \"submission_decision_policies\" : [ \"\" ] } } We can simply leave other selection and decision policies empty, as we do not plan to incorporate any further decision, hacking strategies or replications. Journal: Publication Bias 1 2 3 4 5 6 7 8 9 10 11 { ... \"journal_parameters\" : { \"max_pubs\" : k , \"selection_strategy\" : { \"name\" : \"SignificantSelection\" , \"pub_bias\" : Pb , \"alpha\" : \u0251 , \"side\" : 0 , } } As for Journal's configuration, we can incorporate the Significant Selection method to account for different level of publications bias that we are planning to study.","title":"Study Design and Parameters Pool"},{"location":"studies/selection-variation/#results","text":"","title":"Results"},{"location":"studies/selection-variation/#landscape-of-probability-of-finding-significant","text":"First, we look at the probability of finding significant results within the predefined hypercube of parameters enlisted above. Figure 1 is splited into 4 different parts, each showing results for a simulation study with different number of dependent variables. Overall, we see that most lines are overlapping each other. This indicates that our selections for selective reporting variation does not necessarily translate to a meaningful difference in the probability of finding significant results. However, the effect of different \u0251-level is visible and meaningful. Basically, lowering \u0251-level lowers the chance of finding significant results, as expected. Moveover, we can observe the effect of publication bias on our results. As one would expect, higher publication bias will lead to higher concentration of significant results in the Journal. In SAM, higher publication bias encourages the Journal to accept less non-significant results, therefore, more non-significant results will be discarded, see Journal . 2 3 4 5","title":"Landscape of Probability of Finding Significant"},{"location":"studies/selection-variation/#level-of-es-bias","text":"Looking at the level of bias among our result, we again see alomst no difference between our different selection logics, except the case of researcher's who has priotrized [\"sig\", \"effect > 0\", \"max(pvalue)\"] which expectedly has a slightly lower bias level. Looking more closely, we can observe an steady decline of ES Bias as we increase N . This decline in bias is more apparent as we increase m , number of dependent variables. Moreover, the wild volatility of bias in lower sample sizes and higher publication biases is very noticable. 2 3 4 5 More importantly, notice the effect of \u0251 on trends of bias within rows with higher publication bias. While lower \u0251 generally lowers the level of bias, it does not behave linearly. Looking at studies with N = 20 , m \u2208 {2, 3, 4, 5} , and P b = 0.95 , we can see that lines with different \u0251 will cross each other at least once as we move toward higher true effect sizes, \u03b8 . In fact, while lowering \u0251 reduce the level bias in studies with lower true effect sizes, it promotes publications with higher bias within larger true effect sizes.","title":"Level of ES Bias"},{"location":"studies/selection-variation/#mean-of-significant-p-values","text":"Next, in order to investiage a bit deeper, we look into the distribution of significant p -values by looking at their mean withing our selected range of parameters. As expected, we can see that in every row, average p -value drops as we approach higher effect sizes, with max(pvalue) having slower decline compared to all other choices. Another interesting observation is the steady trends of average signififcant p -values for \u0251 \u2208 {0.005, 0.0005} where in both cases we do not see a large variation. Basically, significant outcomes captured with these \u0251-levels stays strongly significant in the entire range of \u03b8 . This is in contrast to trends seen with \u0251 = 0.05 , as we see variable significance-y level within the range of N , and P b . In addition, while both publication bias and sample size variation influence the intensity of significance at \u0251 = 0.05 , they barely influence it within other \u0251 levels. 2 3 4 5","title":"Mean of Significant P-values"},{"location":"studies/studies/","text":"Attention All examples and studies in this section are performed with slightly older version of SAM, and they were part of series of tests and experiments that we ran for validation and exploration. Experimental Studies \u00b6 In this section, we present several experimental studies, each targeting different aspects of conducting research. We start by investigating the effects of Selective Reporting on probability of finding significant results, followed by an experiment showcasing the effects of Sample Size Variation on known metrics of quality and bias. We continue by incorporating different hacking strategies to our models and tackle the sophisticated question of understanding their interactions with other aspects of conducting research and consequently their effects of meta analysis metrics. As we progress by adding more sophistications to our design, we continue incorporating our results and understandings from previous studies to our new studies. We will show that with this approach we would be able to unravel the boundary of each QRP\u2019s influence on scientific outcomes.","title":"Introduction"},{"location":"studies/studies/#experimental-studies","text":"In this section, we present several experimental studies, each targeting different aspects of conducting research. We start by investigating the effects of Selective Reporting on probability of finding significant results, followed by an experiment showcasing the effects of Sample Size Variation on known metrics of quality and bias. We continue by incorporating different hacking strategies to our models and tackle the sophisticated question of understanding their interactions with other aspects of conducting research and consequently their effects of meta analysis metrics. As we progress by adding more sophistications to our design, we continue incorporating our results and understandings from previous studies to our new studies. We will show that with this approach we would be able to unravel the boundary of each QRP\u2019s influence on scientific outcomes.","title":"Experimental Studies"},{"location":"tutorial/","text":"title: Tutorial \u00b6","title":"Index"},{"location":"tutorial/#title-tutorial","text":"","title":"title: Tutorial"},{"location":"tutorial/getting-started/","text":"After successfully installing and building SAM, you should be able to located the SAM executable, SAMrun , in your build/ folder. First thing to do at this point is to run SAMrun --help and check all its available commands and features. SAMrun Options: -h [ --help ] produce help message -v [ --version ] print version string --debug arg Print debugging information --update-config Update the config file with the drawn seeds --progress Shows the progress bar --master-seed arg (=42) Set the master seed --output-prefix arg Output prefix used for saving files --output-path arg Output path --config arg JSON config file Note Keep in mind that, you may see a slightly different command set based on the version that you are running. You can check SAMrun 's using the -v flag. Sample Run \u00b6 In your build folder you can find a sample configuration file, sample_config_file.json . You can use this file to test your simulation and check whether you've successfully build and configured SAM before running your simulation study. ./SAMrun --config = sample_config_file.json --debug = info The above command will produce an output like this: [11:23] [info] Processing the configuration file... [11:23] [info] Initializing the Researcher... [11:23] [info] Starting the simulation... [11:23] [info] Saving Overall Statistics Summaries... [11:23] [info] Saved ../outputs/sample_simulation_Publications.csv [11:23] [info] Saved ../outputs/sample_simulation_Publications_Summaries.csv Notice the last two lines where SAMrun informs you about the type and place of output files storing your results. In this case, there are two output files have been generated, and they are saved in the ../outputs/ folder. Note You can use the --debug command to control the amount of information emitted by SAMrun during the execution process. For instance, running the command above with --debug=debug will generate much larger output. [11:24] [info] Processing the configuration file... [11:24] [info] Initializing the Researcher... [11:24] [debug] Building a Data Strategy [11:24] [debug] Initializing the Journal. [11:24] [info] Starting the simulation... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [info] Saving Overall Statistics Summaries... [11:24] [info] Saved ../outputs/sample_simulation_Publications.csv [11:24] [info] Saved ../outputs/sample_simulation_Publications_Summaries.csv Running More Simulation \u00b6 As you get more comfortable with how SAMrun process your configuration file, you may want to exlore your parameters space by creating your configuration files, and feeding them to SAMrun . For instance, if you are interested in checking the effect of a specific Hacking Strategy on the full range of true effect sizes, you start by preparing a template configuration file that describes your Experiment Setup, Research, Research Workflow, and Journal. Then, you use this template file to create new configuration files each differing slightly from your original setup. In this case, you can create 10 different files to cover a range of true effect sizes from 0 to 1. Data Strategy of Configuration Files 0.0 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.0 , 0.0 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.1 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.1 , 0.1 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.2 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.2 , 0.2 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.3 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.3 , 0.3 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.4 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.4 , 0.4 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.5 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.5 , 0.5 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.6 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.6 , 0.6 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.7 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.7 , 0.7 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.8 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.8 , 0.8 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.9 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.9 , 0.9 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 1.0 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 1.0 , 1.0 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } Assuming that you are not planning to change other parameters of your simulation, these 10 configurations are all you need to run to study the influece of your Hacking Strategy and Research Workflow on the range of true effect sizes. You can run your simulation by individually passing each configuration file to SAMrun : ./SAMrun --config = sample_simulation_mu_0.0.json ./SAMrun --config = sample_simulation_mu_0.1.json ./SAMrun --config = sample_simulation_mu_0.2.json ./SAMrun --config = sample_simulation_mu_0.3.json ./SAMrun --config = sample_simulation_mu_0.4.json ./SAMrun --config = sample_simulation_mu_0.5.json ./SAMrun --config = sample_simulation_mu_0.6.json ./SAMrun --config = sample_simulation_mu_0.7.json ./SAMrun --config = sample_simulation_mu_0.8.json ./SAMrun --config = sample_simulation_mu_0.9.json ./SAMrun --config = sample_simulation_mu_1.0.json After running all the simulations, you find your outputs/ folder filled with several output files based on your preferences. In this case, SAMrun generates two output files for each configuration file, sample_simulation_mu_\u03bc_Publications.csv and sample_simulation_mu_\u03bc_Publications_Summaries.csv . Therefore, in total, there will be 20 output files ready for pre-processing. You can move these files to your preferred folder, and start analyzing them using R, or any other programming language or software. Running Even More Simulation \u00b6 As you may have realized, the process of creating new configuration files is a cumbersome and error-prone process, especially if you are planning to run thousands of different configuration files. In address this issues, we developed Frodo to be SAM's project management companion. Frodo streamlines the process of automatically creating thousands and thousands of configuration files. In addition, it helps you to run your entire simulation, deal with the complexity of naming several configuration files, and it helps you summarize and process your simulation's results. Read more about Frodo .","title":"Getting Started"},{"location":"tutorial/getting-started/#sample-run","text":"In your build folder you can find a sample configuration file, sample_config_file.json . You can use this file to test your simulation and check whether you've successfully build and configured SAM before running your simulation study. ./SAMrun --config = sample_config_file.json --debug = info The above command will produce an output like this: [11:23] [info] Processing the configuration file... [11:23] [info] Initializing the Researcher... [11:23] [info] Starting the simulation... [11:23] [info] Saving Overall Statistics Summaries... [11:23] [info] Saved ../outputs/sample_simulation_Publications.csv [11:23] [info] Saved ../outputs/sample_simulation_Publications_Summaries.csv Notice the last two lines where SAMrun informs you about the type and place of output files storing your results. In this case, there are two output files have been generated, and they are saved in the ../outputs/ folder. Note You can use the --debug command to control the amount of information emitted by SAMrun during the execution process. For instance, running the command above with --debug=debug will generate much larger output. [11:24] [info] Processing the configuration file... [11:24] [info] Initializing the Researcher... [11:24] [debug] Building a Data Strategy [11:24] [debug] Initializing the Journal. [11:24] [info] Starting the simulation... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [debug] Executing the Research Workflow! [11:24] [debug] Checking whether the Final Submission is going to be submitted to Journal... [11:24] [info] Saving Overall Statistics Summaries... [11:24] [info] Saved ../outputs/sample_simulation_Publications.csv [11:24] [info] Saved ../outputs/sample_simulation_Publications_Summaries.csv","title":"Sample Run"},{"location":"tutorial/getting-started/#running-more-simulation","text":"As you get more comfortable with how SAMrun process your configuration file, you may want to exlore your parameters space by creating your configuration files, and feeding them to SAMrun . For instance, if you are interested in checking the effect of a specific Hacking Strategy on the full range of true effect sizes, you start by preparing a template configuration file that describes your Experiment Setup, Research, Research Workflow, and Journal. Then, you use this template file to create new configuration files each differing slightly from your original setup. In this case, you can create 10 different files to cover a range of true effect sizes from 0 to 1. Data Strategy of Configuration Files 0.0 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.0 , 0.0 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.1 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.1 , 0.1 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.2 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.2 , 0.2 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.3 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.3 , 0.3 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.4 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.4 , 0.4 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.5 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.5 , 0.5 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.6 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.6 , 0.6 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.7 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.7 , 0.7 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.8 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.8 , 0.8 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 0.9 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 0.9 , 0.9 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } 1.0 { \"data_strategy\" : { \"name\" : \"LinearModel\" , \"measurements\" : { \"dist\" : \"mvnorm_distribution\" , \"means\" : [ 0.0 , 0.0 , 1.0 , 1.0 ], \"covs\" : 0.5 , \"stddevs\" : 1 } } } Assuming that you are not planning to change other parameters of your simulation, these 10 configurations are all you need to run to study the influece of your Hacking Strategy and Research Workflow on the range of true effect sizes. You can run your simulation by individually passing each configuration file to SAMrun : ./SAMrun --config = sample_simulation_mu_0.0.json ./SAMrun --config = sample_simulation_mu_0.1.json ./SAMrun --config = sample_simulation_mu_0.2.json ./SAMrun --config = sample_simulation_mu_0.3.json ./SAMrun --config = sample_simulation_mu_0.4.json ./SAMrun --config = sample_simulation_mu_0.5.json ./SAMrun --config = sample_simulation_mu_0.6.json ./SAMrun --config = sample_simulation_mu_0.7.json ./SAMrun --config = sample_simulation_mu_0.8.json ./SAMrun --config = sample_simulation_mu_0.9.json ./SAMrun --config = sample_simulation_mu_1.0.json After running all the simulations, you find your outputs/ folder filled with several output files based on your preferences. In this case, SAMrun generates two output files for each configuration file, sample_simulation_mu_\u03bc_Publications.csv and sample_simulation_mu_\u03bc_Publications_Summaries.csv . Therefore, in total, there will be 20 output files ready for pre-processing. You can move these files to your preferred folder, and start analyzing them using R, or any other programming language or software.","title":"Running More Simulation"},{"location":"tutorial/getting-started/#running-even-more-simulation","text":"As you may have realized, the process of creating new configuration files is a cumbersome and error-prone process, especially if you are planning to run thousands of different configuration files. In address this issues, we developed Frodo to be SAM's project management companion. Frodo streamlines the process of automatically creating thousands and thousands of configuration files. In addition, it helps you to run your entire simulation, deal with the complexity of naming several configuration files, and it helps you summarize and process your simulation's results. Read more about Frodo .","title":"Running Even More Simulation"},{"location":"tutorial/installation/","text":"This page helps you setup your system, install the required packages, and finally build and run SAM. Dependencies \u00b6 SAM depends on several packages: CMake (need to be installed) Boost (need to be installed) nlohmanh/json (need to be installed) Armadillo (need to be installed) LAPACK (need to be installed) BLAS (need to be installed) mlpack (need to be installed) ensmallen (need to be installed) spdlog (need to be installed) fmt . (need to be installed) Lua (need to be installed) sol2 (included) indicators (included) baaraan (included as a submodule) effolkronium/random (included) rang (included) Below you can find an instruction on how to install all these dependencies based on your operation system. Windows (WLS) \u00b6 Microsoft has recently started to embrace Linux (and open-source) by offering a first party Linux environment inside the Windows. Windows Linux Subsystem , WLS, is an example of this enviroment. As Microsoft puts it, \" The Windows Subsystem for Linux lets developers run a GNU/Linux environment \u2014 including most command-line tools, utilities, and applications \u2014 directly on Windows, unmodified, without the overhead of a traditional virtual machine or dualboot setup. \" In our tests, this in facts works better than alternatives, e.g., Cygwin, and allows you to quickly and correctly deploy an Ubuntu instance on your system. We recommend you to give this approach a try if you are a Windows user since it offers the cleanest and most robust solutions to build and run SAM in your Windows machine. If you decide to give the WLS a try, you can simply head to the Linux (Ubuntu) section of this guide and follow the same procedure without any issues. Windows (Anaconda) \u00b6 If you are using Windows, in order to avoid unneccessary complications and compilation issues, we recommend setting up your development enviroment by installing Anaconda . By installing Anaconda, you get a full-featured scientific enviroment that simplifies the process of building and managing SAM's dependencies tremendously. After installing anaconda, open the Anaconda Navigator and open the CMD.exe prompt. Here you can install the required packages using the conda command. It is advised to enter each command separately. conda install -c conda-forge cmake conda install -c conda-forge boost-cpp conda install -c conda-forge nlohmann_json conda install -c conda-forge armadillo conda install -c conda-forge mlpack conda install -c conda-forge ensmallen conda install -c conda-forge spdlog conda install -c conda-forge fmt conda install -c conda-forge lua Note You can choose to use Anaconda on macOS and Linux as well. If you go with Anaconda, then you can simply ignore the following steps. macOS \u00b6 Before you start, you need to download and install the Xcode from Mac App Store . In addition, you need to install the Command Line Tools, by running xcode-select --install in your Terminal, after successfully installing Xcode. Now, if you do not have Homebrew already installed, you may download and install from here , and after successful installation of Homebrew, you can run the following commands to install all the requirements. This may takes a few minutes... brew install cmake brew install Lua brew install boost brew install armadillo brew install ensmallen brew install mlpack brew install fmt brew install spdlog brew tap nlohmann/json ; brew install nlohmann-json Linux (Debian/Ubuntu) \u00b6 On Ubuntu, you can install most of the dependencies using the apt tool. sudo apt update sudo apt install build-essential sudo apt install cmake sudo apt install liblapack-dev libblas-dev sudo apt install libboost-all-dev sudo apt install libarmadillo-dev sudo apt install lua5.3 liblua5.3-dev For nlohmann/json , mlpack , ensmallen , fmt , and spdlog , you need to build and install these packages manually. This is due to the fact that sometimes there required version of them are not yet deployed in different Linux distros. Please follow the link to their homepage, and follow their instruction. Note Based on your distribution and version, these commands may be different, or you may end up having different versions of these packages available to you. Building SAM \u00b6 In order to build SAM, you can follow the following steps: mkdir SAM_Project cd SAM_Project git clone https://amirmasoudabdol.github.com/SAM cd SAM git submodule init ; git submodule update ; mkdir build cd build cmake .. make If this process is successful, you should have a file name SAMrun in your build/ directory. You can test whether SAM is built correctly and completely by running this command, ./SAMrun --help .","title":"Installation"},{"location":"tutorial/installation/#dependencies","text":"SAM depends on several packages: CMake (need to be installed) Boost (need to be installed) nlohmanh/json (need to be installed) Armadillo (need to be installed) LAPACK (need to be installed) BLAS (need to be installed) mlpack (need to be installed) ensmallen (need to be installed) spdlog (need to be installed) fmt . (need to be installed) Lua (need to be installed) sol2 (included) indicators (included) baaraan (included as a submodule) effolkronium/random (included) rang (included) Below you can find an instruction on how to install all these dependencies based on your operation system.","title":"Dependencies"},{"location":"tutorial/installation/#windows-wls","text":"Microsoft has recently started to embrace Linux (and open-source) by offering a first party Linux environment inside the Windows. Windows Linux Subsystem , WLS, is an example of this enviroment. As Microsoft puts it, \" The Windows Subsystem for Linux lets developers run a GNU/Linux environment \u2014 including most command-line tools, utilities, and applications \u2014 directly on Windows, unmodified, without the overhead of a traditional virtual machine or dualboot setup. \" In our tests, this in facts works better than alternatives, e.g., Cygwin, and allows you to quickly and correctly deploy an Ubuntu instance on your system. We recommend you to give this approach a try if you are a Windows user since it offers the cleanest and most robust solutions to build and run SAM in your Windows machine. If you decide to give the WLS a try, you can simply head to the Linux (Ubuntu) section of this guide and follow the same procedure without any issues.","title":"Windows (WLS)"},{"location":"tutorial/installation/#windows-anaconda","text":"If you are using Windows, in order to avoid unneccessary complications and compilation issues, we recommend setting up your development enviroment by installing Anaconda . By installing Anaconda, you get a full-featured scientific enviroment that simplifies the process of building and managing SAM's dependencies tremendously. After installing anaconda, open the Anaconda Navigator and open the CMD.exe prompt. Here you can install the required packages using the conda command. It is advised to enter each command separately. conda install -c conda-forge cmake conda install -c conda-forge boost-cpp conda install -c conda-forge nlohmann_json conda install -c conda-forge armadillo conda install -c conda-forge mlpack conda install -c conda-forge ensmallen conda install -c conda-forge spdlog conda install -c conda-forge fmt conda install -c conda-forge lua Note You can choose to use Anaconda on macOS and Linux as well. If you go with Anaconda, then you can simply ignore the following steps.","title":"Windows (Anaconda)"},{"location":"tutorial/installation/#macos","text":"Before you start, you need to download and install the Xcode from Mac App Store . In addition, you need to install the Command Line Tools, by running xcode-select --install in your Terminal, after successfully installing Xcode. Now, if you do not have Homebrew already installed, you may download and install from here , and after successful installation of Homebrew, you can run the following commands to install all the requirements. This may takes a few minutes... brew install cmake brew install Lua brew install boost brew install armadillo brew install ensmallen brew install mlpack brew install fmt brew install spdlog brew tap nlohmann/json ; brew install nlohmann-json","title":"macOS"},{"location":"tutorial/installation/#linux-debianubuntu","text":"On Ubuntu, you can install most of the dependencies using the apt tool. sudo apt update sudo apt install build-essential sudo apt install cmake sudo apt install liblapack-dev libblas-dev sudo apt install libboost-all-dev sudo apt install libarmadillo-dev sudo apt install lua5.3 liblua5.3-dev For nlohmann/json , mlpack , ensmallen , fmt , and spdlog , you need to build and install these packages manually. This is due to the fact that sometimes there required version of them are not yet deployed in different Linux distros. Please follow the link to their homepage, and follow their instruction. Note Based on your distribution and version, these commands may be different, or you may end up having different versions of these packages available to you.","title":"Linux (Debian/Ubuntu)"},{"location":"tutorial/installation/#building-sam","text":"In order to build SAM, you can follow the following steps: mkdir SAM_Project cd SAM_Project git clone https://amirmasoudabdol.github.com/SAM cd SAM git submodule init ; git submodule update ; mkdir build cd build cmake .. make If this process is successful, you should have a file name SAMrun in your build/ directory. You can test whether SAM is built correctly and completely by running this command, ./SAMrun --help .","title":"Building SAM"}]}